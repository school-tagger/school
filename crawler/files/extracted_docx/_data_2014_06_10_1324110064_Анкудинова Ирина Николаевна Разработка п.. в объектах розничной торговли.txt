ПРАВИТЕЛЬСТВО РОССИЙСКОЙ ФЕДЕРАЦИИ

Федеральное государственное автономное образовательное

учреждение высшего профессионального образования

"Национальный исследовательский университет

"Высшая школа экономики"

Пермский филиал

Факультет бизнес-информатики



Кафедра информационных технологий в бизнесе









УДК 004 .65









РАЗРАБОТКА ПРОГРАММНОГО СРЕДСТВА ОЦЕНКИ ВОСТРЕБОВАННОСТИ ТЕРРИТОРИЙ ГОРОДА В ОБЪЕКТАХ РОЗНИЧНОЙ ТОРГОВЛИ

Выпускная квалификационнаяработа бакалавра













Работу выполнил студент

группы БИ-10-1

4 курса факультета бизнес-информатики

	Анкудинова И.Н.



Научный руководитель:

доцент кафедры информационных технологий

 в бизнесе, к.п.н.доцент,

	КушевВ.О.

“_____” 20__ г.





Пермь 2014

СПИСОК ТЕРМИНОВ И СОКРАЩЕНИЙ

В работе встречаются следующие термины и сокращения, требующие разъяснения:

БД – база данных.

СППР – система поддержки принятия решений.

UML – язык графического описания для объектного моделирования.





Введение

Для эффективного развития экономики страны необходимо правильное сочетание малого, среднего и крупного бизнеса. Благодаря их сложному взаимодействию определяется уровень жизни населения.

Важное место в современной экономике занимает малый и средний бизнес, так как именно он способствует развитию конкуренции, регулирует цены на товары, определяет качество валового продукта. Поэтому создаются различные программы по поддержке малого и среднего бизнеса, в том числе для начинающих предпринимателей. В то же самое время для малого и среднего бизнеса характерна значительная зависимость от внешней среды, поэтому при формировании собственного предприятия возникают различные препятствия, в частности территориальные. Например, если неправильно определить местоположение для создаваемого бизнеса, можно потерять достаточно много клиентов из-за отсутствия спроса в данном регионе. Поэтому при создании бизнеса необходимо определить территорию, приносящую наибольшую доходность по предлагаемым услугам или продуктам, однако этот процесс является достаточно трудоемким из-за анализа большого количества информации.

Сектор розничной торговли является неотъемлемой частью бизнеса, так как оказывает значительное влияние и на другие отрасли и затрагивает все слои населения. Таким образом, проблема определения местоположения для создаваемого бизнеса будет решаться относительно объектов розничной торговли. Из чего следует, что объектом исследования является совокупность объектов розничной торговли на территории города Перми, а предметом исследования – совокупность методов оценки востребованности территорий в объектах розничной торговли. 

Целью работы является автоматизация оценки востребованности территорий города Перми в объектах розничной торговли для определения наиболее подходящего местоположения для осуществления выбранного вида розничной торговли.

Оценка востребованности территорий уменьшит риски неудачи разорения нового торгового объекта, так как будет учтен ряд критериев, характеризующий спрос на предлагаемый продукт. Поскольку необходимо проводить анализ большого количества разнородных данных, существует потребность в создании программного средства, реализующего обработку данных и предлагающего решение поставленной проблемы, то есть о нахождении наиболее выгодном местоположении для торгового объекта. Таким образом, определены следующие задачи:

описание предметной области;

проектирование модели анализа данных;

разработка программного средства;

разработка технического задания;

разработка экономического обоснования.

Предпроектное исследование

Первая глава посвящена изучению предметной области и описанию проблемы, обзору существующих решений, а также анализу литературы, использованной в работе. 

Описание проблемы

Малый и средний бизнес благоприятно влияют на экономику страны: уменьшается процент безработицы, увеличивается уровень доходов, развивается конкуренция и т.д. Также на экономику значительно влияет розничный сектор, определяющий уровень жизни в стране. Развитие сектора способствует изменению конечных потребительских цен, благодаря географической доступности товаров повышается уровень обеспеченности населения, который представляет собой один из индикаторов качества жизни населения. Благодаря жесткой конкуренции диктуются высокие стандарты качества, соответственно данный сектор контролирует качество продукции, попадающей к потребителю. Также розничная торговля влияет на стабильность государства, так как является источником поступления денежных средств и вносит серьезный вклад в развитие отдельных регионов страны [8]. 

Основной проблемой в среднем и малом бизнесе является то, что фирмы в данной области достаточно часто разоряются, так как предприятия достаточно сильно зависят от внешних факторов. Далее рассмотрены причины разорения предприятий.

Отсутствие опыта. Для создания собственного бизнеса руководитель должен иметь определенный опыт в данной сфере, иначе высок риск провала на первых этапах.

Дефицит оборотных средств. В большинстве случаев, предприниматели малого и среднего бизнеса недостаточно времени уделяют на расчет всевозможных расходов при создании предприятия.

Высокие эксплуатационные траты. Предприниматель должен сосредоточить свое внимание на снижении затрат, не оказывающих реального влияния на уровень доходов, при этом не снижая качество предлагаемого продукта или услуги.

Неудачное местонахождение предприятия. Определение неправильного местоположения может привести к большим затратам и к дальнейшему банкротству из-за отсутствия спроса, большой удаленности от поставщиков.

Отсутствие плана, либо целей. Открывая собственный бизнес, необходимо составить бизнес-план, содержащий цели, задачи, временные рамки [3]. Зачастую предприниматели малого бизнеса не составляют бизнес-планов и не могут точно сформулировать цели и задачи.

Данный список представляет собой наиболее часто встречающиеся причины разорения нового предприятия, поэтому список может быть увеличен. В данной работе рассматривается именно решение проблемы неправильного выбора местоположения для предприятия.

Предприниматели малого и среднего бизнеса редко проводят тщательный анализ своего предприятия. Таким образом, не учитывается множество факторов, которые будут способствовать его развитию или, наоборот, банкротству. Правильно выбранная территория значительно сокращает риски разорения бизнеса, поэтому предприниматели должны уметь определять основные характеристики своего бизнеса, влияющие на выбор его местоположения.

Выбор размещения нового бизнеса значительно повлияет на его доходность в дальнейшем. Необходимо соотнести и проанализировать большое количество информации, чтобы прийти к правильному решению. Одним из главных факторов, влияющих на прибыльность торгового объекта, является потребительская аудитория предлагаемого продукта. От того насколько точно будет определен потребитель зависит дальнейший успех бизнеса. Таким образом, выбор местоположения нужно делать относительно преобладающих категорий людей на территории.

Обзор существующих методов

Существуют различные методики, используемые компаниями для определения размещения бизнеса. На данном этапе рассматриваются наиболее распространенные из них [9]:

Метод контрольного списка. Первый метод можно назвать рейтинговой методикой или методом контрольного списка. Он предполагает оценку каждого варианта размещения магазина по фиксированному набору параметров. Значение параметров для всех вариантов оценивается экспертом. Шкала (но не ее вид) неявно определяется самим экспертом по каждому параметру. Метод контрольного списка стал, пожалуй, самым распространенным методом для принятия решений по местоположению как в России, так в США и Западной Европе. Очевидным преимуществом является его простота и дешевизна. Кроме того, в некоторых случаях высококвалифицированный и опытный эксперт может дать оценку более точную, чем любой существующий статистический метод. Для использования данного метода в компании должен работать эксперт, умеющий точно оценивать площадки.

Аналоговый подход. Аналоговый подход основан на использовании значений некоторых характеристик существующих торговых точек в качестве основы прогноза для новых. Затем оптимальное на основе максимизации оборота или ожидаемой прибыли точки выбирается место. В аналоговом подходе используются характеристики торговых точек, предположительно не изменяющиеся между объектами одного типа. На первом шаге применения аналогового подхода необходимо отобрать ряд действующих торговых точек, схожих по всем основным характеристикам, за исключением, возможно, плотности населения в районе. На втором шаге оценивается способность торговых точек привлекать клиентов. Обычно в этих целях в качестве достаточно точного и дешевого метода используется опрос клиентов в торговых залах. На третьем, заключительном шаге расчетов аналитик должен вычислить оборот новой торговой точки. В простейшем случае это можно сделать путем подсчета численности целевого сегмента в предполагаемой зоне охвата новой торговой точки.

Регрессионный анализ. Зачастую используют еще более очевидный и строгий подход, основанный на построении регрессии оборота от основных характеристик размещения магазина. Выбирается место, обеспечивающее максимально ожидаемое значение оборота. Выборка формируется так же, как и во втором случае: эксперт отбирает группу сходных предприятий. Однако это сходство не должно быть уже столь близким, как в аналоговом подходе. Достаточно лишь, чтобы все магазины относились к одному типу предприятий (гипермаркет, супермаркет и т.д.). Переменные, описывающие расположение каждого магазина, могут быть получены из стандартных контрольных листов. Кроме того, в число регрессоров включаются переменные, описывающие рынок в зоне размещения, характеристики торговых точек, потребителей, цены и уровень конкуренции. Принципиально важно, чтобы значения каждой переменной по всем точкам выборки оценивались одним экспертом. В целом метод достаточно часто применялся в случаях сетевых розничных компаний. Регрессионный анализ использовался для выбора местоположения продовольственных магазинов, отделений банков, винных магазинов, отелей.Для проведения регрессионного анализа существует множество программных средств, например:

MINITAB – решение, предоставляющее средства для выполнения каждой фазы проекта повышения качества, включая такие функции, как StatGuide и ReportPad, позволяющие обрабатывать результаты анализа [6].

WEKA - продукт университета Уайкато (Новая Зеландия), обеспечивающий графический пользовательский интерфейс для работы с файлами данных и генерации визуальных результатов (в виде таблиц и графиков). Кроме того, можно интегрировать WEKA, как и любую другую библиотеку, в свои собственные приложения, например, для автоматизации анализа данных на стороне сервера, используя стандартный API [6].

MSExcel – прикладная программа, входящая в MSOffice, предназначена для обработки информации с помощью электронных таблиц [5].

Помимо вышеперечисленных решений существует множество других, реализующих регрессионный анализ.

Модели выявленных предпочтений. Модели выявленных предпочтений являются развитием пространственных моделей. Смысл состоит в том, чтобы на основе фактических пространственных данных о выборе магазинов респондентами оценить параметры модели для прогноза рыночной доли. Значения параметров оцениваются эконометрическим путем. На основе доли предприятия можно оценить оборот, прибыль и привлекательность той или иной точки. Кроме того, данный метод позволяет вместе с местом выбрать и оптимальную концепцию предприятия для каждого варианта размещения.

Для любого из вышеперечисленных методов могут использоваться различные программные средства, реализующие расчет по параметрам. Но ни одно из них целенаправленно не предлагает решение по выбору наиболее выгодного местоположения для нового бизнеса. Кроме того, перечисленными методами пользуются компании крупного бизнеса. Индивидуальные предприниматели не проводят анализ с помощью существующих громоздких методик, так как не требуется подсчета большого количества экономических показателей в малом и среднем бизнесе. А также использование некоторых методик является дорогостоящим средством для создания данного вида предприятия.

Основные понятия и определения

Для того, чтобы разобраться в предметной области и ее объектах используются онтологии. Существует множество определений данного термина. 

Согласно определению Гладун А.Я. [2]: «Онтология состоит из терминов (понятий), их определений и атрибутов, а также связанных с ними аксиом и правил вывода.

Формальная модель онтологии O=<Т, R, F> — это упорядоченная тройка конечных множеств, где:

Т — термины прикладной области (ПрО), которую описывает онтология O; 

R — отношения между терминами заданной ПрО; 

F — функции интерпретации, заданные на терминах и/или отношениях онтологии O. 

Модели онтологий классифицируются таким образом:

простые (имеют лишь концепты);

на основе фреймов (имеют лишь концепты и свойства); 

на основе логик (напримерOntolingua, DAML+OIL)».

Д.Кудрявцев дает следующее определение онтологии [7]: «Онтология — формальная спецификация разделяемой концептуальной модели, где: 

под «концептуальной» моделью подразумевается абстрактная модель предметной области, описывающая систему понятий предметной области,

под «разделяемой» подразумевается согласованное понимание концептуальной модели определенным сообществом (группой людей),

«спецификация» подразумевает описание системы понятий в явном виде,

«формальная» подразумевает, что концептуальная модель является машиночитаемой».

В целом можно сказать, что в рамках данной работы онтология является концептуализацией предметной области для отображения основных классов объектов, влияющих на выбор прибыльной территории. В работе используется плагин OntoGraphдля представления иерархии понятий проектируемой модели. Так как модель содержит большое количество экземпляров, данное средство подходит наилучшим образом для данной задачи.

В рамках данной работы будет использоваться UML язык. Унифицированный язык моделирования UML (Unified Modeling Language) – графический язык моделирования для описания, проектирования, визуализации и документирования в объектно-ориентированном анализе. В рамках данной работы используется диаграмма классов, определяющая типы объектов системы и различного рода статические связи, которые существуют между ними. На диаграммах классов изображаются также атрибуты классов, операции классов и ограничения, которые накладываются на связи между объектами[4]. Построенная диаграмма классов позволяет формализовать концепцию модели, а также отобразить связи между классами, не представленные в онтологии с помощью плагина OntoGraph.

Для того, чтобы автоматизировать оценку востребованности территорий, будет реализован прототип системы поддержки принятия решений (СППР).Согласно определению Барсегян: «СППР — это системы, обладающие средствами ввода, хранения и анализа данных, относящихся к определенной предметной области, с целью поиска решений. Основная задача СППР — предоставить аналитикам инструмент для выполнения анализа данных»[1].

Барсегян дает достаточно содержательное определение, включая основные характеристики СППР. Также Барсегян рассматривает архитектуру СППР.

Подсистема ввода данных. В таких подсистемах, называемых OLTP (Online transaction processing), выполняется операционная (транзакционная) обработка данных. Для реализации этих подсистем используют обычные системы управления базами данных (СУБД).

Подсистема хранения. Для реализации данной подсистемы используют современные СУБД и концепцию хранилищ данных.

Подсистема анализа. Данная подсистема может быть построена на основе:

подсистемы информационно-поискового анализа на базе реляционных СУБД и статических запросов с использованием языка структурных запросов SQL (Structured Query Language);

подсистемы оперативного анализа. Для реализации таких подсистем применяется технология оперативной аналитической обработки данных OLAP (On-line analytical processing), использующая концепцию многомерного представления данных;

подсистемы интеллектуального анализа. Данная подсистема реализует методы и алгоритмы Data Mining ("добыча данных") [1].

СППР реализует модели, разработанные экспертами, в совокупности с эвристическими методами поиска решений. Существуют различные классификации СППР.

По способу взаимодействия с пользователем выделяют следующие типы СППР: 

пассивные системы не позволяют выдвинуть конкретное предложение, несмотря на реализацию средств, в различной степени поддерживающих пользователя при поиске наиболее эффективного решения; 

активные системы непосредственно участвуют в поиске и подготовке наиболее оптимального решения; 

кооперативные системы предоставляют пользователю возможность доработать найденные ими решение, а затем проверить внесѐнные пользователем коррективы [3].

По способу поддержки различают: 

модельно-ориентированные СППР, выполняют поиск оптимальных решений основываясь на специально разработанные модели (статистические, финансовые и т.п.); 

СППР, ориентированные на данные, организуют поддержку пользователя при поиске эффективных решений, агрегируя большие объѐмы данных из гетерогенных источников; 

СППР, ориентированные на знания, выполняют поиск оптимальных решений, основываясь на специально разработанной базе знаний [3]. 

Чаще всего встречаются СППР смешанного типа. 

По сфере использования выделяют: 

настольные СППР – небольшие системы, ориентированные на использование одним пользователем, работающим на персональном компьютере; 

общесистемные СППР, используют в своей работе большие хранилища данных и ориентированы на использование многими пользователями [3]. 

Поиск решений в СППР строится в большинстве случаев на основе концепции Knowledge Discovery in Database (KDD), которая реализует процесс поиска полезных знаний в “сырых” данных. Схема представлена на рисунке ниже: 



Рисунок 1.1. Концепция KDD

Данный процесс состоит из следующих этапов:

Подготовка исходного набора данных. Этот этап заключается в создании набора данных, в том числе из различных источников. Для этого необходимо обеспечить различные инструменты доступа к источникам данных.

Предобработка данных. Как правило, полученные данные являются недостаточными или избыточными, в них могут содержаться шумы, пропуски и т.д. Таким образом, этап предобработки необходим для преобразования данных в корректные данные и их дальнейшей подачи на вход системы.

Трансформация и нормализация данных. На этом этапе информация приводится к пригодному для последующего анализа виду с помощью следующих операций: приведение типов, квантование, приведение к «скользящему окну» и т.д.

Data Mining. Данный этап предполагает использование различных алгоритмов, таких как деревья решений, нейронные сети, установления ассоциаций и т.д.

Постобработка данных. На выходе полученные знания интерпретируются и применяются.

В целом, KDD определяет пошаговые действия для преобразования данных в практически полезные знания. 

Далее рассмотрим технологию Data Mining и основные алгоритмы. Барсегян дает достаточно точное описание термина Data Mining: «Технология Data Mining (также называемая Knowledge Discovery In Data —обнаружение знаний в данных) изучает процесс нахождения новых, действительных и потенциально полезных знаний в базах данных. Data Mining лежит на пересечении нескольких наук, главные из которых — это системы баз данных, статистика и искусственный интеллект». Задачи, решаемые методами Data Mining[11]:

классификация – это отнесение объектов (наблюдений, событий) к одному из заранее известных классов;

регрессия, в том числе задачи прогнозирования. Установление зависимости непрерывных выходных от входных переменных;

кластеризация – это группировка объектов (наблюдений, событий) на основе данных (свойств), описывающих сущность этих объектов;

ассоциация – выявление закономерностей между связанными событиями;

последовательные шаблоны – установление закономерностей между связанными во времени событиями, т.е. обнаружение зависимости, что если произойдет событие X, то спустя заданное время произойдет событие Y;

анализ отклонений – выявление наиболее нехарактерных шаблонов.

 Книга «10 самых эффективных алгоритмов Data Mining», написанная на основе проведенной конференции по Data Mining (the IEEE International Conferenceon Data Mining), определяет классификацию алгоритмов Data Mining[5].

С4.5. – набор алгоритмов для классификации проблем в области машинного обучения и интеллектуального анализа данных (ориентирован на обучение с учителем).

Алгоритмы k-средних(k-means) – простые широко используемые алгоритмы кластеризации. Цель кластеризации или сегментации разделить используемые объекты (записи) на группы или кластеры таким образом, чтобы объекты внутри кластеры были схожи друг с другом, в отличие от объектов, принадлежащим разным группам.

Метод опорных векторов (support vector machine), включающий классификатор опорных векторов (support vector classifier) и регрессию опорных векторов (support vector regression).

Алгоритм Apriori или AprioriTid – алгоритм поиска ассоциативных правил.

EM-алгоритм (Excpectation-Maximization) – широко используется в различных областях, таких как интеллектуальный анализ данных, машинное обучение, распознавание образов.

Алгоритм Page Rank хорошо известный алгоритм ранжирования интернет-страниц, которым также пользуется Google.

Алгоритмы Ada Boost (adaptive boosting) одни из самых эффективных алгоритмов для повышения точности аналитических моделей.

Метод ближайших соседей (k-nearest neighbor classification) осуществляет поиск группы k-объектов в обучающем наборе расстояние до которых минимально и определении класса, наиболее встречающегося среди k-ближайших соседей.

«Наивная классификации» (Naïve Bayes) - легко интерпретируемые метод о взаимной независимости признаков.

Алгоритм CART: Classification and Regression Tree представляет важную веху в эволюции искусственного интеллекта, машинного обучения, непараметрической статистики и анализа данных.

Вышеперечисленные алгоритмы являются наиболее распространенными для обнаружения в данных практически полезных знаний. Так как поставленная задача является специфической, в связи с возможными сложностями относительно построения отношений между объектами, например, между объектом Остановка и объектом Организация, было принято решение разработать модель, нацеленную на решение задач в рамках данной предметной области. Далее концепцию данной модели необходимо использовать при разработке программного средства. 

В данной главе были рассмотрены основные классификации СППР, процесс поиска решений. Также представлен обзор основных алгоритмов Data Mining.

Проектирование модели анализа данных

Глава представляет описание и анализ предметной области, определение основных экземпляров, необходимых при проектировании модели. Также в данной главе рассмотрена основная концепция проектируемой модели и разработанные алгоритмы решения поставленной задачи.

Анализ предметной области

Для решения задачи определения прибыльного местоположения необходимо разобраться тщательно в предметной области и во всех связующих факторах и определить, какие основные объекты необходимо рассматривать для проектирования модели анализа.

Главным фактором, влияющим на доходность торговой точки, является спрос на товар, а рыночный спрос на товар определяется совокупностью индивидуальных спросов покупателей. У каждого товара есть своя целевая аудитория. Таким образом, предприниматель должен уметь определять категории покупателей, у которых предлагаемый товар будет пользоваться спросом. На каждой территории в городе можно найти категорию или набор категорий покупателей, являющиеся преобладающими в данной области.  Далее возникает необходимость определить основные области в городе, где данный спрос высок, или, другими словами, где перемещается предполагаемый покупатель.

Одним из решений для определения перемещения различных категорий клиентов является рассмотрение всех объектов, расположенных на территории города. В данном контексте объектами являются предприятия города Перми, такие как образовательные учреждения, торговые предприятия и т.д. Каждый из таких объектов содержит определенный набор преобладающих категорий покупателей, например, услугами салона красоты в основном пользуются женщины, в институте преобладающей категорией являются студенты.

Для удобства анализа необходимо разделить город на территории, внутри которых будут рассматриваться объекты. В качестве решения территория города поделена на области между автобусными остановками, и каждый из таких территорий содержит различные категории покупателей.

Для визуализации предметной области и представления иерархии понятий была построена онтология, отображающая основные экземпляры, участвующие при проектировании модели анализа (см. рис.2.1.).



Рисунок 2.1. Онтология предметной области

Спроектированная онтология представляет собой иерархию экземпляров. Каждое из понятий, включенное в модель, участвует в анализе данных. Для визуализации иерархии в виде дерева был использован плагин OntoGraph.

На самом верхнем уровне дерева расположились следующие компоненты:

Остановка. Здесь подразумеваются все автобусные остановки города. Атрибутами экземпляра являются:

название;

широта;

долгота.

Классификация по типу объекта. Экземпляр представляет собой классификацию для каждого объекта города. У данного экземпляра единственный атрибут:

название.

Классификация покупателей/клиентов. Экземпляр включает различную категоризацию людей. Атрибутом данного экземпляра является:

название.

Рассмотрим каждый из экземпляров более подробно. Для того, чтобы определить какие категории людей или, другими словами, категории потребителей преобладают на каждой из территории, необходимо знать какие объекты на данной области располагаются, а также информацию каждого объекта об их клиентообороте. Поэтому также необходимо типизировать все возможные объекты в г. Пермь (см. рис.2.2.).



Рисунок 2.2. Онтология классификации по типу объекта.

На представленной онтологии отображена часть входящих в нее экземпляров. Компонент «Классификация по типу объекта» включает в себя 60 экземпляров, каждый из которых соответствует классификации объектов карты Google Maps. Кроме того, в данную классификацию введен экземпляр новый розничный торговый объект, который является анализируемым объектом для поиска прибыльной территории.

Онтология изучаемой предметной области также содержит классификацию покупателей, представленную на рис 2.3.



Рисунок.2.3. Онтология категорий потребителей

Данная классификация содержит ряд экземпляров.

По интересам (см. рис.2.4.). В данной классификации отображены основные сферы деятельности людей:

искусство;

спорт;

наука;

красота;

юриспруденция;

техника/проектирование;

строительство/квартира;

автомобили;

медицина;

экономика/финансы;

развлечение;

животные.



Рисунок 2.4. Классификация людей по интересам.

В данном случае, люди будут классифицироваться по их основной деятельности или увлечениям, например, посетители мебельного магазина будут относиться к категории «Строительство/квартира».

По занятости (см. рис. 2.5.); экземпляр идентифицирует людей по их текущей занятости:

дошкольник;

школьник;

студент;

работник;

пенсионер.



Рисунок 2.5. Классификация людей по занятости

Данная классификация достаточно близка к возрастной периодизации, однако имеет некоторые различия, например, молодой человек в возрасте от 18 до 24 может никогда не быть студентом, однако будет являться работником. Но потребности работника 20 лет и 35 существенно различаются. 

Возрастная периодизация (см.рис.2.6.). За основу взята возрастная периодизация Эрика Эриксона:

раннее детство (0-6);

школьный возраст(7-12);

юность(13-20);

молодость(21-25);

взрослость(26-60);

старость (от 60).



Рисунок 2.6. Классификация людей по возрастной периодизации

Данная классификация может быть полезной для предприятий, проводящих социологические опросы и достаточно хорошо знающих своих потребителей.

По полу (см.рис.2.7.). Экземпляр идентифицирует людей по полу:

мужской;

женский.



Рисунок 2.7. Классификация людей по полу

Данная классификация применима, например, для салона красоты, так как преобладающей категорией являются женщины.

Разработка модели анализа данных

Рассмотрим подробно проектируемую модель анализа данных. На данном этапе необходимо определить способ деления территорий между остановками. Как было сказано ранее, спрос на товар предприятия зависит от правильной идентификации категорий людей, потребляющих данный товар или услугу. Следовательно, город необходимо разделить на области таким образом, чтобы можно было к каждой территории привязать определенный набор категорий покупателей. Было принято решение, что территория для любого объекта будет определяться тремя ближайшими остановками к данному объекту. Таким образом, каждый объект в городе будет принадлежать трем ближайшим остановкам, или, другими словами, вокруг каждой остановки будет образован некоторый потенциал объектов. Так как каждый объект содержит в себе некоторые категории людей, для каждой остановки также можно получить категории людей от соответствующих объектов. 

Представим данную модель в виде ориентированного графа G, который задается двумя множествами G=(V, E), где V – конечное множество, элементы которого называют вершинами или узлами, E – множество упорядоченных пар на V. Узлами графа являются объекты и остановки, дугами являются потоки данных (категории потребителей) (см. рис 2.8.). 



Рисунок 2.8. Связь и передача данных между объектом и остановкой

Введем ряд ограничений:

Дуга всегда является исходящей из вершины “Объекта” и заходящей в вершину “Остановка”.

Не существует исходящих дуг из вершины “Остановка”.

Обоснуем выбор окружения объекта тремя остановками. 

Одна остановка. Охватывает недостаточное количество объектов.

Две остановки. Для того чтобы определить некоторую область с преобладающими категориями людей необходимо взять минимум две ближайшие автобусные остановки. В большинстве случаев данные остановки будут представлять собой одну, разделенную на два противоположных маршрута. Данная территория будет охватывать небольшое количество объектов, таким образом, увеличивается вероятность получения недостаточного количества информации о категориях людей, что повлияет на итоговое решение.

Три остановки. Три ближайшие остановки к объекту будут образовывать некий треугольник, содержащий преобладающие категории людей.

Четыре остановки. Полученный четырехугольник будет охватывать слишком большую территорию для дальнейшего анализа, так как остановки расположены достаточно на большом расстоянии друг от друга. В противном случае данная территория будет содержать почти все категории людей, что будет являться неприемлемым для решения задачи. Кроме того, сложность данного алгоритма увеличивается.

Привлекательность размещения новой торговой точки на предполагаемой области можно будет оценить, сравнивая категории людей, перемещающихся в данной области, и категории, необходимые для дальнейшего процветания предприятия малого или среднего бизнеса.

Для формализации данной модели была использована диаграмма классов UML (см. рис. 2.9.). 



Рисунок 2.9. Диаграмма классов UML для анализируемой модели

Данный вид диаграммы был выбран благодаря возможности отображения основных классов системы, их атрибутов и зависимостей между классами.

Данные для анализа получены благодаря системе учета объектов розничной торговли и их окружения, которая нацелена на выгрузку объектов с карты Google Maps. Так как объекты не содержат информацию о категориях потребителей, каждому объекту был присвоен ряд категорий людей, представленных в онтологии, экспертным путем (см. приложение Е). Для классификации по занятости и возрастной периодизации было введено ограничение: для каждого объекта города по данным классификациям необходимо определить не более двух экземпляров, т.е. выделить целевую аудиторию по данным классификациям.

Для того чтобы проверить корректность спроектированной модели анализа данных, будет разработан прототип СППР, реализующий концепцию модели.

Предполагается, что приложение должно позволять определять наиболее прибыльное местоположение двумя способами:

пользователь выбирает категории потребителей для новой торговой точки и ее возможное местоположение. В результате система должна предоставить ответ пользователю:

прибыльное;

убыточное.

пользователь выбирает категории потребителей для новой торговой точки. В качестве решения система предоставляет ряд местоположений в городе Перми, расположенных в порядке уменьшения привлекательности.

Рассмотрим алгоритм решения каждого из методов.

Алгоритм с указанием адреса.

Система получает информацию об открываемой торговой точке от пользователя. Данная информация включает в себя выбор трех преобладающих категорий потребителей и адрес предполагаемого размещения. 

Система определяет три ближайшие остановки для данного адреса. Так как каждый объект и остановка содержат данные о координатах, можно определить расстояние между любыми двумя объектами с помощью формулы гаверсинусов.

где 1,2, – широта и долгота двух точек в радианах,   - разница 

Для каждой остановки на данной территории определяется информация о категориях покупателей, введенные пользователем.

Система определяет территорию, наиболее подходящую для размещения торговой точки

Система сравнивает доли категорий покупателей на предполагаемой области размещения и наиболее подходящей.

После анализа данных пользователь получает один из вариантов ответа.

В том случае, если доля категорий покупателей на рассматриваемой области составляет более 40% от наиболее подходящей территории, система определяет территорию как прибыльную.

В том случае, если доля категорий покупателей на рассматриваемой области составляет менее 40% от наиболее подходящей территории, система определяет территорию как убыточную.

Данный алгоритм представлен в виде блок-схемы в Приложении A.

Алгоритм без указания адреса:

Система получает информацию об открываемой торговой точке от пользователя. Данная информация включает в себя выбор трех преобладающих категорий потребителей и адрес предполагаемого размещения.

Система выбирает по городу остановки, содержащие информацию о данных категориях людей.

Для каждой остановки определяются две ближайшие к ней, таким образом формируются территории.

Методом перебора рассматривается каждая территория и подсчитываются доли каждой из категорий.

Выводит в рейтинг первые пять прибыльных территорий.

Данный алгоритм представлен в виде блок-схемы в Приложении B.

В ходе разработки программного средства было принято решение отказаться от классификации категорий потребителей по полу для оценки территорий. Так как каждая территория содержит большое количество объектов, в совокупности на каждой территории перемещается примерно равное количество мужчин и женщин. Небольшая разница в долях присутствия мужчин и женщин на рассматриваемых областях не должна повлиять на доходность торгового объекта. Однако, программное средство реализовывает подсчет данных долей при желании пользователя.

Далее рассмотрим, как выбираются более привлекательные для расположения территории и как подсчитываются доли по категориям покупателей на этих территориях. В каждой анализируемой области в большинстве случаев содержатся все элементы классификации возрастная периодизация и классификации по занятости. В то время как, классификация по интересам встречается реже. Поэтому, каждой из классификаций присваивается коэффициенты в сумме равные 1: 0.6 – классификация по интересам, 0.2-классификация по занятости, 0.2 – возрастная периодизация. Каждый из коэффициентов кратен двум, таким образом получим следующие коэффициенты: 0.3, 0.1, 0.1. Для каждой из территорий подсчитывается количество объектов с данным видом классификации и умножается на коэффициент:

где a – количество объектов с классификацией по интересам, b – количество объектов с классификацией по занятости, c – количество объектов с классификацией по возрасту покупателей. Система рассматривает все возможные варианты трех ближайших остановок по городу и выводит рейтинг первых пяти территорий, у которых значение “y” оказалось максимальным. 

Разработка программного средства

Концепция модели легла в основу разработки программного средства, предоставляющее решение по поставленной задаче. Так программное средство представляет собой прототип СППР, необходимо рассмотреть все этапы процесса поиска решений.

Подготовка исходного набора данных. Этап включает получение данных, определенных с помощью онтологии. Для этого было использовано готовое программное средство «Система учета объектов розничной торговли». Таким образом, была сформирована БД и использована в дальнейшем для анализа с организациями, типами организаций их координатами (см. приложение С). 

Предобработка данных. Для дальнейшего анализа необходимо подготовить данные. Исходя из концепции модели потребовалось модифицировать БД (см. приложение D). В первую очередь были удалены таблицы с данными, не требующиеся для обработки:

routes;

routes_types;

routes_stops.

Кроме того, БД не содержала таблицы для включения информации по категориям покупателей. Поэтому потребовалось создание таблиц category, categ_detail. Кроме того, в таблице Orgданные по организациям и остановкам не были разделены. Для этого также была создана таблица Stops.

Таблица Stops содержит следующие поля:

id_stop – идентификатор таблицы;

name_stop – название остановки;

latlng – координаты расположения остановки.

Таблица categ_detail содержит экземпляры классификаций покупателей:

id_categ_detail – идентификатор таблицы;

name_detail– название экземпляра классификации;

id_categ – внешний ключ для таблицы category.

Таблица category включает виды классификаций:

id_category – идентификатор таблицы;

name_category – название вида классификации.

Кроме того, необходимо было создание сводных таблиц:

categ_and_org – сводная таблица для таблиц categ_detailи types;

org_stop – сводная таблица для таблиц StopsиOrg.

Добавление и удаление таблиц в БД осуществляется с помощью SQL-запросов (см. табл. 2.1.)

Таблица 2.1. Распределение категорий людей по объектам

Создание сводных таблиц и связей между ними показано в Приложении G.

Помимо модификации структуры БД, необходимо было заполнение созданных таблиц и предобработку данных в уже существующих таблицах.

Удаление из базы данных категорий организаций, не участвующих в анализе. Так как категоризация объектов идентична категоризации объектов в карте Google Maps, такие объекты как церковь, храм удаляются из базы данных.

Перенос данных об остановках в отдельную таблицу. Категории объектов также включают в себя категорию «Остановка». В данном случае данный объект необходим для определения границ территорий в городе Пермь. Таким образом, данные по остановкам (название, координаты расположения) выносятся в таблицу Stops и из таблицы Org удаляются. 

Заполнение таблиц category и categ_and_detail данными о категориях клиентов и видах категорий клиентов.

Заполнение сводных таблиц. 

В первую очередь необходимо было заполнить сводную таблицу categ_and_org, соединяющую таблицы категории клиентов и типы организаций. Данные заполнялись на основе построенной ранее таблицы, представленной в Приложении E. 

Далее необходимо было заполнить сводную таблицу org_and_stops. Для каждой организации определялись три ближайшие остановки с использованием формулы гаверсинусов.

Модификация и предобработка данных выполняется автоматически с помощью ряда запросов, представленных в таблице 2.2. 

Таблица 2.2. Описание запросов для предобработки

Обработка данных. Данный этап включает в себя реализацию разработанных алгоритмов. Рассмотрим каждый из алгоритмов в отдельности.

Алгоритм без указания адреса.  Для реализации метода данного алгоритма используются следующие параметры:

idInterest – идентификатор выбранной категории покупателей по интересам;

idOccup – идентификатор выбранной категории покупателей по занятости;

idAge – идентификатор выбранной категории покупателей из возрастной периодизации.

Система, выбирает из БД пять остановок, содержащих наибольшую суммарную долю по выбранным категориям. Далее для каждой из остановок выбирается две ближайших для формирования территорий и также подсчитывается суммарная доля для каждой территории. Исходный код данного метода представлен в Приложении G.

Алгоритм с указанием адреса. Для реализации метода помимо параметров, перечисленных в предыдущем алгоритме, необходим адрес предполагаемого расположения нового розничного торгового объекта. Система получает адрес размещения и передает в сформированный файл JavaScript, необходимый для взаимодействия с картой Google Mapsдля получения координат по введенному адресу.

По полученным координатам определяются три ближайшие остановки к объекту и рассчитывается суммарная доля целевой аудитории для рассматриваемого торгового объекта. Далее определяется наилучшая территория для размещения в городе и сравнивается в выбранной территорией. 

Для того, чтобы начать работать с программой пользователю необходимо подключить заполненную БД к программе. Далее для предобработки данных нужно перейти на вкладку «Предобработка данных» и нажать кнопку «Обработать данные» (см. рис. 2.10.). 



Рисунок 2.10. Форма для предобработки данныз

На каждом этапе выводится результат выполнения обработки:

выполнено;

ошибка.

В процессе обработки данных выполняются SQL-запросы, описанные ранее. 

Далее можно приступать к оценке территорий. Данные операции выполняются на вкладке «Анализ данных» (см. рис.2.11.). 



Рисунок 2.11. Форма для получения решения

В приложении была добавлена карта Google Maps, для взаимодействия с которой необходимо приобретение ключа. 

Рассмотрим также работу алгоритмов:

Алгоритм с указанием адреса. Реализация данного алгоритма потребовала взаимодействия с картой Google Maps для получения координат адреса. Для получения решения пользователь должен выбрать категории покупателей и ввести адрес в текстовое поле (см. рис.2.12.).



Рисунок 2.12. Получение решения по адресу

При нажатии на кнопку «Оценить» пользователь получит ответ, будет ли данная территория прибыльной или убыточной, а также на карте будет установлен маркер по данному адресу. Также пользователь может получить вычисленную долю той или иной категории людей на рассматриваемой области и сравнить с долями, полученными на области, которая в наибольшей степени подходит для размещения нового торгового объекта (см. рис. 2.13).



Рисунок 2.13. Получение долей по категориям потребителей

Алгоритм без указания адреса. Данный алгоритм анализирует данные, содержащиеся в базе данных. Пользователь должен выбрать категории потребителей для новой торговой точки и система, перебрав массив остановок, получит первые пять наиболее подходящих областей для размещения (см. рис. 2.14.).



Рисунок 2.14. Получение решения без указания адреса

Для того чтобы очистить поля формы пользователю нужно нажать на кнопку «Очистить».

В данной главе описаны два этапа разработки. В первом случае проектируется модель и алгоритмы для решения задачи. Далее разрабатывается программное средство, в основе которого лежит концепция модели. Необходимо уточнить, что данные, полученные для обработки, являются неполными, поэтому высока вероятность неточности решения.







Экономическое обоснование

В будущем разработанную концепцию модели планируется внедрить для создания web-сервиса. Таким образом, рассчитаем основные экономические показатели, необходимые для создания данного сайта.

Web-сервис будет анализировать данные с карт города, и предлагать возможные прибыльные места для выбранного вида торговой деятельности в малом и среднем бизнесе. Помимо предложенного решения, у предпринимателей будет возможность отслеживать дальнейшую динамику востребованности открывшегося торгового объекта. В разработке проекта планируется определить группу участников, представленную в таблице 3.1.

Таблица 3.1. Заработные платы участников проекта

При расчете заработной платы в день во внимание принималось, что в месяце 22 рабочих дня. Рассмотрим обязанности каждого из участников проекта.

Руководитель проекта:

определение цели и задач проекта;

создание плана работ;

проведение оценки стоимости ресурсов;

проведение оценки рисков;

координация внутри проекта;

контроль сроков выполнения работ.

Программист:

разработка, участие в тестировании, отладка сервиса;

осуществление сопровождения web-приложения;

создание и наполнение схем БД.

Аналитик:

анализ предметной области;

анализ функциональных возможностей web-приложения;

разработка документации программного средства;

участие в интервьюировании web-приложения.

Тестировщик:

создание сценариев тестирования для сервиса;

осуществление тестирования сервиса;

заполнение тестовыми данными таблиц БД;

анализ и классификация полученных ошибок.

Интернет-маркетолог:

разработка стратегий развития проекта;

анализ продвижения web-сервиса;

расширение клиентской БД.

Для того, чтобы посчитать затраты труда на разработку web-приложения, нужно определить этапы разработки и оценить трудоемкость (см. табл. 3.2.).

Таблица 3.2. Этапы разработки web-сервиса

В целом на реализацию проекта будет потрачено 33 дня. Если взять в учет, что сроки будут сорваны, необходимо вычислить максимальное количество дней, потраченных на реализацию проекта.  У каждого участника проекта умножим количество дней выполнения работ на 20%(см. табл. 3.3.).



Таблица 3.3. Этапы разработки web-сервиса с учетом невыполнения сроков

В целом на проект будет потрачено 233 дня. Для того, чтобы рассчитать сколько денег будет потрачено на заработную плату, необходимо вычислить по следующей формуле:

где Z1-суммарные затраты на заработную плату без учета заработной платы руководителя проекта, ai-участник проекта, bj-этап работ. Таким образом, получим:

Кроме того, в течение всего проекта работает руководитель проекта. Таким образом, суммарные затраты составят:

где Z – суммарные затраты на заработную плату в течение реализации проекта. Необходимо учесть также затраты на технологическое обеспечение (см. табл. 3.4.):



Таблица 3.4. Технологическое оснащение офиса

Аренда офиса составляет 30 000 руб. С доходов от использования разработанного решения компания выделяет 10 000 руб. В итоге стоимость технического оснащения равна:

Так как у компании уже создала ряд продуктов, нет необходимости приобретать лицензии на ПО.

Из расчета данных показателей получается, что себестоимость разработки web-сервиса составит:

Для того чтобы реализация нового сервиса окупилась, компания введет подписку для получения услуг сервиса в размере 1500 руб. с пользователя, а также поквартальную оплату за использование услуг в размере 500 руб. Кроме того, будет использоваться 3 блока рекламы от Google, Yandex и Rambler. В таблице 3.5. приведены цены за клик:

Таблица 3.5. Список цен за один клик уникального пользователя

Предполагается, что в за сутки будет около 1000 уникальных пользователей, из них около 100 будут заходить по ссылкам. Таким образом, в месяц компания получит дохода с рекламы:

В первый месяц планируется привлечение пяти постоянных пользователей. В дальнейшем, каждый месяц работы сервиса компания будет увеличивать количество постоянных пользователей на 30 человек. Таким образом, расчеты приведены в таблице 3.6.:

Таблица 3.6. Доход полученный компанией за полгода

За полгода компания сможет выручить 503 000 руб. дохода. Полученный доход не учитывает затраты на аренду офиса, на поддержку сервиса. На поддержку сервиса выделяется 8000 руб./мес. Также условно за полгода компания на прочие расходы с дохода по данному продукту выделяет 100 000 руб.

В следующие полгода компания заработает 703 000 руб. 

Через полтора года компания получит доход в размере 883 000 руб.,

За два года компания заработает суммарный доход 3 752 000 руб., а через полтора года затраты на реализацию и внедрение проекта окупятся.  

Окупаемость web-сервиса достаточно сложно рассчитать, так как показатель зависит от множества внешних факторов, в том числе количества уникальных пользователей. Данные расчеты используют достаточно грубую оценку, так как не учтены расходы на амортизацию, расходы, связанные с невыполнением планов по привлечению новых клиентов. Также для раскрутки данного проекта, могут создаваться различные программы, которые требуют дополнительного вложения средств.

Заключение

В данной работе обозначена важность поддержки малого и среднего бизнеса, а также основные причины разорений данных предприятий. Одна из причин, выбор неправильного местоположения для нового предприятия, была взята за основу для разработки модели анализа данных, позволяющая найти наиболее привлекательную для размещения территорию.

Для визуализации предметной области и определения основных классов, необходимых для построения модели, была спроектирована онтология. Модель представлена в форме ориентированного графа, а также с помощью диаграммы классов UML. При проектировании модели были описаны основные понятия, участвующие при обработке данных. Модель включает в себя два алгоритма, реализующие анализ данных. В первом случае определятся набор местоположений, наиболее подходящих для размещения с помощью учета целевой аудитории новой торговой точки. Во втором случае оценивается конкретная область, заданная адресом, для размещения розничного торгового объекта.

Концепция модели легла в основу разработки программного средства, являющегося прототипом СППР. На этапе предобработки программное средство реализует модификацию исходной БД в требуемую для дальнейшего анализа. На этапе анализа данных производится поиск решения с помощью созданных алгоритмов.

 В будущем планируется разработать web-приложение на основе данной модели, а также усовершенствовать ее путем ввода расчетов экономических показателей.

Библиографический список

1. Барсегян А.А., Куприянов М. С., Холод И. И., Тесс М. Д., Елизаров С. И.. Анализ данных и процессов. СПб.: БХВ-Петербург, 2009.17 c.

2.Гладун А.Я., Рогушина Ю.В. Онтологии в корпоративных системах // Корпоративные системы.2006, №1, с. 41-47.

3. Мальцев П.А., Воронина Т.В. Онтология Businessintelligence // В кн.: Математика программных систем: межвузовский сборник научных статей. Пермь.: Пермский государственный национальный исследовательский университет. 2012.

4.Фаулер М., Скотт К. UML в кратком изложении М.: Мир. 1999. 71 с.

5.Vipin K., The Top Ten Algorithms in Data Mining. London.: Taylor&FrancisGroup.2009.

6. Абернети М. Интеллектуальный анализ данных с помощью программного пакета WEKA//IBM [Электронный ресурс][Режим доступа: https://www.ibm.com/developerworks/ru/library/os-weka1/][Проверено: 30.04. 2014]

7.Камоев Т.К. Проблемы теории и практики предпринимательства: О роли розничной торговли в экономике России [Электронный ресурс] [Режим доступа:  ] [Проверено:30.04.2014] 

8. Кудрявцев Д. Технологии применения онтологий. [Электронный ресурс][Режим доступа: http://bigspb.ru/theory/km/onto_technologies.php] [Проверено: 30.04.2014] 

9. Угаров А.С. Методы выбора местоположения торговой точки [Электронный ресурс] [Режим доступа: ] [Проверено: 30.04.2014]

10. Дубинин М. Расчет расстояний по их координатам. [Электронный ресурс] [Режим доступа: http://www.kobzarev.com/programming/calculation-of-distances-between-cities-on-their-coordinates.html] [Проверено: 30.04.2014]

11.Data-Mining-добыча данных // Технологии анализа данных. [Электронный ресурс] [Режим доступа: http://www.basegroup.ru/library/methodology/base/] [Проверено: 30.04.2014]

12. Определение ставки дисконтирования. Для чего нужна ставка дисконтирования. //4Consult.ru [Электронный ресурс] [Режим доступа: /] [Проверено: 30.04.2014]

Блок-схема алгоритма с указанием адреса





Рисунок A.1. Блок-схема алгоритма с указанием адреса

Блок-схема алгоритма без указания адреса



Рисунок B.1. Блок-схема алгоритма с указанием адреса



Исходная база данных





Рисунок С.1. Исходная база данных

Модифицированная база данных





Рисунок D.1. Модифицированная база данных



Распределение категорий людей по объектам

Таблица Е.1. Распределение категорий людей по объектам





Таблица Е.1. Распределение категорий людей по объектам(продолжение)





Таблица Е.1. Распределение категорий людей по объектам(продолжение)

Техническое задание на разработку системы















Оглавление

1. Общие сведения51

Полное наименование системы и ее условное обозначение51

Основания для разработки51

Плановые сроки начала и окончания работ51

Основания для разработки51

2. Назначение и цели создания модуля51

2.1. Назначение системы51

2.2. Цель создания системы52

2.3. Характеристика объекта автоматизации52

3. Требования к системе53

     3.1. Требования к структуре и функционированию53

     3.2. Условия эксплуатации54

     3.3. Требования к временным показателям системы54

     3.4. Требования к информационному обеспечению модуля55

     3.5. Требования к лингвистическому обеспечению55

     3.6. Требования к программному обеспечению системы55

     3.7. Требования к техническому обеспечению55

     3.8. Требования к эргономике и технической эстетике56

     3.9. Требования к техническому обеспечению56

4. Порядок контроля и приемки системы56

4.1. Виды испытаний системы56

4.2. Требования к программной документации57

4.3. Стадии и этапы разработки58




Общие сведения

Настоящее техническое задание определяет форму и содержание работ по разработке программного средства для оценки востребованности территорий города Пермь в объектах розничной торговли. 

Полное наименование системы и ее условное обозначение

Наименование программного средства - «Система оценки востребованности территорий города в объектах розничной торговли».

Основания для разработки

Настоящее Техническое задание разработано в рамках выполнения выпускной квалификационной работы студентов факультета бизнес-информатики, направления 080500.62 Бизнес-информатика.

Работа выполняется на основании учебного плана и темы выпускной квалификационной работы, определенной научным руководителем и утвержденной приказом от 25.11.2013 №8.2.6.2-06/698 «Об утверждении тем и руководителей выпускных квалификационных работ студентов факультета бизнес-информатики».

Разработчиком программного средства является студентка 4 курса факультета бизнес-информатики: Анкудинова Ирина. 

Плановые сроки начала и окончания работ

Начало работ по проектированию и разработке системы: сентябрь 2013 года. Окончание работ по созданию системы: 20 мая 2014 года.

Назначение и цели создания модуля.

Назначение системы.

По виду автоматизируемой деятельности относится к системам управления, хранения, обработки информации. Программное средство должно осуществлять анализ собранных данных и принимать решение на основе полученных результатов. Объектом автоматизации является процесс оценки территорий города Пермь, для определения наиболее прибыльного местоположения для открываемой торговой точки.

Основными пользователями разрабатываемой системы будут предприниматели малого и среднего бизнеса.

В основе программного средства лежит концепция спроектированной модели анализа данных:

для каждого объекта города определяются категории людей;

для каждого объекта определяются три ближайшие автобусные остановки;

вокруг каждой автобусной остановки образуется некоторый потенциал объектов с определенной категорией людей.

Цель создания системы

Целью создания системы является сокращение риска разорения нового торгового объекта малого или среднего бизнеса.

Характеристика объекта автоматизации

Объектом автоматизации является процесс оценки территорий города Пермь. У данного процесса нет установленного алгоритма выполнения или стандарта. В общем случае он включает в себя:

определение целевой аудитории для нового торгового объекта. Целевая аудитория зависит от вида предоставляемой услуги или товара. 

деление территорий города Пермь для удобства дальнейшего анализа (не обязательно);

поиск территорий с наибольшим спросом на предлагаемый товар или услугу. Необходимо определить место, где количество потребителей на предлагаемый товар или услугу будет преобладать.

Спроектированная модель анализа данных включает в себя экземпляры.

Объект представляет собой любое предприятие или жилое помещение. Атрибутами являются:

название;

адрес;

долгота;

широта.

Остановка. В модели рассматриваются только автобусные остановки. Остановки с одним названием, но отличными координатами считаются разными остановками. Атрибутами являются:

название;

широта;

долгота.

На данном этапе можно выделить еще два экземпляра.

Классификация по типу объекта. Данный экземпляр представляет собой классификацию объектов в городе Перми, построенную на основе классификации объектов на карте Google Maps. Атрибутом данного экземпляра является:

название.

Категории потребителей. Данный экземпляр представляет собой набор классификаций потребителей по следующим признакам:

пол - классификация по половому признаку;

возрастная периодизация – классификация потребителей по возрасту;

занятость – классификация потребителей по текущей занятости: школьник, студент и т.д.;

интерес – классификация определяет сферы деятельности потребителей: автомобили, наука и т.д.

Требования к системе

Требования к структуре и функционированию.

Программное средство состоит из двух функциональных подсистем.

Подсистема загрузки и обновления данных. Реализуется функция догрузки данных из системы учета объектов розничной торговли, а также обновление уже существующих данных в системе.

Подсистема для анализа данных и реализации поиска решений. Реализуется функция оценки востребованности территорий для новой открываемой торговой точки.

Программное средство представляет собой приложение, состоящее из двух вкладок:

Вкладка для оценки территорий города. Пользователь сможет оценивать территории города двумя способами. В первом случае пользователю нужно определить: будет ли прибыльным предполагаемое местоположение для открываемой торговой точки. Тогда входными параметрами будут: категории потребителей для торговой точки и адрес размещения. На выходе будет получен один из трех ответов:

прибыльное местоположение;

убыточное местоположение;

Во втором случае пользователь вводит лишь предполагаемые категории потребителей. Модуль системы проводит анализ по всему городу и выводит рейтинг от 1 до 5 наиболее прибыльных местоположений.

Вкладка для загрузки и обновления данных. Пользователь сможет загружать и обновлять данные из системы учета объектов розничной торговли с помощью кнопки «Обновить данные».

Смежной системой является система учета объектов розничной торговли и их окружения, осуществляющая загрузку данных с карты Google Maps.

Условия эксплуатации

Для обеспечения эксплуатации и обновления системы необходимо выделение следующих ответственных лиц:

администратор подсистемы загрузки и обновления данных. Данный сотрудник должен владеть следующими навыками и знаниями:

знание языка SQL, умение составлять сложные SQL-запросы;

знание языков Java, C#;

умение выполнять интеграцию данных;

знание методологий проектирования хранилищ данных.

администратор подсистемы анализа данных. Данный сотрудник должен владеть следующими навыками и знаниями:

знание языка SQL, умение составлять сложные SQL-запросы;

знание и умение применять средства и методологии анализа данных;

знание языка Java.

Требования к временным показателям системы

Уровень надежности должен достигаться согласованным применением организационных, организационно-технических и программно-аппаратных средств. Сбой программного средства может произойти по одной из следующих причин:

сбой операционной системы;

сбой технического обеспечения.

Надежное функционирование программы будет обеспечено благодаря бесперебойному питанию технических средств, а также использование лицензионного программного обеспечения.

Надежность программного обеспечения подсистем должна обеспечиваться за счет:

надежности общесистемного ПО и ПО, разрабатываемого разработчиком;

проведением комплекса мероприятий отладки, поиска и исключения ошибок.

ведением журналов системных сообщений и ошибок по подсистемам для последующего анализа и изменения конфигурации.

Требования к информационному обеспечению модуля

Хранение и организация данных программного средства должна быть осуществлена средствами MySQL. Для визуального проектирования базы данных, моделирования и создания базы данных должен использоваться инструмент MySQL Workbench.

Требования к лингвистическому обеспечению

Пользовательский интерфейс модуля должен быть реализован на русском языке. При составлении технической документации возможно использование англоязычных терминов и понятий.

Требования к программному обеспечению системы

Для разработки системы должна использоваться среда Eclipse SDK. В качестве фрейма для создания графического интерфейса должна использоваться библиотека Swing.

Требования к техническому обеспечению

Для ведения разработок и поддержки программного средства необходимо обеспечить доступ к серверу приложения, а также к серверу системы учета объектов розничной торговли.

Для обеспечения работы программного средства требуется:

процессор – 2 х 3 ГГц;

объем оперативной памяти – не менее 2 Гб;

объем жесткого диска – не менее 120 Гб; 

сетевая карта – с поддержкой скорости не менее 1 Гбит/сек.

Требования к эгрономике и технической эстетике.

Программное средство должно обеспечивать удобный для конечного пользователя интерфейс, отвечающий следующим требованиям.

В части внешнего оформления:

интерфейсы должны быть типизированы;

обеспечение наличия локализованного (русскоязычного интерфейса) пользователя;

должен использоваться шрифт: Times New Roman;

размер шрифта должен быть равен 14 кегль, для заголовков – 16 кегль.

В части диалога с пользователем:

при возникновении ошибок в работе системы на экран монитора должно выводиться сообщение с наименованием ошибки;

Требования к антивирусной защите

Средства антивирусной защиты должны быть установлены на рабочем столе пользователя и обеспечивать:

централизованное управление сканированием, удалением вирусов и протоколированием вирусной активности на рабочих местах пользователей;

централизованную автоматическую инсталляцию клиентского ПО на рабочих местах пользователей и администраторов;

централизованное автоматическое обновление вирусных сигнатур на рабочих местах пользователей и администраторов;

ведение журналов вирусной активности;

администрирование всех антивирусных продуктов.

Порядок контроля и приемки системы

Виды испытаний системы:

Для ввода в эксплуатацию программное средство должно пройти испытания.

Предварительные испытания. На данном этапе фиксируются и устраняются неполадки. Далее необходимо проверить устранение выявленных неполадок и осуществить принятие решения о возможности передачи программного средства в опытную эксплуатацию. Для этого составляется акт приемки программного средства в опытную эксплуатацию.

Опытная эксплуатация. На данном этапе также фиксируются и устраняются неполадки. В результате составляется акт о завершении опытной эксплуатации.

Приемочные испытания. Фиксируются и устраняются неполадки. Составляется и подписывается акт о завершении приемочных испытаний. Также необходимо составить акт завершения работ.

Требования к программной документации

При создании программного средства должна быть разработана следующая документация:

описание концепции модели анализа данных;

схема базы данных и описание отдельных таблиц;

тестовые сценарии в электронной форме;

описание работы системы;

руководство пользователя;

руководство разработчика.

Стадии и этапы разработки.

Предпроектное исследование. На данном этапе описана проблема, изучена литература.

Проектирование модели. Данный этап включает в себя анализ и визуализацию предметной области, разработку концепции модели анализа данных, а также алгоритмов получения решения.

Проектирование приложения. На данном этапе должны быть определены функции системы, разработка структуры и макета приложения.

Разработка системы. На данном этапе проектируется база данных и реализуется бизнес-логика.

Тестирование. На данном этапе разрабатываются тесты для проверки корректности работы системы.

Документирование. Данный этап включает в себя разработку документации программного средства.

Расчет доходов компании от работы web-приложения

Таблица G.1. Доходы компании в первый год 

Таблица G.2. Доходы компании во второй год 



Исходные коды

Листинг H.1. JavaScript для получения координат адреса

<!DOCTYPE html>

<html>

<head>

    <meta name="viewport" content="initial-scale=1.0, user-scalable=no" />

    <style type="text/css">

        html { height: 100% }

        body { height: 100%; margin: 0; padding: 0 }

        #map-canvas { height: 100% }

    </style>

    <script type="text/javascript"  src="https://maps.googleapis.com/maps/api/js?sensor=true&key=AIzaSyBWeWxnHaMKuWxHzs2cSo8QD0Mw7o6RiXw">

    </script>

    <script type="text/javascript">

        var geocoder;

        var map;

        var lat=null;

        var lng=null;

	var marker=null;

        function initialize() {

            geocoder = new google.maps.Geocoder();

            var latlng = new google.maps.LatLng(58.01741, 56.28552);

            var mapOptions = {

                zoom: 8,

                center: latlng

            }

            map = new google.maps.Map(document.getElementById("map_canvas"), mapOptions);

        }

function getCntr(lat, lng)

{

latlng = new google.maps.LatLng(lat, lng);

mapOptions={

zoom:10,

center:latlng

	}

marker=new google.maps.Marker({

position:latlng,

map:map,



})



map.setCenter(latlng);



marker.setPosition(latlng);

}



function initCntr()

{



latlng = new google.maps.LatLng(58.01741, 56.28552);

mapOptions={

zoom:10,

center:latlng

	}

marker=setMap(null);





map.setCenter(latlng);







}

        function codeAddress(address) {

        	data=null;

            geocoder.geocode( { 'address': address}, function(results, status) {

                if (status == google.maps.GeocoderStatus.OK) {

                    map.setCenter(results[0].geometry.location);

                    lat=results[0].geometry.location.A;

                    lng=results[0].geometry.location.k;

                } else {

                	data = false;

                    alert("Geocode was not successful for the following reason: " + status);

                }

            });

        }

    </script>

</head>

<body onload="initialize()">

<div id="map_canvas" style="width:100%; height:100%"></div>

</body>

</html>









Листинг H.2. Модификация БД

packagedb;



importjava.sql.Connection;

importjava.sql.PreparedStatement;

importjava.sql.ResultSet;

importjava.sql.SQLException;

importjava.sql.Statement;

importjava.util.ArrayList;

importjava.util.List;



importclassesInvoved.Organization;

importclassesInvoved.Stops;



public class PreparingData {



	private void insertCategory() throws SQLException {

		ConnectToMSSQLcnt = new ConnectToMSSQL();

		cnt.createCon();

		Connection c = cnt.con;

		// Statement st = c.createStatement();

		List<String>lst = new ArrayList<String>();

		lst.add("Возрастная периодизация");

		lst.add("Категория по интересам");

		lst.add("Категория по полу");

		lst.add("Категория по занятости");

		PreparedStatement st2;

		for (inti = 0; i<lst.size(); i++) {

			st2 = c

					.prepareStatement("INSERT INTO category (id_category, name_category)"

							+ " VALUES (?, ?)");

			st2.setInt(1, i + 1);

			st2.setString(2, lst.get(i));

			st2.executeUpdate();

		}

		cnt.disconnect();



	}



	private void insertCategoryDetail() throws SQLException {

		ConnectToMSSQLcnt = new ConnectToMSSQL();

		cnt.createCon();

		Connection c = cnt.con;

		int k = 1;

		List<String>lst = new ArrayList<String>();// поинтересам

		lst.add("Искусство");

		lst.add("Спорт");

		lst.add("Наука");

		lst.add("Красота");

		lst.add("Юриспруденция");

		lst.add("Техника/проектирование");

		lst.add("Строительство/квартира");

		lst.add("Автомобили");

		lst.add("Медицина");

		lst.add("Экономика/финансы");

		lst.add("Развлечение");

		lst.add("Животные");

		PreparedStatementst;

		for (inti = 0; i<lst.size(); i++) {

			st = c

					.prepareStatement("INSERT INTO categ_detail (id_categ_detail, name_detail, id_categ)"

							+ " VALUES (?, ?, ?)");

			st.setInt(1, k);

			st.setString(2, lst.get(i));

			st.setInt(3, 2);

			st.executeUpdate();

			k++;

		}

		k = 13;

		List<String> lst2 = new ArrayList<String>();// позанятости

		lst2.add("Дошкольник");

		lst2.add("Школьник");

		lst2.add("Студент");

		lst2.add("Работник");

		lst2.add("Пенсионер");

		for (inti = 0; i< lst2.size(); i++) {

			st = c

					.prepareStatement("INSERT INTO categ_detail (id_categ_detail,name_detail, id_categ)"

							+ " VALUES (?, ?, ?)");

			st.setInt(1, k);

			st.setString(2, lst2.get(i));

			st.setInt(3, 4);

			st.executeUpdate();

			k++;

		}

		k = 19;

		List<String> lst3 = new ArrayList<String>();// возрастная

		lst3.add("Раннее детство(0-6)");

		lst3.add("Школьный возраст (7-12)");

		lst3.add("Юность (13-20)");

		lst3.add("Молодость (21-25)");

		lst3.add("Взрослость (26-60)");

		lst3.add("Старость (26-60)");

		for (inti = 0; i< lst3.size(); i++) {

			st = c

					.prepareStatement("INSERT INTO categ_detail (id_categ_detail, name_detail, id_categ)"

							+ " VALUES (?, ?, ?)");

			st.setInt(1, k);

			st.setString(2, lst3.get(i));

			st.setInt(3, 1);

			st.executeUpdate();

			k++;

		}

		cnt.disconnect();

	}



	private static void addedMethod(Connection c, inttyp, intct)

			throwsSQLException {

		PreparedStatementst = c

				.prepareStatement("INSERT INTO categ_and_org (id_categ, id_type)"

						+ " VALUES (?, ?)");

		st.setInt(1, ct);

		st.setInt(2, typ);

		st.executeUpdate();

	}



	private void matchOrgCateg() throws SQLException {

		ConnectToMSSQLcnt = new ConnectToMSSQL();

		cnt.createCon();

		Connection c = cnt.con;

		// /1

		addedMethod(c, 40, 7);

		addedMethod(c, 40, 22);

		addedMethod(c, 40, 23);

		addedMethod(c, 40, 16);

		// 2



		addedMethod(c, 44, 4);

		addedMethod(c, 44, 22);

		addedMethod(c, 44, 23);

		addedMethod(c, 44, 15);

		addedMethod(c, 44, 16);



		// 3

		addedMethod(c, 45, 4);

		addedMethod(c, 45, 22);

		addedMethod(c, 45, 23);

		addedMethod(c, 45, 15);

		addedMethod(c, 45, 16);



		// 4

		addedMethod(c, 46, 7);

		addedMethod(c, 46, 22);

		addedMethod(c, 46, 23);

		addedMethod(c, 46, 16);



		// 5

		addedMethod(c, 48, 7);

		addedMethod(c, 48, 21);

		addedMethod(c, 48, 22);

		addedMethod(c, 48, 14);

		addedMethod(c, 48, 15);

		// 6

		addedMethod(c, 50, 9);

		addedMethod(c, 50, 23);

		addedMethod(c, 50, 24);

		addedMethod(c, 50, 16);

		addedMethod(c, 50, 17);



		// 7

		addedMethod(c, 52, 11);

		addedMethod(c, 52, 22);

		addedMethod(c, 52, 23);

		addedMethod(c, 52, 16);



		// 8

		addedMethod(c, 53, 1);

		addedMethod(c, 53, 3);

		addedMethod(c, 53, 21);

		addedMethod(c, 53, 22);

		addedMethod(c, 53, 15);

		addedMethod(c, 53, 16);



		// 9

		addedMethod(c, 56, 20);

		addedMethod(c, 56, 22);

		addedMethod(c, 56, 14);

		addedMethod(c, 56, 16);



		// 10

		addedMethod(c, 57, 12);

		addedMethod(c, 57, 20);

		addedMethod(c, 57, 23);

		addedMethod(c, 57, 14);

		addedMethod(c, 57, 16);



		// 11

		addedMethod(c, 58, 4);

		addedMethod(c, 58, 22);

		addedMethod(c, 58, 23);

		addedMethod(c, 58, 15);

		addedMethod(c, 58, 16);



		// 12

		addedMethod(c, 63, 8);

		addedMethod(c, 63, 22);

		addedMethod(c, 63, 23);

		addedMethod(c, 63, 15);

		addedMethod(c, 63, 16);



		// 13

		addedMethod(c, 69, 7);

		addedMethod(c, 69, 22);

		addedMethod(c, 69, 23);

		addedMethod(c, 69, 8);

		addedMethod(c, 69, 16);



		// 14

		addedMethod(c, 70, 10);

		addedMethod(c, 70, 23);

		addedMethod(c, 70, 24);

		addedMethod(c, 70, 16);

		addedMethod(c, 70, 17);



		// 15

		addedMethod(c, 73, 11);

		addedMethod(c, 73, 21);

		addedMethod(c, 73, 22);

		addedMethod(c, 73, 15);

		addedMethod(c, 73, 16);



		// 16

		addedMethod(c, 74, 9);// стоматология

		addedMethod(c, 74, 13);

		addedMethod(c, 74, 14);

		addedMethod(c, 74, 15);

		addedMethod(c, 74, 16);

		addedMethod(c, 74, 17);

		// addedMethod(c, 74, 18);

		addedMethod(c, 74, 19);

		addedMethod(c, 74, 20);

		addedMethod(c, 74, 21);

		addedMethod(c, 74, 22);

		addedMethod(c, 74, 23);

		addedMethod(c, 74, 24);

		// 17

		addedMethod(c, 76, 2);

		addedMethod(c, 76, 22);

		addedMethod(c, 76, 23);

		addedMethod(c, 76, 15);

		addedMethod(c, 76, 16);



		// 18

		addedMethod(c, 77, 4);

		addedMethod(c, 77, 22);

		addedMethod(c, 77, 23);

		addedMethod(c, 77, 15);

		addedMethod(c, 77, 16);



		// 19

		addedMethod(c, 78, 11);

		addedMethod(c, 78, 21);

		addedMethod(c, 78, 22);

		addedMethod(c, 78, 15);

		addedMethod(c, 78, 16);



		// 20

		addedMethod(c, 79, 1);

		addedMethod(c, 79, 2);

		addedMethod(c, 79, 3);

		addedMethod(c, 79, 20);

		addedMethod(c, 79, 21);

		addedMethod(c, 79, 13);

		addedMethod(c, 79, 14);



		// 21

		addedMethod(c, 81, 3);

		addedMethod(c, 81, 20);

		addedMethod(c, 81, 21);

		addedMethod(c, 81, 14);

		addedMethod(c, 81, 15);



		// 22

		addedMethod(c, 82, 23);

		addedMethod(c, 82, 24);

		addedMethod(c, 82, 16);

		addedMethod(c, 82, 17);



		// 23

		addedMethod(c, 86, 8);

		addedMethod(c, 86, 22);

		addedMethod(c, 86, 23);

		addedMethod(c, 86, 15);

		addedMethod(c, 86, 16);



	

		cnt.disconnect();



	}



	public String fillCategory() {

		try {

			insertCategory();

			insertCategoryDetail();

			matchOrgCateg();

			return "Выполнено";

		} catch (Exception e) {

			return "Ошибка";

		}

	}



	public double gettingStopsForOrg(String org, String stp) {

		String[] orgStr = splitTrimLtln(org);

		String[] stpStr = splitTrimLtln(stp);

		if ((orgStr.length == 2) && (stpStr.length == 2))

			returnhaverSinus(orgStr, stpStr);

		return -1;

	}



	private String[] splitTrimLtln(String ltln) {

		String[] ltlnStr = ltln.trim().split("\\s+");// 0-latitude..1.longtit

		if (ltlnStr.length == 2) {

			if (ltlnStr[0].contains(","))

				ltlnStr[0] = ltlnStr[0].replace(",", "");

			if (ltlnStr[0].contains("("))

				ltlnStr[0] = ltlnStr[0].replace("(", "");

			if (ltlnStr[1].contains(","))

				ltlnStr[1] = ltlnStr[1].replace(",", "");

			if (ltlnStr[1].contains(")"))

				ltlnStr[1] = ltlnStr[1].replace(")", "");



		}

		returnltlnStr;

	}



	private static double haverSinus(String[] orgStr, String[] stpStr) {

		int R = 6371;

		doubledLat = Math.toRadians(Double.parseDouble(stpStr[0])

				- Double.parseDouble(orgStr[0]));

		doubledLong = Math.toRadians(Double.parseDouble(stpStr[1])

				- Double.parseDouble(orgStr[1]));

		double lat1 = Math.toRadians(Double.parseDouble(orgStr[0]));

		double lat2 = Math.toRadians(Double.parseDouble(stpStr[0]));



		double a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1)

				* Math.cos(lat2) * Math.sin(dLong / 2) * Math.sin(dLong / 2);

		double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

		return c * R;

	}



	public static int checking(double[] mas, double i) {

		for (int k = 0; k <mas.length; k++) {

			if ((mas[0] >i) || (mas[0] == 0.0)) {

				mas[0] = i;

				return 0;

			} else if ((mas[1] >i) || (mas[1] == 0.0)) {

				mas[1] = i;

				return 1;

			} else if ((mas[2] >i) || (mas[2] == 0.0)) {

				mas[2] = i;

				return 2;

			}

		}

		return -1;

	}



	public String соединитьОстОрг() {

		ConnectToMSSQLcnt = new ConnectToMSSQL();

		try {

			cnt.createCon();



			Connection c = cnt.con;

			Statement st = c.createStatement();

			Statement st2 = c.createStatement();

			ResultSetrs = st.executeQuery("select* from Org");

			while (rs.next()) {

				double[] mas = new double[3];

				Organization org = new Organization();

				org.setId(rs.getString(1));

				org.setName(rs.getString(2));

				org.setLatlng(rs.getString(3));

				String[] vs = new String[3];

				double k = -1;

				ResultSet rs2 = st2.executeQuery("select * from stops");

				while (rs2.next()) {

					Stops stp = new Stops();

					stp.setId(rs2.getString(1));

					stp.setName(rs2.getString(2));

					stp.setLatLng(rs2.getString(3));

					k = gettingStopsForOrg(org.getLatlng(), stp.getLatLng());

					if (k == -1)

						break;

					int l = checking(mas, k);

					if (l == 0)

						vs[0] = stp.getId();

					else {

						if (l == 1)

							vs[1] = stp.getId();

						else if (l == 2)

							vs[2] = stp.getId();

					}

				}

				if (k != -1) {

					PreparedStatementstInsert = c

							.prepareStatement("INSERT INTO org_stop (id_org,id_stop)"

									+ " VALUES (?, ?)");

					for (inti = 0; i<vs.length; i++) {

						stInsert.setString(1, org.getId());

						stInsert.setString(2, vs[i]);



						stInsert.executeUpdate();

					}

				}

			}

			cnt.disconnect();

			return "Выполнено";

		} catch (SQLException e1) {

			return "Ошибка";

		}

	}



	public String fillStops() {

		ConnectToMSSQLcnt = new ConnectToMSSQL();

		try {

			cnt.createCon();



			Connection c = cnt.con;

			 Statement st = c.createStatement();

			 //String sql =

			// "ALTER TABLE Org ADD COLUMN (id_categ) REFERENCES category (id_category)";

			 //st.executeUpdate(sql);

			 List<Stops>stp = new ArrayList<Stops>();

			ResultSetrs = st

			 .executeQuery("select * from Org, org_types, types where Org.id_organisation=org_types.id_organisation AND types.id_type=org_types.id_type AND types.id_type="

			 + 64);

			try {

			while (rs.next()) {

			 Stops s = new Stops();

			s.setId(rs.getString(1));

			s.setName(rs.getString(2));

			s.setLatLng(rs.getString(3));

			stp.add(s);

			 }

			 } catch (Exception e) {

			e.printStackTrace();

			 }

			PreparedStatement st2 = c

			 .prepareStatement("INSERT INTO Stops (id_stop,name_stop, latlng)"

			 + " VALUES (?, ?,?)");

			for (inti = 0; i<stp.size(); i++) {

			st2.setString(1, stp.get(i).getId());

			st2.setString(2, stp.get(i).getName());

			st2.setString(3, stp.get(i).getLatLng());

			st2.executeUpdate();

			 }

			cnt.disconnect();



			return "Выполнено";

		} catch (SQLException e1) {

			return "Ошибка";

		}

	}



	public String createNewTable() {

		ConnectToMSSQLcnt = new ConnectToMSSQL();

		try {

			cnt.createCon();



			Connection c = cnt.con;

			Statement st = c.createStatement();

			String sql = "CREATE TABLE Stops (id_stopNCHAR(100) PRIMARY KEY,name_stop NCHAR(100), latlng NCHAR(100) )";

			st.executeUpdate(sql);

			sql = "CREATE TABLE org_stop (id_org NCHAR(100), id_stop  NCHAR(100))";

			st.executeUpdate(sql);

			sql = "ALTER TABLE org_stop ADD FOREIGN KEY (id_org) REFERENCES Org (id_organisation)";

			st.executeUpdate(sql);

			sql = "ALTER TABLE org_stop ADD FOREIGN KEY (id_stop) REFERENCES stops (id_stop)";

			st.executeUpdate(sql);



			sql = "CREATE TABLE category (id_category INT PRIMARY KEY, name_category  NCHAR(40))";

			st.executeUpdate(sql);



			sql = "CREATE TABLE categ_detail (id_categ_detail INT PRIMARY KEY, name_detail  NCHAR(50), id_categ INT)";

			st.executeUpdate(sql);



			sql = "ALTER TABLE categ_detail ADD FOREIGN KEY (id_categ) REFERENCES category (id_category)";

			st.executeUpdate(sql);



			sql = "CREATE TABLE categ_and_org (id_categ INT , id_type  INT)";

			st.executeUpdate(sql);



			sql = "ALTER TABLE categ_and_org ADD FOREIGN KEY (id_type) REFERENCES types (id_type)";

			st.executeUpdate(sql);

			sql = "ALTER TABLE categ_and_org ADD FOREIGN KEY (id_categ) REFERENCES categ_detail (id_categ_detail)";

			st.executeUpdate(sql);

			cnt.disconnect();

			return "Выполнено";

		} catch (SQLException e) {

			return "Ошибка";

		}

	}



	public String deleteTables() {

		ConnectToMSSQLcnt = new ConnectToMSSQL();

		try {

			cnt.createCon();



			Connection c = cnt.con;

			Statement st = c.createStatement();

			String sql = "DROP TABLE routes_stops";

			st.executeUpdate(sql);



			sql = "DROP TABLE Routes";

			st.executeUpdate(sql);



			sql = "DROP TABLE routes_types";

			st.executeUpdate(sql);

			cnt.disconnect();

			return "Выполнено";

		} catch (SQLException e) {

			return "Ошибка";

		}

	}

}



Листинг H.3. Реализация алгоритма с указанием адреса

public static String estimateByAdres(ModelRating model,

			String[] adress) throws SQLException {

		int idInterest = model.inter.getId();

		int idAge = model.age.getId();

		int idOccup = model.occup.getId();

		String answer = "";

		ConnectToMSSQL cnt = new ConnectToMSSQL();

		cnt.createCon();

		Connection c = cnt.con;

		Statement st = c.createStatement();

		double k = -1;

		double[] mas = new double[3];

		List<Stops> vs = new ArrayList<Stops>();

		for (int i=0; i<3; i++)

			vs.add(new Stops());

		ResultSet rs = st.executeQuery("select * from stops");

		while (rs.next()) {

			Stops stp = new Stops();

			stp.setId(rs.getString(1));

			stp.setName(rs.getString(2));

			stp.setLatLng(rs.getString(3));

			k = insertData.gettingStopsForOrg(adress, stp.getLatLng());

			if (k != -1) {

				if (k == -1)

					break;

				int l = insertData.checking(mas, k);

				if (l == 0) {

					vs.get(0).setId(stp.getId());

					vs.get(0).setName(stp.getName());

					vs.get(0).setLatLng(stp.getLatLng());

				} else {

					if (l == 1) {

						vs.get(1).setId(stp.getId());

						vs.get(1).setName(stp.getName());

						vs.get(1).setLatLng(stp.getLatLng());

					} else if (l == 2) {

						vs.get(2).setId(stp.getId());

						vs.get(2).setName(stp.getName());

						vs.get(2).setLatLng(stp.getLatLng());

					}

				}

			}

		}

		calculatingPortion(idInterest, idAge, idOccup, st, vs);

		int kolvo = 1;

		List<Stops> stp = mainEstimationMethod(idInterest, idAge, idOccup, st,

				kolvo);

		// Получение для остановки ближайших

		ResultSet rs2 = st.executeQuery("select * from stops");

		double[] mas2 = new double[3];

		List<Stops> vs2 = new ArrayList<Stops>();

		for (int i=0; i<2; i++)

			vs2.add(new Stops());

		while (rs2.next()) {

			Stops stp2 = new Stops();

			stp2.setId(rs2.getString(1));

			stp2.setName(rs2.getString(2));

			stp2.setLatLng(rs2.getString(3));



			k = insertData.gettingStopsForOrg(stp.get(0).getLatLng(), stp2

					.getLatLng());

			if (k != -1) {

				if (k == -1)

					break;

				int l = insertData.checking2(mas2, k);

				if (l == 0) {

					vs2.get(0).setId(stp2.getId());

					vs2.get(0).setName(stp2.getName());

					vs2.get(0).setLatLng(stp2.getLatLng());

				} else {

					if (l == 1) {

						vs2.get(1).setId(stp2.getId());

						vs2.get(1).setName(stp2.getName());

						vs2.get(1).setLatLng(stp2.getLatLng());

					}

				}

			}

		}

		calculatingPortion(idInterest, idAge, idOccup, st, vs2);

		Double resVs = vs.get(0).getRes() +vs.get(1).getRes() + vs.get(2).getRes();

		Double resVs2 = vs2.get(0).getRes() + vs2.get(1).getRes() + stp.get(0).getRes();// самая

		// большая

		

		model.currentStop.add(0.3*(vs.get(0).getPortInterest()+vs.get(1).getPortInterest()+vs.get(2).getPortInterest()));

		model.currentStop.add(0.1*(vs.get(0).getPortAge()+vs.get(1).getPortAge()+vs.get(2).getPortAge()));

		model.currentStop.add(0.1*(vs.get(0).getPortOccup()+vs.get(1).getPortOccup()+vs.get(2).getPortOccup()));

		

		model.bestStop.add(0.3*(vs2.get(0).getPortInterest()+vs2.get(1).getPortInterest()+stp.get(0).getPortInterest()));

		model.bestStop.add(0.1*(vs2.get(0).getPortAge()+vs2.get(1).getPortAge()+stp.get(0).getPortAge()));

		model.bestStop.add(0.1*(vs2.get(0).getPortOccup()+vs2.get(1).getPortOccup()+stp.get(0).getPortOccup()));

		double itog = resVs / resVs2;

		if (itog >= 0.4)

			answer = "Прибыльное";

		else

			answer = "Убыточное";

		cnt.disconnect();

		return answer;



Листинг H.4. Реализация алгоритма без указания адреса

public static List<Areas> запросВыборкиОстановокПоКатегориям(

			int idInterest, int idAge, int idOccup) throws SQLException {

		ConnectToMSSQL cnt = new ConnectToMSSQL();

		cnt.createCon();

		Connection c = cnt.con;

		Statement st = c.createStatement();

		List<Areas> areas = new ArrayList<Areas>();

		int kolvo = 5;

		List<Stops> stp = mainEstimationMethod(idInterest, idAge, idOccup, st,

				kolvo);

		for (Stops s : stp) {

			Areas area = new Areas();

			ResultSet rs2 = st.executeQuery("select * from stops");

			double[] mas2 = new double[2];

			List<Stops> vs2 = new ArrayList<Stops>();

			for (int i = 0; i < 2; i++)

				vs2.add(new Stops());

			double k = -1;

			while (rs2.next()) {

				Stops stp2 = new Stops();

				stp2.setId(rs2.getString(1));

				stp2.setName(rs2.getString(2));

				stp2.setLatLng(rs2.getString(3));

				k = insertData.gettingStopsForOrg(s.getLatLng(), stp2

						.getLatLng());

				if (k != -1) {

					if (k == -1)

						break;

					int l = insertData.checking2(mas2, k);

					if (l == 0) {

						String id = stp2.getId();

						vs2.get(0).setId(id);

						vs2.get(0).setName(stp2.getName());

						vs2.get(0).setLatLng(stp2.getLatLng());

					} else {

						if (l == 1) {

							vs2.get(1).setId(stp2.getId());

							vs2.get(1).setName(stp2.getName());

							vs2.get(1).setLatLng(stp2.getLatLng());

						}

					}

				}

			}

			calculatingPortion(idInterest, idAge, idOccup, st, vs2);

			Double resVs = vs2.get(0).getRes() + vs2.get(1).getRes()

					+ s.getRes();

			List<Stops> lst = new ArrayList<Stops>();

			lst.add(s);

			lst.add(vs2.get(0));

			lst.add(vs2.get(1));

			Collections.sort(lst);

			area.setStp(lst);

			area.setPortion(resVs);

			areas.add(area);

		}

		Collections.sort(areas);

		cnt.disconnect();

		return areas;

	}







	}

