ВЫПУСКНАЯ КВАЛИФИКАЦИОННАЯ РАБОТА
по направлению 231000.62 Программная инженерия
подготовки бакалавра

На тему: Программа восстановления каркасных 3D объектов из 2D проекций

Студента группы № _____	________________   ________________________ 
 		Подпись			(Ф.И.О.)

________________
(Дата)

Научный руководитель

__________________________		________________    ________________________ 
(должность, звание)				подпись				(Ф.И.О.)

________________
(Дата)





















Москва, 2014


Реферат

	Отчет 35 с., 3 главы, 16 рис., 1 табл., 12 источников, 5 прил.

каркасная модель, псевдокаркасная модель, восстановление псевдокаркасной модели, восстановление каркасной модели, восстановление каркасных 3d объектов по 2d проекциям.



	Объектом разработки является  программа восстановления каркасных 3D объектов по 2D проекциям.

	Цель работы –разработка приложения, которое получает на вход три ортогональные 2D проекции объекта и создает трехмерную каркасную модель на выходе.

	В ходе работы проводились анализы существующих подходов к восстановлению 3D объектов: метода отображения границ и конструктивной сплошной геометрии. Также были проанализированы некоторые алгоритмы восстановления трехмерных моделей.

	В результате работы была разработана программа, позволяющая загрузить три файла ортогональных проекций в одном из основных форматов хранения изображений САПР DXF и восстанавливающая трехмерную псевдокаркасную модель объекта. Пользователь может взаимодействовать с полученной моделью (вращать, масштабировать). Кроме того пользователь может интерактивно удалять ребра для того чтобы получить необходимую ему каркасную модель.

	От своих аналогов программа отличается простотой в использовании и поддержкой операционной системой OS X.

	Программа может применяться при изучении инженерной и компьютернй графикой.

В дальнейшем планируется добавить в программу возможность восстановления solid объектов из 2D проекций. 


Определения, обозначения и сокращения

САПР – система автоматизированного проектирования.

Псевдокаркасная модель – модель, включающая в себя дополнительные ребра, которые принадлежат проекции, но могут не принадлежать итоговому объекту.

CSG – constructive solid geometry, конструктивная сплошная геометрия – один из подходов к восстановлению 3D объектов по проекциям.

Face – лицевая поверхность – грань, относящаяся к некоторому ребру.

Ребро – сторона грани. - 


Введение

Восстановление 3D моделей по их 2D проекциям является важным объектом исследования уже долгое время. В основном свое применение эта область исследования нашла в инженерном деле. До того как построить некоторую деталь, создаются ее различные чертежи и проекции. Для того чтобы получить более широкое представление о том, что получится в итоге, создается 3D модель, даже если этот процесс занимает значительное количество времени.

Наибольший прорыв в области восстановления 3D моделей совершили Wesley и Markowsky в своих работах [8, 11], предложив использовать каркасную модель как промежуточный шаг процесса восстановления. На сегодняшний день они являются одними из самых известных исследователей в этой области, а их подход используется при разработке практически любого нового алгоритма восстановления 3D моделей.

Процесс восстановления, который включает в себя взаимодействие пользователя с системой, чаще всего занимает значительное количество времени, вследствие чего разрабатываются различные алгоритмы для автоматического восстановления 3D моделей. Эти алгоритмы могут быть разделены на два типа в зависимости от существующих подходов. На данных момент существует два основных похода к восстановление 3D моделей: метод отображения границ и метод конструктивной сплошной геометрии. Метод отображения границ состоит в работе с линиями (ребрами) и вершинами, в свою очередь метод конструктивной сплошной геометрии основан на работе с геометрическими примитивами, такими как куб или шар.

Можно выделить две основные стадии восстановления 3D объектов по проекциям: создание псевдокаркасной модели объекта (pseudo-wireframe) и создание объекта (solid). Псевдокаркасная модель состоит из набора вершин и ребер, соединяющих эти вершины. Она может содержать лишнюю, но в то же время более полную информацию об описываемом объекте. В отличие от каркасной модели, она может включать в себя «лишние» ребра, которые принадлежат описывающим ее проекциям (рис. 1) Одна псевдокаркасная модель может описывать большое количество 3D объектов (рис .2). 



Рисунок 1. Три проекции октаэдра



Рисунок 2. (a) – псевдокаркасная модель октаэдра, (b, c, d) – возможные solid объекты, этой модели



При анализе существующих приложений, предоставляющих возможность работы с 3D моделями, было выделено несколько самых популярных решений: Autodesk 3DS Max, Autodesk Autocad, Kompas-3D, Matlab, Blender (табл. 1). 


Сравнительная таблица существующих решений



Основным недостатком всех перечисленных систем за исключением последней является их платное распространение. Кроме этого Kompas-3D и Blender не имеют функционала восстановления 3D моделей из 2D проекций.

Autocad широко используется в сфере инженерного проектирования, однако реализованная в этой программе система восстановления 3D моделей из проекций основана на взаимодействии пользователя с системой.

3DS Max является практически самой распространенной и широко используемой системой для работы с трехмерной графикой. Программа предоставляет возможность восстанавливать 3D модель по проекциям, однако имеет довольно сложный интерфейс, а так же работает только в операционной системе Windows.

Matlab - кроссплатформенный пакет программ, который как и Autocad широко используется в сфере инженерного проектирования. Кроме этого Matlab является высокоуровневым интерпретируемым языком программирования, поэтому для работы необходимы соответствующие знания языка.

Таким образом очевидна актуальность разработки свободно распространяемой программы восстановления каркасных 3D объектов по трем 2D проекциям для операционной системы OS X, которая была бы доступна для работы пользователю без специальной подготовки. Выбор операционной системы обуславливается тем, что из перечисленных приложений ее поддерживают только Autocad, Blender и Matlab. А эти приложения либо не предоставляют необходимой функциональности, либо требуют дополнительных знаний для работы с ними, либо не распространяются свободно.

Целью данной выпускной квалификационной работы является разработка программы восстановления каркасных 3D объектов, состоящих из многогранников, по 2D ортогональным проекциям для операционной системы OS X.

Для достижения цели работы необходимо решить следующие задачи:

Изучить существующие форматы представления инженерных чертежей;

Рассмотреть основные подходы в восстановлении 3D объектов по 2D проекциям;

Изучить существующие алгоритмы восстановления трехмерной модели по трем двухмерным ортогональным проекциям;

Разработать программу, принимающую на вход три 2D проекции (вид сверху, вид спереди, вид сбоку) в одном из базовых CAD форматов (DXF) и восстанавливающую корректную каркасную 3D модель заданного объекта на выходе.

Протестировать работу приложения при помощи известных примеров.




Обзор существующих подходов и программных решений

Существующие подходы

Метод отображения границ

Одни из первых исследований в области восстановления 3D моделей по проекциям были проведены профессором Masanori Idesawa в 1973 году и были представлены в его работе “A system to generate a solid figure from three views” [6,7]. Idesawa предложил способы восстановления трехмерных вершин, ребер и лицевых поверхностей для многогранных объектов. Кроме того, так как некоторый набор вершин и ребер (каркасная модель) может описывать несколько объектов, он предложи способ, как удалять “призрачные ” ребра для того чтобы в итоге получать уникальный объект. Сам предложенный алгоритм состоял в следующих шагах.

На вход программе подаются три проекции, которые представлены наборами вершин и ребер. Все вершины представляются в виде их координат x, y, z и порядковых номеров этих вершин. Пусть  описывает вершину, тогда  описывает набор вершин, которые соединяюются с  ребрами. Если три или больше вершин находятся на одной прямой, они объединяются в группу.  описывает группы, к которым принадлежит .

Точки в трехмерном пространстве описываются как



,				(1)



где  - координаты i-го элемента списка вершин,

с – некоторая координата,

 - количество вершин в ,

 - количество вершин в ,

 - количество вершин в .

Пусть () представляется комбинацией i, j, k так что выполняются условия . Тогда () образуют матрицы трехмерных вершин . Эти операции применяются в (1) ко всем комбинациям i, j, k. Условия  выполняются следующим образом:

Если , тогда 

Если , тогда  ,

Если , тогда 

где  – положительной число, обозначающее погрешность.

Пусть  и  – две разные вершины в V. , ,  используются для обозначения i, j, k в .  является элементом  относительно ., ,  используются для обозначения i, j, k в .  является элементом  относительно . Далее  обозначает k-ый элемент , который является элементом  относительно.  обозначает k-ый элемент , который является элементом  относительно. Похожие переменные принимаются для плоскостей YZ и XZ.

Таким образом результатом следующих булевых операций является определение того, соединяются ли вершины  и  ребром:















При восстановлении лицевых поверхностей используются следующие правила.

Существует k лицевых поверхностей, содержащих вершину пересечения k ребер;

Ребро представляет собой границу двух лицевых поверхностей, а в списках их границ вершины этого ребра идут в разном порядке;

Граница лицевой поверхности замкнута.

Для начала необходимо используя эти правила найти грань, которая может быть уникально определена. Затем нужно провести поиск всех ребер на границе грани и сохранить эти ребра в список и отсортировать, чтобы они удовлетворяли правилу (b). В конце нужно отсортировать вершины ребер против часовой стрелки для внешней лицевой поверхности и по часовой стрелке для внутренней поверхности грани.

 Это был один из первых подходов к восстановлению 3D объектов. Впоследствии алгоритмы, в которых происходит работа с ребрами, получили общее название Boundary representation (Метод отображения границ). Модели в методе отображения границ создаются при помощи топологии и геометрических объектов. Основными топологическими единицами являются: faces (лицевые грани, или поверхности), edges (ребра) и vertices(вершины). Face – это ограниченная часть поверхности, относящаяся в некоторому ребру, ребро – сторона грани. В 1980 году George Markowky, профессор университета Мэна, и Michael A. Wesley из исследовательского института IBM Томаса Уотсона в своей работе “Fleshing out Wireframes” [8,11] предложили использовать псевдокаркасную модель как промежуточную стадию процесса восстановления 3D объекта. Эта работа до сих пор является основополагающей для разработки новых алгоритмов в рамках метода отображения границ. 

Конструктивная сплошная геометрия

Первые исследования в рамках второго подхода к восстановлению 3D объектов по 2D проекциям были произведены Aldefel в 1983 году [1]. На входе в программу принимаются три проекции, из которых считываются данные о примитивах. Aldefel описывает возможные связи между примитивами. Одной из основных связей является CONTACT(n, m), которая обозначает что n и m связаны хотя бы одной общений точкой. Петля – замкнутая кривая без самопересечения.

Шаг 1: Установить все отношения между примитивами, которые связаны связью CONTACT.

Шаг 2: Найти, сохранить в списке все элементарные петли (петли, которые не содержат других петель) и отметить их как “открытые”. 

Шаг 3: Вычисление объема всех “открытых” петель и выбор петли P с максимальным объемом. Также случайным образом выбирается проекция , которая будет считаться базовым силуэтом. 

Шаг 4: Предположим что P описывает базовый силуэт одного или нескольких объектов. Для того чтобы доказать или опровергнуть это, необходимо выполнить следующий алгоритм:

Случайным образом выбирается проекция  и в ней ищутся все прямоугольные силуэты , которые совпадают с P. Если таких силуэтов не найдено, выйти из алгоритма. 

В оставшейся проекции  найти для каждого  прямоугольный силуэт , совпадающие как с , так и с P. Если таких силуэтов не найдено, выйти из алгоритма.

Проанализировать P и найти все примитивы, которые требуют наличия линий в одной или обеих проекциях (базовая проекция не учитывается).

Для каждой пары () найти полный список линий, которые описываются их примитивами. Если операция прошла успешно, итоговый объект представлен объединением  и списка линий, полученных на этом шаге.

Шаг 5: “Увеличить” петлю P, создав все петли, которые включают в себя петли, прилежащие к P, если их еще не существует. Добавить их в список, отметить новые зависимости, отметить новые петли как “открытые”, а P пометить как “закрытую”.

Шаг 6: Спроецировать полученные объекты на плоскости, чтобы определить, описываются ли они входными проекциями. Если это так, то на этом работа алгоритма завершается, в противном случае перейти к шагу 3.

 Описанный алгоритм работает только для объектов равномерной толщины. Подход носит название Конструктивная сплошная геометрия (Constructive solid geometry | CSG), и его основной концепцией является  возможность математического описания любых сложных объектов при помощи более простых. Простейшими телами в CSG являются примитивы – тела простой формы, такие как куб, сфера, цилиндр, призма. Более сложные объекты создаются при помощи применения булевых операций (объединение, пересечение, разность) к некоторому набору примитивов. 

Восстановление сплошных тел по шести проекциям

Впоследствии Shum предложил алгоритм, в котором для восстановления 3D модели используются шесть проекций [4,11]. Алгоритм не обрабатывает пунктирные линии на проекциях. На проекциях допускаются прямые линии и круги, а также многогранные объекты с гранями, ортогональными хотя бы к одной оси координат, и ортогональные цилиндры.

В начале работы проекции делятся на три группы смежных проекций и располагаются соответствующим образом друг относительно друга. В процессе инкрементального выдавливания один из контуров становится образующим, а второй – направляющим. Из шести проекций образуются три пары. Для того чтобы образующий контур и направляющий не были параллельны, следующие операции выдавливания не выполняются :, , ,  и т.д. , где f-front, R-rear, t – top, b – bottom, r- right, l- left. Кроме того, существует только шесть комбинаций пар проекций для процесса инкрементального выдавливания:









Инкрементальное выдавливание делится на три шага: сегментация образующих контуров в сегментные контуры, выдавливание толщины в направляющей проекции, совершение выдавливания.

В процессе инкрементального выдавливания учитываются только образующие контуры, внешние линии образующей грани. В начале находятся все точки поворота в направляющем контуре, затем они проецируются перпендикулярно на общую грань проекции. Эти точки используются для разделения образующего контура не несколько сегментных контуров. Результатом является матрица SGS:

],

где  - i-ый сегментный контур,

n – количество сегментных контуров для выдавливания.

Расстояния между точками поворота вдоль направления выдавливания определяют толщину выдавливания: , где m – количество инкрементальных выдавливаний.

В процессе самого выдавливания все сегментные контуры соединяются с толщинами выдавливания для того чтобы сформировать примитивные solid-объекты. Булевая операция объединения примитивных solid-объектов затем создаст выдавленный solid.

В итоге для каждой пары проекций объединение всех примитивов создаст два выдавленных solid-объекта. К ним применяется операция пересечения, чтобы сформировать solid пересечения. Пересечение пересеченных solid-объектов для всех пар проекций создаст итоговый solid.

	Как конструктивная сплошная геометрия, так и метод отображения границ используются для создания итоговых 3D объектов. Как правило, восстановление псевдокаркасной модели является этапом работы алгоритмов обоих подходов. Однако задачей работы является восстановления каркасных моделей из 2D проекций. Основной вклад в разработку алгоритма восстановления каркасной модели внесли Markowsky и Wesley. При разработке последующих алгоритмов именно их подход всегда используется при восстановлении каркасных моделей объектов. Поэтому именно этот алгоритм был выбран для разработки приложения. 


Описание используемых алгоритмов

Извлечение 2D ортографической информации

Каркасная модель  объекта  строится по фронтальной проекции (FV – front view), боковой проекции – виду справа (SV – side view) и верхней проекции – вид сверху (TV – top view), которые подаются на вход программе в формате систем автоматизированного проектирования (САПР) DXF. Файл каждой проекции необходимо проанализировать и загрузить информацию о хранящихся в нем геометрических компонентах – вершинах и ребрах –  в матрицы :

 ,

где  - координаты вершины - начала ребра,

 - координаты вершины - конца ребра,

где ,

n – количество ребер в проекции.

Каждое ребро задается координатами двух вершин, координаты одной вершины могут встречаться в описании несколько раз по количеству сходящих в ней ребер.

Разметка 2D граней и вершин

Для того чтобы уменьшить количество параметров, определяющих ребра, каждая вершина отмечается порядковым номером. Номера вершин будут описывать ребра вместо координат этих вершин.  Кроме того, сами ребра также отмечаются порядковыми номерами. Таким образом для каждой проекции создаются матрицы  и  для хранения информации о вершинах и ребрах соответственно:

 ,

где  – порядковый номер i-ой вершины,

 - координаты i-ой вершины, i =1,2,…,k

k – количество вершин проекции.

 ,

где  - объект типа «ребро», i = 1,2,…,n

n – количество ребер проекции.



Каждый объект типа «ребро» содержит4 следующую информацию:

 ,

где  - порядковый номер ребра,

 – порядковый номер вершины, определяющей начало ребра,

 - порядковый номер вершины, определяющей конец ребра,

 - тип ребра,

i = 1,2,…,n,

n – количество ребер проекции.



Таким образом матрица вершин содержит порядковые номера вершин проекции и их координаты, а матрица ребер – порядковые номера ребер и порядковые номера вершин, определяющих эти ребра. Тип ребер предлагается запоминать для обработки пунктирных линий на проекции, которые обычно используются для обозначения ребер, находящихся не на лицевых гранях проекции.

Координаты вершин проекций могут значительно отличаться, поэтому для упрощения работы с ними предлагается сдвинуть каждую проекцию таким образом чтобы она находилась в первом квадранте и хотя бы одна точка лежала на оси X и хотя бы одна точка лежала на оси Y. Для этого необходимо найти минимальную координату  и минимальную координату   вершин в каждой проекции. После этого необходимо выполнить следующую операцию для матриц каждой проекции:

 ,

 ,

где fv[i,2] – элемент i-ой строки и второго столбца матрицы ,

fv[i,3] – элемент i-ой строки и третьего столбца матрицы .

Впоследствии ребра проекции будут сравниваться с ребрами каркасной модели. Так как одно ребро проекции может описывать большое количество ребер в каркасной модели, ребра проекции должны быть максимальной длины, а не множеством коротких отрезков, лежащих на одной прямой.



Рисунок 3. Вид сбоку

 Например на рисунке 3 представлена проекция некоторого объекта. В конечной матрице проекции не должно существовать несколько ребер, лежащих на одной прямой и пересекающихся в вершинах, таких как bc, cd и fg, gc. Если они были обнаружены, то оба ребра, лежащие на одной прямой, удаляются из , и добавляются ребра bd и fc соответственно. 

Объединение граней и вершин

Для последующей работы с данными о проекциях необходимо создать две новых матрицы  и  для верхней и боковой проекции соответственно. После этого нужно выполнить следующие операции над новыми матрицами:

,

,

где rtv[i,3] – элемент i-ой строки и третьего столбца матрицы  (координата y),

rtv[i,4] – элемент i-ой строки и четвертого столбца матрицы  (координата z),

rsv[i,2] – элемент i-ой строки и второго столбца матрицы  (координата x),

rsv[i,4] – элемент i-ой 4строки и четвертого столбца матрицы  (координата z).



Предполагается, что проекции, полученные в начале работы программы из файлов, созданы в едином масштабе. Для упрощения работы с каркасной моделью необходимо перенести данные о проекциях из матриц вершин  в общую матрицу вершин  и из матриц ребер  в матрицу ребер .

Данные о проекциях расположены в  и  последовательно, поэтому теперь легко можно провести перпендикуляры из всех вершин: по z для фронтальной проекции, по y вверх для верхней проекции и по x вправо для боковой проекции, - и добавить новые вершины в , а новые ребра в .

На этом этапе работы алгоритма часть ребер никак не связана между собой, а также существуют повторяющиеся ребра, поэтому нужно удалить повторяющиеся вершины из  и заменить порядковые номера этих вершин в  на соответствующие не удаленные. Кроме того, нужно удалить повторяющиеся ребра из .

Нахождение точек пересечения ребер

Перпендикуляры, проведенные на предыдущем шаге все еще никак между собой не связны, поэтому необходимо найти точки их пересечения. Заранее не известно, какие именно ребра пересекаются; для каждого ребра проверяются все остальные, еще не проверенные ребра, на предмет их пересечения. В этой проверке можно выделить четыре случая: ребра параллельны / находятся на одной прямой / скрещиваются (лежат в параллельных плоскостях) / пересекаются. Проверку нужно провести только на нахождение ребер на одной прямой и на пересечение.

Определение нахождения ребер на одной прямой

Уравнение прямой, проходящей через две точки, в трехмерном пространстве выглядит следующим образом:



где  - координаты первой точки,

 - координаты второй точки.



Так как проверяемые ребра (восстановленные перпендикуляры) параллельны хотя бы одной оси координат, в этой формуле будет происходить деление на ноль, во избежание этого нужно воспользоваться правилом пропорции:

 					(2).



Допустим, сравнивается ребро AB и ребро CD, если подставить в (2) вместо  координаты вершины A, вместо  координаты вершины B, а вместо  поочередно координаты вершин C и D, и оба выражения будут выполняться, то ребра лежат на одной прямой.

В этом случае ребра могут не пересекаются. Если же ребра ab и cd пересекаются могут возникнуть пять ситуаций: 

ребра пересекаются в одной из существующих вершин (рис. 4); 



Рисунок 4.

ребра совпадают, в этом случае второе ребро удаляется из ;

одна из вершин одного ребра находится на другом ребре, к примеру вершины ребер ab и cd расположены в следующем порядке: a c b d, в этом случае ребра ab и cd удаляются из , а новые ребра ac, cb и bd добавляются в матрицу (рис. 5);



Рисунок 5.

одно ребро находится внутри другого, но вершины не совпадают, в этом случае меньшее ребро удаляется из . Например на рис. 6 нужно удалить ребро ab;



Рисунок 6

одно ребро находится внутри другого, и одна из вершин ребра ab совпадает с одной из вершин ребра cd, к примеру если a = c и вершины расположены в порядке: a=c, d, b (рис. 7), ребро ab удаляется из , а новое ребро db добавляется в матрицу.



Рисунок 7.

Определение пересечения ребер

Две прямые AB и CD:



проходящие через точки  ,  и  , соответственно, пересекаются, если выполняется условие:





и если ранг этой матрицы равен двум. Иными словами для прямых AB и CD нужно найти такие коэффициенты u и v, что система из трех уравнений (3) имеет решение:



 			(3)





Определитель матрицы 3х3 считается по формуле (4):





 (4).



Ранг матрицы равен количеству ненулевых строк в матрице ступенчатого вида. Для того чтобы привести матрицу к ступенчатому виду можно воспользоваться методом Гаусса, для этого введем элементарные преобразования матрицы:

Перестановка двух столбцов или строк матрицы;

Умножение элементов одной строки или столбца на одно и то же число, отличное от нуля;

Прибавление к элементами одной строки или столбца соответствующих элементов другой строки или столбца, умноженных на одно и то же число.

Для того чтобы привести матрицу к ступенчатому виду методом Гаусса необходимо выполнить следующие шаги:

Выбрать в первом столбце элемент, отличный от нуля (ведущий элемент). Если строка с ведущим элементов (ведущая строка) не первая, переставить ее на место первой строки (преобразование I типа). Если в первом столбце нет ведущего элемента, то продолжить поиск в оставшейся части матрицы. Нужно закончить преобразования если исключены все столбцы.

Разделить все элементы ведущей строки на ведущий элемент. Если строка последняя, то преобразования заканчиваются.

К каждой строке ниже ведущей строки прибавить ведущую строку, умноженное на такое число, что все элементы ниже ведущего элемента становятся равны нулю.

Исключив ведущую строку и ведущий столбец, перейти к пункту 1 для оставшейся части матрицы.

Если определитель равен нулю и ранг матрицы равен двум, систему уравнений (2) можно решить при помощи формул Крамера [12]. Для решения системы из трех уравнений с двумя неизвестными достаточно двух уравнений, поэтому решение, использующее первое и второе уравнение будет иметь вид:





.



Если плоскость, в которой находятся пересекающиеся ребра, перпендикулярна плоскости XY, то D будет равен нулю. Аналогично плоскость пересечения может быть перпендикулярна плоскостям XZ и YZ. Поэтому для нахождения точки пересечения выбираем пару уравнений, где D не равен нулю. Таким образом, решение для первого и третьего уравнений:





.

Решение для второго и третьего уравнений:





.



В случае пересечения ребер возможны четыре случая:

Прямые, определенные вершинами ребер пересекаются, но сами ребра не пересекаются;

Ребра пересекаются в одной из их вершин. Если ребро ab пересекает cd в точке a (рис. 8), то cd удаляется из , а новые ребра ca и ad добавляются в список;



Рисунок 8.

Ребра пересекаются в новой вершине. Если ребро ab пересекает cd в некоторой точке m (рис. 9), ab и cd удаляются из , а новые ребра am, mb, cm, md добавляются в список;



Рисунок 9.

Ребра пересекаются двумя вершинами (рис. 10).



Рисунок 10.

Таким образом в каркасную модель добавлены все ребра, ортогональные ко всем трем проекциям. Следующим шагом является добавление ребер, не ортогональных ни к одной проекции.

Создание не ортогональных ребер

Для того чтобы  создать все возможные ребра не ортогональные ни к одной плоскости проекции, необходимо спроецировать вершины  на каждую из плоскостей XY, XZ и YZ. Под проецированием понимается приравнивание к нулю одной из координат трехмерной вершины, Таким образом при проецировании на плоскость XY координата z приравнивается к нулю, при проецировании на XZ координата y приравнивается к нулю, при проецировании на YZ координата x приравнивается к нулю. 

После этого для каждой вершины каркасной модели перебираются вершины соответствующей проекции ( для XY,  для XZ,  для YZ). Для каждой i-ой вершины проекции выделяются координаты вершин, соответствующие плоскости, на которую модель спроецирована, которые соединяются ребрами с i-ой вершиной (соседних вершин). В каркасной модели создаются ребра, соединяющие i-ую вершину и все вершины с выделенными двухмерными координатами.

На рисунке 11 приведен пример проекций некоторого объекта (a,b,c) и результат, который был достигнут на момент выполнения шага 2.4.2.



Рисунок 11. (a) – фронтальная проекция, (b) – вид сверху, (c) – вид сбоку, (d) – текущая каркасная модель.

 На текущем этапе алгоритма необходимо восстановить реба FL и CO. Из модели видно, что для этого необходимо  спроецировать модель на плоскость YZ (боковая проекция). В этом случае координаты y и z каждой вершины сравниваются с соответствующими координатами матрицы . К примеру вершина  С по этим координатам равна вершине D проекции. Для вершины D находятся все вершины, которые соединяются ребрами с D. На проекции это вершины E, N, M. После этого в каркасной модели находятся все вершины, чьи координаты y и z (в данном случае) равны координатам y и z вершин E, N или M. Из проверяемой вершины C проводятся все возможные ребра к найденным вершинам, если таких ребер еще не существует. Таким образом в каркасную модель добавятся ребра CA, CE, CK, CM, CH, CO, CN (рис. 12).



Рисунок 12.

Таким образом, необходимое ребро CO, которое не ортогональной ни одной проекции, было добавлено в список ребер. Все остальные ребра, скорее всего, не принадлежат всем проекциям и будут удалены на следующем шаге алгоритма. Такие операции производятся для каждой вершины модели, а так же для каждой проекции.

Удаление лишних ребер

На данном этапе выполнения алгоритма в псевдокаркасной модели существует большое количество ребер, не принадлежащих проекциям. Для того чтобы их удалить, необходимо спроецировать вершины  на каждую из плоскостей XY, XZ и YZ и сравнить ребра ) с ,  и  соответственно. Если спроецированное ребро модели совпадает с одним из ребер соответствующей проекции, но не выходит за его пределы, оно остается в списке, в противном случае – удаляется. 

В дополнение к алгоритму построения псевдокаркасной модели объекта по трем 2D проекциям, предложенному Markowsky и Wesley [11], в работе предлагается алгоритм обработки пунктирных линий, который можно использовать для несимметричных относительно центра проекций. 

Изначально предполагается что объект, чья псевдокаркасная модель создается в ходе алгоритма, симметричен относительно центра, поскольку известны только три его проекции. На предыдущем шаге могли быть созданы ребра, которые принадлежат проекциям, но в итоговую каркасную модель не входят. 

Рассмотрим возможность восстановления каркасных моделей несимметричных объектов. Предположим, что фигура симметрична только относительно двух плоскостей XY и YZ. Для каждого пунктирного ребра проекции создается список ребер из , которые совпадают с пунктирным ребром. Если удалять ребра на ближайшей и дальней гранях каждой плоскости, то может возникнуть ситуация, при которой на дальней грани удалятся нужные ребра. Поэтому предлагается для фронтальной проекции из получившихся списков удалять ребро с наименьшей координатой z. Для боковой проекции удалять ребро с наибольшей координатой x. Для верхней проекции удалять ребро с наибольшей координатой y.

Таким образом, из трех двумерных проекций в результате работы алгоритма получается псевдокаркасная модель с допущением, что на дальних гранях объекта могут  сформироваться ребра, принадлежащие проекциям, но, возможно, не принадлежащие объекту. Пользователю предоставляется возможность интерактивного удаления лишних ребер.


Разработка программы

Формат DXF

DXFTM – открытый формат файлов для обмена данными между приложениями систем автоматизированного проектирования (САПР). Был создан для Autocad фирмой Autodesk и поддерживается практически всеми системами САПР на платформе PC. Наряду с форматом DWG является одним из самых распространенных форматов файлов для обмена графической информацией, однако DWG является закрытым форматом, тогда как для DXF Autodesk предоставляется бесплатную спецификацию [3]. DXF формат содержит все информацию об изображении в виде маркированных данных. Это означает что различные данные обозначаются целыми числами.

Формат DXF состоит из семи следующих разделов (см. Приложение А рисунок 3):

HEADER – содержит основную информацию о чертеже. К примеру, здесь может храниться название программы, в которой был создал файл, версия программы, максимальные и минимальные координаты в чертеже (см. Приложение А рисунок 4).

CLASSES – содержит информацию об объявленных в приложении экземплярах классов, которые используются в разделах BLOCKS, ENTITIES и OBJECTS.

TABLES – хранит массивы данных, такие как таблица слоев, таблица стилей, таблица типов линий (см. Приложение А рисунок 5).

BLOCKS – хранит данные о примитивах, объединенных в блоки. Блок имеет уникальный идентификатор и название и может использоваться в разделе ENTITIES (см. Приложение А рисунок 7).

ENTITIES – хранит данные о примитивах (см. Приложение А рисунок 6).

OBJECTS – содержит данные о не графических объектах, которые используются в приложениях, написанных на AutoLISP и ObjectARX.

THUMBNAILIMAGE – хранит изображение того, что находится на чертеже.

Формат входных данных

Входные данные представлены в виде файлов трех проекций: вид спереди, вид сверху, вид сбоку, - в формате DXF. Программе необходимо знать, какой проекцией является каждый из файлов, поэтому проекции должны иметь название “FV.dxf” или “fv.dxf”, “TV.dxf” или  “tv.dxf”, “SV.dxf” или “sv.dxf” соответственно. Проекции должны быть описаны линиями. Важно отметить, что линии, находящиеся за пределами грани проекции должны быть обязательно описаны при помощи линии типа пунктир (рис. 13).



Рисунок 13. Проекции буквы «Т». (a) –вид сверху, (b) –вид спереди, (c) –вид сбоку.

Программа распознает пунктирные линии, которые имеют подстроку «DASHED» в своем названии. Все остальные типы линий распознаются как обычные.

Выходные данные

В результате работы программы формируется каркасная 3D модель объекта, описанного тремя проекциями, полученными на входе в программу (рис. 14).



Рисунок 14. Результат работы программы. (a) – вид сверху, (b) – вид спереди, (c) – вид сбоку, (d) –получившаяся псевдокаркасная модель.



Так как итогом работы описанного алгоритма является псевдокаркасная модель, пользователь может сам выбрать и удалить лишние по его мнению ребра. В связи с этим реализованы функции “Отменить” и “Повторить” при помощи класса “NSUndoManager”.  

Выбор средств разработки

В работе предлагается разработать приложение, работающее под операционной системой OS X. Ввиду этого в качестве языка разработки выбран объектно-ориентированный язык Objective C и среда разработки Xcode. Для работы с файлами формата DXF выбран фреймворк DXFReader [10]. При анализе файла он возвращает массив примитивов, содержащихся в файле, и их данных. Для вывода проекций и каркасной модели на экран используются методы фреймворка “QuartzCore”.

Диаграмма классов



Рисунок 15. Диаграмма классов разрабатываемого приложения восстановления каркасных 3D объектов по 2D проекциям

Основным классом программы является “Document”, в нем создается объект класса “Wireframe” и вызывается метод “wire”, в котором происходит создание каркасной модели. Кроме того в “Document” происходит обработка работы пользовательского интерфейса. Все данные о проекциях и каркасной модели хранятся в экземпляре класса “Model”. Классы группы “Views” являются классами, обрабатывающими вывод на экран проекций и самой каркасной модели. “View1” выводит фронтальную проекцию, “View2” выводит верхнюю проекцию, “View3” выводит боковую проекцию, “ShowView” обрабатывает выводит на экран каркасной модели при помощи методов, которые будут описаны в следующем разделе. Класса группы “Operations” содержат классовые методы для работы с вершинами (класс “Vertices”) и ребрами (класс “Edges”), а также некоторые математические операции (класс “AAMath”).

Вывод на экран каркасной модели

При описании фигуры для вывода ее на экран используется матрица вершин A размером [n, 4].

,

где  – координаты x, y, z i-ой вершины,

n – количество вершин.

Четвертый элемент строки является однородной координатой k, и для однозначности принимается k=1. В ходе преобразований этот элемент изменяется и корректируется. Таким образом в однородных координатах каждая вершина  представляется в виде

,

где ,

,

.

Для того чтобы в ходе преобразований получить реальные координаты, необходимо делить каждую строку матрицы A на четвертый элемент этой строки.

В программе реализованы такие преобразования трехмерной машинной графики как

Повороты вокруг осей координат;

Масштабирование по осям;

Сдвиг вдоль осей координат.

Для выполнения соответствующего преобразования необходимо умножить матрицу A матрицу соответствующего преобразования.

Поворот вокруг оси Ox на угол  представлен матрицей :



Поворот вокруг оси Oy на угол  представлен матрицей :



Масштабирование по осям представлено матрицей :

,

где d – коэффициент масштабирования.

Сдвиг вдоль осей координат представлен матрицей :

,

где dx – коэффициент сдвига по оси Ox,

dy – коэффициент сдвига по оси Oy,

dz – коэффициент сдвига по оси Oz.

Стоит отметить, что после процесса восстановления фигура находится полностью в первом квадранте плоскости XZ (рис. 16). 



Рисунок 16. Пример результата работы программы до вывода на экран

Для удобства работы с фигуры необходимо сдвинуть ее центр в начало координат, для этого нужно умножить матрицу A на матрицу ,

где dx =,

dy =,

dz =.

	На экран выводят только координаты x и y матрицы A. Так как в NSView центр координат находится в левой нижней точке окна, при выводе на экран для нормального отображения фигуры к каждой координате x прибавляется переменннная drawX,, а к каждой координате y прибавляется переменная drawY. Изначально drawX равен половине ширины окна “ShowView”, а drawY равен половине высоты окна “ShowView”. Эти значения изменяются при изменении положения центра координат.


Заключение

В работе были решены следующие задачи:

Изучены существующие форматы представления инженерных чертежей;

Изучены существующие алгоритмы восстановления трехмерной каркасной модели по трем двухмерным ортогональным проекциям;

Предложен алгоритм удаления лишних ребер на описанных проекциями лицевых поверхностях, обозначенных на проекциях пунктирными линиями;

Разработано приложение, принимающее на вход три 2D проекции (вид сверху, вид спереди, вид сбоку) формата DXF и восстанавливающее корректную каркасную 3D модель заданного объекта на выходе.

Результатом работы является программа восстановления каркасных 3D объектов из 2D проекций для операционной системы OS X. В программе реализовано автоматическое создание псевдокаркасной модели, необходимую каркасную модель пользователь может получить при помощи удаления ненужных по его мнению ребер в полученной псевдокаркасной модели.

 В дальнейшем планируется изучить алгоритмы восстановления solid объектов из 2D проекций и добавить этот функционал в программу. Также возможно изучение процесса восстановления трехмерных объектов по набору фотографий.




Используемые источники

Aldefeld, B. (1983). On automatic recognition of 3D structures from 2D representations. Computer Aided Design, 15(2), 59-72.

Ç ̇ıçek, A. & Gülesin, M. (2004). Reconstruction of 3D models from 2D orthographic views using solid extrusion and revolution. Journal of Materials Processing technology, 152, 291-298.

DXF Format [DXF - DXF Reference]. (n.d.). Retrieved February 10, 2014, from 

Furferi, R., Governi, L., Palai, M., & Volpe, Y. (2011). 3D Model Retrieval from mechanical drawings analysis. International Journal of mechanics, 5(2), 91-99.

Governi, L. & Furferi, R. & Palai, M. & Volpe, Y. (2013). 3D geometry reconstruction from orthographic views: A method based on 3D image processing and data flitting. Computers in industry, 64, 1290-1300.

Idesawa, M. (1973). A system to generate a solid figure from three views. Bull JSME, 16, 216-225.

Lee, H. & Han, S. (2005).  Reconstruction of 3D interacting solids of revolution from 2D orthographic views. Computer-Aided Design, 37, 1388-1398.

Markowsky, G. & Wesley, M. (1980). Fleshing out wireframes. IBM Journal of Research and Development, 24 (5), 582–597. 

Shum, S. S. P., Lau, W. S., Yuen, M. M. F., & Yu, K. M. (1997). Solid reconstruction from orthographic opaque views using incremental extrusion. Computer Graphics, 26(6), 787-800.

SourceForge.net: DXFReader - Project Web Hosting - Open Source Software. (2009, February 22). Retrieved January 10, 2014, from 

Wesley, M.A. & Markowsky, G. (1981). Fleshing out projections, IBM Journal of Research and Development, 25 (6), 934–954. 

Мальцев А. И. Основы линейной алгебры. — Изд. 3-е, перераб., М.: «Наука», 1970. — 400 c.


Приложение А



Рисунок 1. Структура DXF файла



Рисунок 2. Структура секции HEADER в DXF файле



Рисунок 3. Структура секции TABLES в DXF файле





Рисунок 4. Структура секции ENTITIES в DXF файле





Рисунок 5. Структура секции BLOCKS в DXF файле

Рисунки (1-5) приводятся с сайта 
Импорт графических данных из DXF файла средствами C# Режим доступа:  , свободный. (дата обращения:3 9.04.14)