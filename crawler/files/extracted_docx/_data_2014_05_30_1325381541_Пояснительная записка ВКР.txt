Правительство Российской Федерации

Федеральное государственное автономное образовательное

учреждение высшего профессионального образования

"Национальный исследовательский университет

"Высшая школа экономики"



Отделение программной инженерии

Кафедра Управления разработкой программного обеспечения



УТВЕРЖДАЮ 

Зав. кафедрой УРПО 



________________ С.М. Авдошин 

«__» _______________ 2014 г.

 

ВЫПУСКНАЯ КВАЛИФИКАЦИОННАЯ РАБОТА

по направлению 231000.62 Программная инженерия

подготовки бакалавра



На тему: Программа динамического симметричного шифрования с возможностью поиска по ключевым словам в зашифрованных данных







Студенки группы № 471ПИ           ______________               Тужиковой Инны Ильиничны 

      Подпись                                                                            (Ф.И.О.) 

____________ 

(Дата) 

Научный руководитель 



Доцент кафедры УРПО, к.т.н.        ______________  Савельева Александра Александровна

                 (должность, звание)                                                            подпись                                                              (Ф.И.О.) 

________________ 

(Дата)



















Москва, 2014 г.




Реферат

Отчет 97 с., 4 ч., 11 рис., 11 табл., 4 прил., 40 источников.

Шифрование с возможностью поиска, зашифрованный индекс, SSE, безопасное криптографическое хранилище, безопасность в облачных хранилищах.

Областью исследования данной работы является проблема шифрования файлов, которое позволяет в дальнейшем производить процедуру поиска по ключевым словам в зашифрованной коллекции документов без предварительной расшифровки. Наиболее очевидное и эффективное применение данная схема шифрования может найти в системах удаленного хранения пользовательских файлов с шифрованием на клиентской стороне.

Основными целями данной работы являются реализация схемы шифрования с поиском в зашифрованных данных и оценка эффективности применения в системе удаленного хранения. В работе приведен обзор современного состояния теории и осуществлен сравнительный анализ существующих методов. На основе полученных результатов теоретической части работы реализована схема шифрования и проведена эмуляция взаимодействия клиента и сервера в контексте удаленного хранения файлов.

В работе подробно рассматривается реализация схемы шифрования и оценка полученных результатов. Дальнейшая работа над данной темой может быть направлена на применение полученных результатов в реальном облачном хранилище, а также исследование схемы шифрования с целью повышения эффективности по различным критериям.  





Введение

За последние годы облачные решения стали неотъемлемой частью информационных технологий. Все больше коммерческих организаций и пользователей персональных компьютеров используют облачные сервисы в своей работе. Так, исследование, опубликованное Enterprise Strategy Group [37], показывает, что 28% опрошенных компаний пользуются облачными технологиями, что в два раза больше, чем в 2009 году. Одним из популярных видов сервисов являются хранилища пользовательских данных. Примером подобных сервисов являются такие программные продукты как Dropbox, Google Drive, SkyDrive, которые предоставляют персональным и корпоративным пользователям услуги удаленного хранения данных.

Вместе с ростом популярности облачных хранилищ становится актуальным вопрос безопасности пользовательских данных в интернете. Еще одно исследование, проведенное Ponemon Institute [30] показывает, что только 19% организаций, использующих сервисы удаленного хранения файлов, избегают передачи конфиденциальных данных в облако. Вместе с этим, со стороны провайдеров облачных решений принимаются комплексные меры по защите пользовательских данных. Так, например, по заявлению в официальном блоге Dropbox [15], в системе пользовательские файлы защищаются с помощью шифрования, безопасной передачи данных по зашифрованным каналам и дополнительной функции двухэтапной проверки.

Несмотря на многочисленные заявления облачных провайдеров, шифрование внутри системы не может считаться до конца безопасным, поскольку нельзя быть полностью уверенным, что хранимые данные не могут быть расшифрованы злоумышленником из числа сотрудников облачного сервиса. В связи с этим получила распространение концепция шифрования на клиентской стороне. Эта идея подразумевает, что прежде чем данные будут отправлены на удаленный сервер, владелец зашифрует их собственным секретным ключом, защищенное хранение которого сделает невозможным получение доступа к файлам внутри облака. Существует ряд утилит, которые позволяют пользователю шифровать файлы и отправлять их в существующее облачное хранилище. Наиболее популярные среди подобных решений такие продукты как Boxcryptor [10], SecretSync [35] и TrueCrypt [39].

Идея шифрования на клиентской стороне видится решением многочисленных проблем безопасности пользовательских данных в интернете. Однако существует проблема, которая возникает при использовании данной концепции – работа с зашифрованными данными. В частности поиск в зашифрованной коллекции, находящейся на сервере, представляется нетривиальной задачей. Наиболее простым, с точки зрения реализации, и очевидным решением подобной проблемы является последовательное выполнение следующих операций: 

создать локальную копию зашифрованных файлов;

расшифровать файлы;

произвести поиск в каждом файле расшифрованной коллекции;

получить результаты поиска.

Данное решение имеет ряд недостатков, таких как дополнительные требования к объему жесткого диска и производительности компьютера. Когда речь идет о большом корпоративном файловом хранилище, расположенном на удаленном файловом сервисе, его полная выгрузка в собственную систему и дальнейшая обработка не представляются логичным решением и умаляют возможности, ради которых был выполнен перенос данных в облако.

Решением данной проблемы поиска по зашифрованным файлам может быть использование дополнительных структур данных, которые типично применяются в поисковых системах. Примером такого вспомогательного инструмента является индекс файловой коллекции. Индекс способен значительно сократить время поиска за счет его использования вместо последовательного поиска в каждом документе коллекции. Существуют лишь несколько решений, которые позволяют пользователю производить поиск в зашифрованных данных в облаке: Perspecsys [29] и CipherCloud [12]. Особенностью этих программных продуктов является создание индекса оригинальных документов наряду с шифрованием и отправкой их в облако. При этом индекс создается и хранится локально на клиентской стороне. Подобный подход имеет следующие недостатки: 

невозможность пользоваться сервисом на тех компьютерах, где нет локальной копии файлового индекса (получение доступа к облачных хранилищам с помощью смартфонов и планшетов  на данный момент стало вполне привычной и ожидаемой функцией);

необходимость дополнительных вычислительных ресурсов для выполнения операции поиска.

Комплексным решением данной проблемы является разработка систем, способных хранить индекс файловой коллекции на серверной стороне. В отличие от вышеуказанных решений, где индекс хранится локально в незашифрованной форме, индекс должен храниться в зашифрованной форме таким образом, что:

индекс не должен раскрывать серверу информацию о хранимых файлах;

индекс должен обеспечивать эффективные методы поиска по зашифрованной коллекции;

доступ к поиску по индексу должен осуществляться с помощью секретного ключа пользователя, который не может быть раскрыт сервером;

индекс должен обновляться при добавлении или удалении файлов в коллекцию без полной его перестройки.

Примером подобного решения является идея безопасного облачного хранилища (Secure cloud storage), предложенная в 2010 году исследователями из Microsoft Research [23]. Данная концепция подразумевает облачное решение, архитектура которого включает четыре основных компонента: обработчик данных, верификатор данных, генератор запросов серверу и генератор пользовательских идентификаторов. Обработчик данных осуществляет предварительное шифрование перед отправкой данных в облако. Верификатор отвечает за неизменность хранимых данных. Генератор запросов для сервера создает зашифрованные запросы, с помощью которых сервер находит и возвращает пользователю информацию. Генератор идентификаторов позволяет получать доступ к системе внешним агентам. Подобное решение позволяет избежать многих проблем безопасности и получить возможность поиска в зашифрованных данных. 

Безопасное облачное хранилище может в дальнейшем изменить подход к защите данных в интернете. В свою очередь, алгоритм поиска по зашифрованным данным является составной частью такого решения. Целями данной работы являются реализация такого алгоритма и оценка его эффективности. В рамках этой работы выделяются следующие задачи:

Изучение научных работ о состоянии теории в выбранной области. На данный момент существует немало подходов и схем для решения этой задачи, что свидетельствует о необходимости обзора существующих алгоритмов, выбора критериев для сравнения и анализа их достоинств и недостатков.   

Выбор необходимых структур данных и реализация алгоритма, выбранного на предыдущем этапе.

Реализация эмуляции взаимодействия клиента и сервера. Разработка интерфейса, позволяющего продемонстрировать работу реализованного алгоритма в контексте взаимодействия клиента и сервера.

Выбор тестовых данных и проведение экспериментов. 

Анализ полученных результатов.

В основной части работы в главе 1 описаны существующие методы поиска по зашифрованным данным, определены критерии и проведено сравнение данных методов. Во второй главе приведено описание работы выбранного алгоритма. В главе 3 перечислены особенности программной реализации: структура программы, используемые компоненты, варианты использования системы. В главе 4 описана методология проведения экспериментов, их результаты и анализ применимости разработки. В заключении приведены выводы по проделанной работе и возможные дальнейшие направления работы в этой области.



    

 




Обзор схем шифрования с возможностью поиска в зашифрованных данных

Существующие модели поиска по зашифрованным данным

Oblivious RAM

Одним из самых сильных с точки зрения безопасности является подход к поиску в зашифрованных данных с использованием, так называемой, забывчивой памяти (Oblivious RAM, ORAM). Концепция ORAM была предложена в 1996 году в работе Голдриха и Островски [18] и подразумевала собой устройство памяти, которое позволяет считывать и записывать информацию таким образом, что само устройство не знает, в каких областях памяти были произведены операции.

Подобная концепция реализуется с помощью протоколов для чтения и записи. Двусторонний протокол чтения позволяет пользователю получить -й элемент памяти в качестве выходного значения, в то время как входными параметрами являются номер элемента памяти  и секретный ключ. Серверу протокол чтения ничего не возвращает, получая на вход непосредственно саму забывчивую память, т.е. некую область памяти. В свою очередь, протокол записи получает от пользователя номер элемента памяти  и значение для записи , ничего ему не возвращая. Сервер же передает протоколу записи забывчивую память и получает назад ее обновленную версию.

Наличие подобных протоколов позволяет сконструировать решение для поиска по зашифрованным данным. Для этого требуется со стороны сервера наличие двух элементов забывчивой памяти ORAM1 и ORAM2. Первый хранит в себе зашифрованные документы, второй – структуру данных, поддерживающую операцию поиска, например, обратный индекс в зашифрованной форме. Таким образом, процедура поиска сводится к набору обращений к серверу через протокол чтения, а обновление коллекции файлов – через протокол записи.

Безопасность данного подхода  определяется непосредственно «забывчивостью» используемых структур. Подобное решение скрывает от сервера практически все, даже доступ к результатам поиска. Однако недостатком использования ORAM является относительная медленность поиска, что накладывает ограничения на размер хранимых коллекций и вычислительные ресурсы.    

Searchable symmetric encryption

Searchable symmetric encryption (SSE) – это подход, который с самого начала был ориентирован на проблему взаимодействия клиента с сервером, который не может считаться до конца доверенным. Впервые подход был описан в 2000 году в работе Сонга, Вагнера и Перрига [36]. В общем случае SSE может быть описан в виде следующих четырех процедур: инициализация, генерация поискового запроса, поиск в зашифрованных данных и расшифровка результата. На начальном этапе производится шифрование коллекции документов и генерация секретного ключа. Затем клиент на основе отдельного ключевого слова и секретного ключа формирует поисковый запрос, который передается серверу. Далее в процедуре поиска сервер с помощью поискового запроса и имеющейся коллекции зашифрованных файлов находит вхождения слов в документы коллекции. В качестве результата пользователю возвращаются зашифрованные файлы, которые далее расшифровываются с помощью секретного ключа.

Подход, описанный выше, дает лишь общее представление о функционировании алгоритма. Более подробные описания алгоритмов с используемыми криптопримитивами зависят от конкретной реализации. Однако в общем случае вышеописанный подход позволяет разрабатывать схемы, обеспечивающие соответствие удовлетворительному уровню безопасности и эффективности.     

Функциональное шифрование 

Формальное определение функционального шифрование было предложено в 2010 году в работе Боней, Сахай и Вотерс [7]. Такая криптосистема поддерживает особые ограниченные секретные ключи, которые позволяют их владельцу узнать лишь значение некоторой функции от зашифрованных данных и ничего более. В качестве примера в оригинальной статье [7] приводится зашифрованная программа, имея ограниченный секретный ключ к которой, можно узнать лишь выходное значение этой программы к конкретным входным данным. Однако еще в 2001 году Боней и Франклином была предложена схема Identity-based encryption (IBE) [8], которая использует вышеописанный принцип. IBE реализует криптосистему с открытым ключом. В рамках данной концепции существует главная пара ключей (master private key, master public key) и набор отдельных секретных ключей, каждый из которых формируется н основе главного закрытого ключа и некоторого идентификатора.  С помощью главного открытого ключа сообщения шифруются, а с помощью отдельных секретных ключей вычисляется некоторая функция от идентификатора и зашифрованного сообщения.

Идея использования IBE для поиска по зашифрованным данным была предложена в 2004 году [9]. Эта идея заключается в использовании отдельных ключевых слов, содержащихся в документе, в качестве идентификаторов для секретных ключей. Шифрование производится также на основе ключевого слова в качестве идентификатора. В данном случае удаленный компьютер хранит набор шифров, каждый из которых соответствует отдельному слову в файле. С помощью секретного ключа, выработанного с помощью ключевого слова в качестве идентификатора, сервер может узнать о принадлежности слова отдельному документу.

Недостатком этой схемы является то, что нотация IBE не гарантирует, что шифр скрывает информацию об идентификаторе. Тем не менее, эта проблема решаема путем построения схем шифрования на основе IBE, соответствующих данной задаче. Более серьезным недостатком является медленность работы алгоритма поиска, обусловленная тем, что требуется расшифровать все зашифрованные элементы, соответствующие паре документ – слово. Кроме того, использование криптосистемы с открытым ключом дает возможность удаленному компьютеру самостоятельно сгенерировать шифры с помощью главного открытого ключа и определенного словаря и ждать, пока полученный от пользователя ключ «подойдет» к одному из сгенерированных шифров.        

Шифрование, сохраняющее свойства (Property-preserving encryption)

Property-preserving encryption (PPE) - это криптосистема, сохраняющая некоторые свойства оригинального сообщения после шифрования. Примером такой системы является детерминированное шифрование, особенностью которого является генерация определенного шифра для заданных  ключа и оригинального сообщения. Таким образом, совпадение шифров свидетельствует о том, что оригинальные зашифрованные сообщения были идентичны. Другим примерами PPE являются шифрование, сохраняющее порядок (Order preserving encryption) [6]. Данная криптосистема позволяет шифровать оригинальные сообщения  и  ), таким образом, что их шифры, соответственно и , сохраняют их взаимное расположение:  .

Применительно к поиску по зашифрованным данным PPE на примере детерминированного шифрования используется следующим образом. Удаленный компьютер хранит соответствие между документами коллекции и зашифрованными словами, содержащимися в них. Поисковый запрос приходит на сервер в виде зашифрованного ключевого слова. Далее происходит поиск вхождений ключевого слова по всем документам коллекции на удаленном компьютере.

Недостатком такого подхода является линейное по отношению к размеру коллекции зашифрованных файлов время выполнения. Другими словами, для того чтобы найти все вхождения ключевого слова, требуется проверить все слова из коллекции файлов. Однако это может быть исправлено хранением детерминированных шифров с помощью структур данных, поддерживающих быстрый поиск (binary search tree). Более существенными недостатками этого подхода являются некоторые аспекты безопасности. Детерминированность шифров слов позволяет, с одной стороны, наблюдать вхождений одинаковых слов в документы, а с другой – отслеживать повторяемость в поисковых запросах.

Полностью гомоморфное шифрование

Термин «гомоморфное шифрование» впервые был сформулирован в 1978 Рональдом Ривестом, Леонардом Адлеманом и Майклом Дертузосом и подразумевал шифрование, которое позволяет производить операции над зашифрованными операндами без предварительной расшифровки [31]. В рамках этого термина выделяются частично гомоморфные системы и полностью гомоморфные системы. Первые поддерживают только одну операцию: сложение или умножение. Вторые, в свою очередь, гомоморфны относительно двух операций. 

Впервые полностью гомоморфная система была предложена в 2009 году Крейгом Джентри [16]. В своей работе Джентри в качестве одного из возможных применений гомоморфной системы предложил поиск по зашифрованным данным. В общем случае полностью гомоморфное шифрование может быть использовано для решения проблемы удаленных вычислений. Эта проблема может быть сформулирована следующим образом. Пользователь хочет вычислить значение некоторой функции  в точке , однако его компьютер не позволяет сделать этого, и вычисление  делегируется удаленному компьютеру, который не может считаться до конца доверенным. Таким образом, пользователь отправляет зашифрованное сообщение , а затем получает значение функции , расшифровывает его и получает значение . Поиск по зашифрованным данным является частным примером вышеописанной проблемы. В этом случае удаленный компьютер получает зашифрованный поисковый запрос и применяет алгоритм поиска для нахождения документов, содержащих эти слова.

Существенным недостатком такого подхода является линейное по отношению к размеру коллекции зашифрованных файлов время выполнения. Другими словами, для того чтобы найти все вхождения ключевого слова, требуется проверить все зашифрованные файлы.

Сравнение существующих моделей

Основные критерии для сравнения существующих подходов поиска по зашифрованным данным – это безопасность и временная и емкостная эффективность. Под безопасностью в задаче поиска по зашифрованным данным подразумевается, что зашифрованная коллекция файлов не раскрывает серверу информацию об оригинальных данных и что поисковые запросы, посылаемые на сервер, не раскрывают оригинальные ключевые слова.

Самым безопасным среди указанных подходов считается ORAM [24], поскольку он скрывает от сервера всю возможную информацию вплоть до результатов каждого отдельного поиска.  PPE, напротив, характеризуется неудовлетворительными показателями, поскольку в его основе лежит детерминированное шифрование, которое позволяет серверу наблюдать за повторяемостью вхождения отдельных слов в документы и запросов. Функциональное шифрование показывает несколько лучшие характеристики, поскольку основано на рандомизированном шифровании и не позволяет отслеживать закономерности в данных и запросах. Но ввиду того, что такой подход использует криптосистему с открытым ключом, он может подвергаться словарным атакам со стороны сервера.

Среди описанных моделей PPE показывает сублинейное время работы алгоритма , где  – размер коллекции документов, хранимых на сервере. Данный показатель достигается за счет использования специальных структур для хранения отдельных слов (binary search tree). Тем не менее, другие схемы (ORAM, функциональное шифрование, полностью гомоморфное шифрование) показывают линейное время поиска относительно размера коллекции, что связано с необходимостью в процедуре поиска проверять всё содержимое документов. Использование структур вроде обратного индекса в SSE лишает такой необходимости и позволяет свести сложность к линейной относительно , где  – подмножество коллекции документов , содержащих слово .

Немаловажным критерием также является практическая применимость той или иной схемы. Так, например, в ряде работ [11, 17, 24] отмечается, что концепция ORAM применима лишь к небольшим коллекциям документов и является скорее теоретической. Также полностью гомоморфное шифрование является в большей степени теоретическим. Таким образом, среди всех перечисленных моделей поиска по зашифрованным данным, многие являются слабо применимыми на практике ввиду низкого уровня безопасности и высоких требований к вычислительным ресурсам. В связи с этим, наиболее предпочтительной моделью видится SSE. Далее будут рассмотрены различные схемы, основанные на этой модели, и проведено их сравнение.

Особенности отдельных SSE схем

Нотации безопасности

Нотации безопасности являются важным элементом построения криптографических схем, поскольку они служат формализации и унификации критериев безопасности. В рамках SSE выделяются следующие нотации: CPA, CKA1, CKA2 и UC. Рассмотрим подробнее каждую из них.

CPA (Chosen-plaintext attack) – нотация, определяющая надежность схемы при атаке на основе подобранного открытого текста. Данная нотация широко распространена в криптографии и представляет собой следующие условия [1]. У злоумышленника есть доступ к шифрующей функции и возможность отправлять оригинальные входные данные и получать зашифрованные. В этом случае получаемые зашифрованные сообщения не должны выдавать информацию об оригинальном сообщении. В контексте поиска по зашифрованным данным, этот уровень безопасности применим к первому этапу SSE – шифрованию коллекции файлов пользователя.

CKA1 (non-adaptive chosen-keyword attack) – неадаптивная атака на основе выбранных ключевых слов. Впервые была предложена и формализована в работе Ченга и Миценмахера [11] и является нотацией, которая адресована непосредственно к SSE. Данная модель атаки предполагает, что сервер не использует историю пользовательских запросов и соответствующих им результатов. В рамках этих условий должны выполняться следующие требования. Зашифрованная поисковая структура и зашифрованные документы не должны позволять серверу узнать информацию об оригинальной коллекции, кроме числа файлов и их размера. В то же время, поисковый запрос и зашифрованная поисковая структура должны выдавать не более чем список идентификаторов соответствующих файлов. 

Данный уровень безопасности подходит лишь для случаев, когда поисковые запросы независимы друг от друга, т.е. в них нет некоторой повторяемости и, следовательно, анализ запросов и результатов не даст серверу возможности узнать о хранимых документах.

CKA2 (adaptive chosen-keyword attack) была разработана как более сильная нотация по сравнению со CKA1 [26]. Модель атаки предполагает, что у сервера есть возможность наблюдать и анализировать пользовательскую историю запросов и выдаваемых результатов. Данное предположение о поведении недоверенного сервера гораздо более реалистично, чем исходное положение в CKA1. 

UC (Universal composability) – нотация, предложенная в 2012 году Куросава и Охтаки [25]	 и являющаяся наиболее сильной на данный момент. Данная нотация предполагает безопасность данных в любом произвольном окружении.

Динамичность схемы SSE 

Под динамичностью в контексте поиска по зашифрованным данным подразумевается отсутствие необходимости полностью переписывать зашифрованную структуру (такой структурой может быть обратный индекс)  при добавлении или удалении документов коллекции. Подобное свойство схемы, безусловно, делает ее более применимой в реальной среде, где для пользователя подобные варианты использования являются ожидаемыми и необходимыми.

Сравнение существующих SSE схем

В табл. 1 приведены результаты сравнительного анализа некоторых существующих схем поиска по ключевым словам в зашифрованных данных. В табл. 1 использованы следующие обозначения:  – коллекция файлов,  – множество уникальных слов, содержащихся в коллекции,  – размер файловой коллекции,  – число файлов в коллекции,  – количество слов в множестве ,  – максимальное число файлов, соответствующих одному слову.

Таблица 1

Существующие схемы SSE



Наиболее строгая нотация безопасности из рассматриваемых схем – UC – соответствует схеме, описанной в работе Куросава и Охтаки [25] (данная нотация безопасности была введена именно в этой работе). Однако наряду со схемами, описанными в статьях Боней [7] и Картмола [14], время поиска линейно относительно числа файлов, что делает эту схему медленной. Кроме того, схема из работы [25] не поддерживает динамическое обновление зашифрованного индекса. Динамичное шифрование достигается в схемах [24, 26], кроме того, обе схемы соответствуют нотации безопасности CPA2. Однако размер хранимого зашифрованного индекса в схеме [26] значительно превышает этот показатель в схеме [24]. Таким образом, можно сделать вывод, что из всех представленных схем работа Камара [24] является наиболее приемлемой с точки зрения баланса между вычислительной эффективностью, функциональностью и безопасностью.




Описание схемы динамического SSE

Описание работы схемы в контексте взаимодействия клиента и сервера

Функционирование схемы SSE происходит следующим образом. У клиента есть набор файлов , которые состоят из слов множества  . С помощью секретного ключа  клиент шифрует файлы из коллекции , получая зашифрованную коллекцию , и генерирует зашифрованный индекс . Далее клиент посылает  и  на удаленный сервер. Для  процедуры поиска клиент генерирует поисковый токен  с использованием секретного ключа  и ключевого слова . Далее  посылается на удаленный сервер, и последний с помощью поискового токена и зашифрованного индекса   находит вхождения слова  в документы коллекции  и возвращает клиенту коллекцию файлов, содержащих это слово. Клиент получает зашифрованные файлы и расшифровывает их с помощью секретного ключа K.

Процедуры добавления и удаления файлов на сервере происходят аналогичным образом. Для того чтобы добавить файл  в зашифрованную коллекцию, пользователь генерирует токен для добавления файла  на основе добавляемого файла и секретного ключа . Далее  и зашифрованный файл для добавления  отправляются серверу. Сервер обновляет зашифрованный индекс  и коллекцию зашифрованных документов .  Для удаления документа  клиент также генерирует токен для удаления , посылает его серверу, а сервер в свою очередь удаляет соответствующий файл из зашифрованной коллекции и обновляет .

Описание схемы SSE

Схема, предложенная в статье Камара [24] состоит из девяти алгоритмов:

. Генерирует секретный ключ  на основе параметра безопасности .

. Генерирует зашифрованную коллекцию файлов  и зашифрованный индекс  на основе секретного ключа  и исходной коллекции файлов . 

. Генерирует поисковый токен  на основе секретного ключа  и ключевого слова .

. Генерирует токен  и зашифрованный файл  для добавления на основе секретного ключа и добавляемого файла .

. Генерирует токен для удаления  на основе секретного ключа  и удаляемого файла .

. Производит поиск на сервере в зашифрованной коллекции  документов, содержащих ключевое слово , и возвращает набор идентификаторов найденных документов . Поиск осуществляется с помощью зашифрованного индекса  и поискового токена . 

. Добавляет новый зашифрованный файл  на сервер с помощью токена  и обновляет зашифрованный индекс .

. Удаляет существующий зашифрованный файл на сервере с помощью токена  и зашифрованного индекса . Обновляет индекс  до .

. Расшифровывает полученный от сервера зашифрованный файл с помощью секретного ключа .

Компоненты алгоритма

Используемые криптопримитивы

Основой для функционирования схемы SSE является криптосистема с закрытым ключом, которая состоит из трех алгоритмов: . Алгоритм  генерирует секретный ключ на основе некоторого параметра безопасности. Алгоритм  с помощью секретного ключа шифрует документ. В свою очередь алгоритм  расшифровывает полученное зашифрованное сообщение с помощью закрытого ключа. Выбор  является частным вопросом реализации, однако рекомендуется выбирать схему, которая соответствует нотации безопасности CPA-secure [24].

Кроме  в SSE применяются псевдо случайные функции . Каждая из этих функций принимает на вход битовую строку и возвращает определенную битовую последовательность некоторой длины: . Псевдо-случайные функции используются в схеме в процессе шифрования индекса файловой коллекции.

Секретный ключ

Секретный ключ в схеме SSE представляет собой совокупность четырех элементов: три произвольные строки  и секретный ключ . Ключ  является криптографическим ключом, генерируемым с помощью алгоритма  из набора .  используется для шифрования оригинальной файловой коллекции клиента, генерации токенов  и   и расшифровки полученных документов. Ключи  используются для шифрования отдельных записей индекса, хранимого на сервере.

Зашифрованный индекс

Зашифрованный индекс – это структура, которая позволяет  серверу производить поиск по хранящимся на нем документам в зашифрованном виде, не зная, что они представляют собой. Зашифрованный индекс основан на инвертированном индексе [4], который представляет собой структуру данных, где каждому отдельному слову ставится в соответствие документы, в которых оно содержится. В схеме  SSE зашифрованный индекс представляет собой совокупность четырех структур данных: поисковый массив, поисковая таблица, массив удаления и таблица удаления.

Поисковый массив и поисковая таблица используются для выполнения операции поиска по ключевому слову в зашифрованных данных. Массив удаления и таблица удаления используются для поддержки операций добавления и удаления файлов в зашифрованную коллекцию. Поисковый массив и массив удаления хранят элементы, каждый из которых представляет собой пару соответствия слово – файл. Таким образом, в этих двух структурах данных образуются парные узлы – ячейка в поисковом массиве и ячейка в массиве удаления, которые содержат данные об одной и той же паре слово-файл. 

Работа алгоритма

Построение зашифрованного индекса

Построение зашифрованного индекса состоит из создания и заполнения каждого из его четырех элементов: поисковый массив, поисковая таблица, массив удаления и таблица удаления.

Построение поискового массива 

В основе поискового массива лежит обратный индекс, вычисляемый предварительно. Для каждого слова , где  – множество слов, содержащихся в файловой коллекции, создается список узлов . Узлы представляют собой список файлов, содержащих слово . Каждый узел, в свою очередь, представляет собой пару файл-слово и записывается в ячейку , выбранную случайным образом. Каждый узел хранит следующую информацию:



где  – уникальный идентификатор файла ,  – адрес следующего узла  в поисковом массиве , а  – генератор случайных чисел от ключа  и слова . В случае, если  является последним элементом списка ,  .

Построение поисковой таблицы 

Каждый список узлов  имеет соответствующую запись в поисковой таблице :



где  – генератор случайных чисел от ключа  и слова ,  – адрес первого узла списка  в ,  - адрес соответствующего парного узла в массиве удаления , а  – генератор случайных чисел от ключа  и слова . Таким образом,  хранит ссылку на первый элемент списка , а первый элемент, в свою очередь, содержит адрес на следующий элемент. Таким образом, прочитав запись в поисковой таблице, обладая ключами ,  и , можно получить доступ ко всем узлам .  

Построение массива удаления 

Также как и поисковый массив , массив удаления  состоит из элементов, представляющих собой соответствие файл-слово. Отличие заключается в том, что список узлов файл-слово строится для каждого файла. Иными словами, для каждого файла  строится список узлов , где  – число уникальных неповторяющихся слов в файле . Каждый узел  содержит в себе следующую информацию:



,

где   – адрес следующего узла  в ,  – адрес предыдущего узла  в  ,  – адрес следующего узла  в ,  – адрес парного узла в ,  – адрес узла в , предшествующего парному узлу в ,  – адрес узла в , следующего после парного узла в ,  – генератор случайных чисел от ключа  и слова ,  – генератор случайных чисел от ключа  и слова .

Построение таблицы удаления

Каждый список узлов  имеет соответствующую запись в таблице удаления :



Аналогично поисковой таблице ,  хранит ссылку на первый элемент списка , а первый элемент, в свою очередь, содержит адрес на следующий элемент. Таким образом, получив запись в таблице удаления, обладая ключами ,  и , можно прочитать все  узлы списка . 

Запись свободных ячеек

Когда запись данных о содержании файлов завершена, в зашифрованный индекс добавляется незашифрованная информация об оставшихся пустых элементах поискового и массива удаления. Данные свободные ячейки в дальнейшем используются для записи данных о добавленных файлах. Кроме того, после удаления файла ячейки, ранее занятые данными о нем, освобождаются и становятся доступными для записи новых данных.

Данные о свободных ячейках заносятся в   и . В  заносится незашифрованный список , каждый элемент которого содержит информацию о следующей ячейке в списке и об адресе в  парного свободного узла:



В  заносятся  данные о первом элементе списка свободных ячеек :



После того, как элементы зашифрованного массива сформированы, оставшиеся свободные ячейки   и  заполняются случайными строками. Вместе с вышеописанными действиями с помощью  шифруются оригинальные файлы. 

Поиск по ключевому слову

Когда клиент хочет отправить поисковый запрос со словом , он формирует поисковый токен . Поисковый токен состоит из трех элементов: . Затем токен отправляется серверу.

Сервер получает , разделяет его на . С помощью  в поисковой таблице находится запись о слове . Если такой не обнаружено, то сервер возвращает пустой список, что означает, что искомого слова нет в коллекции. Далее, вычисляя , сервер получает номер первой ячейки списка узлов  для слова  в поисковом массиве. Обращаясь к искомой ячейке, сервер прочитывает из нее идентификатор файла, и идет к следующей ячейке, повторяя до тех пор, пока не дойдет до конца списка узлов . Отдельную запись ячейки поискового массива сервер расшифровывает, вычисляя , где  – зашифрованная запись поискового массива.

Добавление файла в коллекцию

Генерация токена для добавления

Для добавления файла , который содержит множество уникальных слов , в коллекцию зашифрованных файлов пользователь генерирует токен для добавления . Токен для добавления файла содержит следующие данные:



где  и  – генераторы случайных чисел от ключей  и  и файла , а  содержит информацию об -м уникальном слове в (Номер формулы).  





где  ,  и  – генераторы случайных чисел от ключей ,  и  и слова ,  – уникальный идентификатор добавляемого файла и  – генераторы случайных чисел от ключа  и добавляемого файла .

После генерации токена клиент шифрует добавляемый файл  и отправляет его серверу вместе с .

Добавление файла

Получив токен для добавления, сервер разделяет его на составляющие: 



Далее для каждого  сервер производит следующие действия:

С помощью поисковой таблицы  вычисляет парный узел ( и ) для  первого свободного элемент в поисковом массиве :





Обновляет ссылку в поисковой таблице на следующий свободный узел:



Находит ссылку на  для слова :



Записывает новый элемент в , соответствующий слову   и добавляемому файлу :



Обновляет поисковую таблицу:



Обновляет парный узел :





Обновляет парный узел нового записанного элемента:



Если , то обновляет таблицу удаления:



Далее сервер добавляет зашифрованный файл  в коллекцию файлов, хранимую на сервере.

Удаление файла из коллекции

Генерация токена для удаления

Для удаления файла  из коллекции файлов, хранимой на сервере, пользователь генерирует токен для удаления :



где ,  и – генераторы случайных чисел на основе удаляемого файла  и ключей ,  и , а  – уникальный идентификатор файла .

Удаление файла

Получив токен для удаления, сервер разделяет его на составляющие:



Далее сервер ищет первый элемент списка :



Далее для каждого  сервер производит следующие действия:

Расшифровывает элемент  :





Удаляет , присваивая случайную строку элементу .

Находит адрес первого свободного узла :



Обновляет поисковую таблицу :



Делает ячейку парного узла  свободной:



 – узел, предшествующий парному узлу . Сервер обновляет указатель узла  на следующий элемент в :









 – узел, следующий за парным узлом . Сервер обновляет указатель узла  на предыдущий элемент в :





Присваивает 

Далее сервер удаляет из своего хранилища зашифрованный файл, который соответствует , полученному из токена, и удаляет  из . 





Программная реализация SSE

Язык и средства разработки

В качестве языка разработки программы был выбран Java. Этот выбор обоснован следующими факторами:

кроссплатформенность, позволяющая в дальнейшем применить имеющиеся теоретические наработки на практике в реальной системе удаленного хранения файлов;

стандартные структуры данных, поддерживаемые Java, позволяют реализовать элементы SSE без необходимости реализовывать собственные методы записи и хранения информации;

высокоуровневость языка и наличие множества встроенных библиотек, позволяющих уменьшить количество исходного кода и время разработки;

наличие встроенных криптографических библиотек с понятными и простыми для использования интерфейсами.

В качестве среды разработки был выбран инструмент NetBeans IDE 1.7.3, являющийся наиболее актуальной версией программы на момент написания работы. Основным преимуществом данной среды является поддержка визуальных средств разработки графического интерфейса, значительно сокращающих время создания GUI.  

Структура программы

Классы, из которых состоит программа, условно можно разделить на три группы. Первая группа классов – классы, реализующие графический интерфейс приложения. Вторая группа – классы, осуществляющие индексирование файловой коллекции. И третья группа – классы, реализующие алгоритм динамического симметричного шифрования с возможностью поиска по зашифрованным данным. В табл. 2 указаны классы программы с разделением по группам.

Таблица 2

Классы программы



ClientForm.java – класс, предназначенный для отображения графического пользовательского интерфейса. С помощью этого класса отображается форма, представляющая собой клиентскую сторону взаимодействия клиента и сервера в рамках облачного сервиса. Форма содержит функциональные вкладки (JTabbedPane), каждая из которых содержит элементы управления. Окно включает следующие вкладки: Шифрование, Поиск, Модификация и О программе. ClientForm является главным классом программы и содержит объект класса ServerForm в качестве закрытого поля класса, что позволяет запускать два окна при открытии программы.

ServerForm.java – класс, предназначенный для отображения графического пользовательского интерфейса. С помощью этого класса отображается форма, представляющая собой серверную сторону взаимодействия клиента и сервера в рамках облачного сервиса. Данная форма отображает текущую активность сервера в виде статусов, отображаемых в текстовой области (JTextArea). Форма также позволяет пользователю просмотреть файлы, находящиеся на серверной стороне. Список таких файлов доступен пользователю для просмотра в форме EncryptedFilesForm, запускаемой текущей ServerForm.

EncryptedFilesForm.java – класс, предназначенный для отображение списка зашифрованных файлов, хранящихся на серверной стороне. Окно запускается классом ServerForm. Форма содержит информацию о коллекции файлов: число файлов и общий размер. Таблица (JTable), отображает следующую информацию о каждом файле:

название файла;

расширение файла;

размер файла.

В то же время строки таблицы кликабельны и по нажатии открывают зашифрованный файл, хранящийся на серверной стороне. 

SearchResultsForm.java – класс, предназначенный для отображение результатов поиска, представленных в виде списка файлов. Открывается классом ClientForm по завершении процесса поиска файлов. Форма содержит информацию о коллекции файлов: число файлов и общий размер. Таблица (JTable), отображает следующую информацию о каждом файле:

название файла;

расширение файла;

размер файла.

Строки таблицы кликабельны и по нажатии открывают оригинальный файл, содержащий искомые ключевые слова.

Index.java – класс, осуществляющий процесс индексирования пользовательских файлов и хранящий в себе результат. Класс формирует и хранит следующие поисковые структуры данных: индекс и обратный индекс файловой коллекции. При создании экземпляра класса на вход конструктору подается коллекция пользовательских файлов. Далее из каждого файла извлекается содержимое, на основе которого строится индекс. Непосредственно за извлечение текста из каждого файла отвечает класс FileIndexer, вызываемый классом Index.     

FileIndexer.java – класс, состоящий из статических методов, каждый из которых отвечает за извлечение текста из определенного типа файлов. Класс поддерживает работу со следующими типами файлов:

текстовые файлы (*.txt);

pdf-файлы (*.pdf);

документы MS Word (doc, docx);

документы MS Excel (xls, xlsx);

документы MS PowerPoint (ppt, pptx);

аудио-файлы (*.mp3);

изображения (*.jpg);

видео (*.flv).

SSEClient.java – класс, содержащий реализацию методов SSE схемы, относящихся к действиям на клиентской стороне. Класс содержит в себе следующие методы схемы:

генерация секретного ключа;

шифрование пользовательской коллекции файлов;

построение зашифрованного индекса;

генерация поискового токена;

генерация токена для удаления файла;

генерация токена для добавления файла;

расшифровка файлов с помощью секретного ключа.

Создав объект класса SSEClient, пользователь получает возможность вызвать метод для шифрования своей файловой коллекции, предварительно создав секретный ключ. После этого, пользователь с помощью экземпляра класса может генерировать поисковые или иные токены, которые затем посылать на серверную сторону (класс SSEServer). 

Объект класса SSEClient содержит в качестве поля экземпляр класса EncryptedIndex, создаваемый внутри класса SSEClient, который содержит в себе информацию о зашифрованном индексе. 

SSEServer.java – класс, содержащий реализацию методов SSE схемы, относящихся к действиям на серверной стороне. Класс содержит в себе следующие методы схемы:

поиск по ключевому слову с помощью поискового токена;

добавление файла в зашифрованную коллекцию с помощью токена для добавления;

удаление файла из зашифрованной коллекции с помощью токена для удаления.

Конструктор класса получает на вход зашифрованный индекс, сгенерированный с помощью SSEClient. Далее класс может быть использован для операций поиска, добавления и удаления файлов с помощью токенов, предварительно сгенерированных с помощью экземпляра SSEClient.

EncryptedIndex.java – класс, хранящий в себе информацию о зашифрованном индексе. Экземпляр класса создается внутри класса SSEClient. Конструктор экземпляра класса получает на вход размер оригинального незашифрованного индекса. Объект класса используется при записи данных в зашифрованный индекс и поддерживает следующие операции:

добавление ячейки в поисковый массив и массив удаления;

добавление записи в поисковую таблицу и таблицу удаления;

добавление в поисковые массив и таблицу данных о свободном узле;

выдача случайного незанятого номера поискового массива и массива удаления;

заполнение поискового массива и массива удаления случайными строками.

Utils.java – вспомогательный класс, содержащий статические методы, используемые на всех этапах работы SSE схемы. Класс содержит следующие виды вспомогательных функций:

генерация случайных строк на основе входного значения;

генерация секретного криптографического ключа;

симметричное шифрование файла;

расшифровка файла;

базовые операции по работе с байтовыми и битовыми массивами.

Используемые компоненты

Криптографические примитивы

Одним из компонентов, применяемым в построении зашифрованного индекса, является генератор случайных чисел. В качестве его реализации используется класс SecureRandom [19] из стандартного пакета java.security [20]. SecureRandom принимает на вход название конкретного алгоритма генератора случайных чисел. В качестве такого алгоритма используется SHA1PRNG [22].

В качестве  схемы для SSE применяются средства Java Cryptography Architecture (JCA) [21]. JCA позволяет применять следующие алгоритмы симметричного шифрования [22]:

AES [27]

ARCFOUR [33]

Blowfish [34]

DES [28]

DESede [13]

RC2 [38]

RC5 [32]  

Среди этих алгоритмов для реализации  было выбрано AES шифрование. Данный выбор был обоснован тем, что алгоритм является стандартом шифрования, принятым Национальным институтом стандартов и технологий (The National Institute of Standards and Technology, NIST) [27]. Кроме того, алгоритм долгое время является наиболее популярным среди коммерческих и государственных организаций и показывает приемлемую криптостойкость [5].

Индексирование файлов

Основой для построения зашифрованного индекса является обратный индекс оригинальных незашифрованных документов. Для извлечения содержимого из файлов используется свободная библиотека Apache Tika [3]. С помощью библиотеки программа поддерживает работу со следующими типами данных: текстовые файлы, pdf-документы, документы MS Office, аудио-файлы, изображения и видео. В табл.3 представлена информация, извлекаемая из разных типов файлов.

Таблица 3

Данные для индексирования

Реализация алгоритма SSE и структуры данных

Зашифрованный индекс

В табл. 4 перечислены структуры данных, с помощью которых реализованы основные элементы динамической схемы SSE.

Таблица 4

Структуры данных



Одной из особенностей поискового массива и массива удаления является наличие нескольких типов ячеек:

ячейки, непосредственно хранящие зашифрованные данные о содержимом индекса;

свободные ячейки, которые могут быть использованы для записи данных о добавляемых файлах;

ячейки, заполненные случайными строками.

Принципиальным вопросом для реализации и оценки производительности программы является соотношение количества таких ячеек. Для реализации было выбрано соотношение . Таким образом, число генерируемых свободных ячеек равно числу пар файл-слово в поисковом массиве и массиве удаления. Это приводит к тому, что добавляемые файлы не должны содержать пар файл-слово больше, чем в первоначально зашифрованной коллекции. Подобное ограничение  соответствует типичному сценарию использования удаленного хранения файлов, где у пользователя есть лимит хранения файлов. В реальном облачном решении количество свободных ячеек и количество ячеек для хранения данных может регулироваться тарифным планом пользователя. 

Поиск словосочетаний

Модель поиска, описанная в статье [24], предполагает поиск по одному ключевому слову. Однако, эта модель была расширена до поиска по словосочетаниям. Поисковому запросу, состоящему из нескольких слов, ставится в соответствие набор поисковых токенов по каждому из слов:  



По каждому сгенерированному токену серверной стороной производится поиск вхождений слов в документы. Далее находится токен, которому соответствует наименьшее количество вхождений слова в документы. После для всех остальных токенов проверяется вхождение в документы, соответствующие минимальному набору. В итоге сервером возвращаются идентификаторы файлов, каждый из которых содержит все слова словосочетания .

Данная логика поискового запроса соответствует логическому оператору AND. Иными словами логический запрос, эквивалентный вводимому пользователем словосочетанию , выглядит следующим образом:



Варианты использования программы

В основу логики приложения, эмулирующего взаимодействие пользователя и удаленного сервера, легло явное разделение ролей акторов Клиент и Сервер. Для реализации подобного представления используются отдельные директории для клиентской и серверной сторон. На рис. 1 показана схема эмуляции Клиента и Сервера. Клиентская сторона представляется с помощью набора пользовательских файлов и папки для сохранения результатов поиска. Серверная сторона представляется с помощью директории для хранения зашифрованных файлов. Таким образом, в рамках реализованной программы Клиент предоставляет директории с файлами, которые будут зашифрованы. Зашифрованные файлы хранятся в серверной директории. Результаты поиска, которые являются расшифрованными файлами из серверной директории, сохраняются в клиентскую директорию для сохранения результатов. 



Рисунок 1. Клиентская и серверная директории

На рис. 2 представлена диаграмма вариантов использования. Данные варианты использования легли в основу пользовательского интерфейса и программной логики и подробно описаны далее. Описание приведено в соответствии с рекомендациями по документированию вариантов использования [40].



Рисунок 2. Варианты использования программы

1. Зашифровать файлы

Акторы: Клиент.

Описание. Пользователь выбирает список файлов, которые хочет зашифровать. Клиент генерирует секретный ключ, зашифровывает файлы и копирует их в папку сервера.

Предварительные условия: программа запущена.

Выходные условия: файлы пользователя зашифрованы и находятся в директории сервера, зашифрованный индекс сформирован.

Сценарий

Клиент выбирает серверную директорию

Клиент предоставляет директории файлов, которые собирается зашифровать.

Клиент генерирует секретный ключ

Клиент строит зашифрованный индекс выбранной файловой коллекции

Клиент шифрует файловую коллекцию

Клиент сохраняет зашифрованные файлы в серверной директории 

2. Поиск keyword

Акторы: Клиент и Сервер.

Описание: Клиент вводит ключевое слово для поиска и получает список файлов, удовлетворяющих поисковому запросу.

Предварительные условия: Файлы зашифрованы и сформирован зашифрованный индекс (Вариант использования 1).

Выходные условия: В папку Клиента для сохранения результатов скопированы расшифрованные файлы, отвечающие условию поиска. Если файлов, удовлетворяющих поисковому запросу, не найдено, выведено сообщение о том, что файлы не найдены.

Сценарий

Клиент выбирает директорию для сохранения результатов

Клиент вводит фразу для поиска

Клиент формирует поисковый токен для введенного слова

Сервер получает поисковый токен и осуществляет процедуру поиска

Сервер возвращает Клиенту набор зашифрованных файлов, удовлетворяющих поисковому запросу или сообщение о том, что таковых файлов не найдено

Если файлы по запросу найдены, Клиент расшифровывает полученные файлы и сохраняет их в директорию для сохранения результатов

3. Добавить файл

Акторы: Клиент и Сервер.

Описание: Клиент добавляет файл в зашифрованную коллекцию

Предварительные условия: Файлы зашифрованы и сформирован зашифрованный индекс (Вариант использования 1).

Выходные условия: добавляемый файл зашифрован и добавлен в серверную директорию, зашифрованный индекс обновлен.

Сценарий

Клиент выбирает файл для добавления

Клиент генерирует токен для добавления файла

Клиент зашифровывает файл

Сервер получает токен

Сервер обновляет зашифрованный индекс. Если добавляемый файл уже существует в коллекции, то возвращает Клиенту сообщение и оставляет индекс неизмененным

Зашифрованный файл сохраняется в серверной директории 

4. Удалить файл

Акторы: Клиент и Сервер.

Описание: Клиент удаляет файл из зашифрованной коллекции

Предварительные условия: Файлы зашифрованы и сформирован зашифрованный индекс (Вариант использования 1)

Выходные условия: файл удален из серверной директории, зашифрованный индекс удален.

Сценарий

Клиент выбирает файл для удаления

Клиент генерирует токен для удаления файла

Сервер получает токен

Сервер проверяет, есть ли удаляемый файл в коллекции. Если файла нет, то возвращает сообщение Клиенту о том, что такого файла не существует

Сервер обновляет зашифрованный индекс

Сервер удаляет зашифрованный файл из коллекции

Интерфейс программы

Интерфейс программы состоит из четырех окно: клиентская сторона, серверная сторона, окно с зашифрованными файлами и окно с результатами поиска. При запуске программы открываются два окна: клиентская сторона и серверная сторона (рис. 3).



Рисунок 3. Стартовое окно программы

В клиентском окне на вкладке Шифрование пользователь выбирает серверную директорию и коллекцию файлов для шифрования (рис. 4). С помощью кнопок Добавить и Удалить пользователь формирует список файлов для шифрования.  С помощью кнопки Зашифровать файлы пользователь шифрует коллекцию и строит индекс. Серверная сторона отображает текущую активность сервера (рис. 4).



Рисунок 4. Процесс шифрования файлов

Кнопка Просмотреть файлы, расположенная на серверной форме открывает окно просмотра зашифрованных файлов (рис. 5). В этом окне отображается список файлов, находящихся в серверной директории. Нажатие на строку таблицы открывает соответствующий файл, представляющий шифр оригинального документа.



Рисунок 5. Окно с зашифрованными файлами

В клиентском окне на вкладке Поиск пользователь вводит клиентскую директорию для сохранения результатов и ключевую фразу для поиска (рис. 6). 



Рисунок 6. Вкладка поиска

В результате пользователь получает список найденных файлов, расшифрованных на клиентской стороне (рис. 7), либо сообщение о том, что файлы не найдены (рис. 8). 



Рисунок 7. Окно с результатами поиска



Рисунок 8. Сообщение для пользователя

На вкладке Модификация клиентского окна пользователь может выбрать файл для добавления в зашифрованную коллекцию или для удаления (рис. 9).



Рисунок 9. Вкладка для добавления и удаления файлов

В течение всей работы программы серверное окно отображает активность сервера (рис. 10).



Рисунок 10. Активность сервера


Методология оценки и эксперименты

Особенности оценки схемы

Частью разработки программы является оценка ее быстродействия. В данном случае был оценен каждый элемент SSE схемы: шифрование, генерация токенов, поиск, добавление и удаление.

На проведение оценки временных затрат на шифрование влияют внутренние особенности этого процесса. Алгоритм шифрования состоит из следующих процессов: чтение файлов, составление индекса оригинальных файлов, генерация секретного ключа, построение зашифрованного индекса и симметричное шифрование файлов. Из всех вышеперечисленных процессов в рамках SSE схемы наиболее важным предметом разработки является построение зашифрованного индекса. Несмотря на то, что индексирование содержимого оригинальных файлов является первым и обязательным шагом всей процедуры, разработка его эффективных схем не является предметом данной работы. Это связано с тем, что подобный вопрос далек от проблем криптографии. Кроме того, быстродействие этого этапа зависит от используемых технологий. Для реальных облачных решений для данной задачи потребовалась бы отдельная система, индексирующая файлы, например, Apache Lucene [2]. Задачи, являющиеся частью , такие как шифрование, расшифровка и генерация секретного ключа, также не являются основным предметом данной работы. Во-первых, они играют вспомогательную роль для SSE и, во-вторых, их быстродействие так же, как и в случае с индексированием, зависит от конкретного алгоритма, выбор которого в большей степени лежит за пределами SSE.

Таким образом, оценка реализованного алгоритма учитывает лишь время, которое занимает генерация зашифрованного индекса. По аналогии с шифрованием операции поиска и добавления файлов оцениваются без учета времени, потраченного на зашифровку, расшифровку и индексирования файла.

Еще один аспект, которые учитывается при тестировании разработанной схемы, – это доступ к используемым данным. Поскольку в оценивании временных затрат не учитывается время на индексирование и симметричное шифрование, на получаемые значения не влияет стоимость операций чтения и записи файлов. Для того чтобы подобные операции не влияли на работу серверной стороны схемы, зашифрованный индекс не сохраняется на жесткий диск, а находится в памяти и передается серверной стороне как параметр конструктора. 

Эксперименты проводились на персональном компьютере с процессором Intel Core i7-3517U с частотой 2.4 ГГц и оперативной памятью 4 Гб. 

Формирование тестовых данных

Для проведения экспериментов для оценки построения зашифрованного индекса в качестве тестовых примеров были использованы текстовые файлы, документы (pdf –файлы, документы MS Office) и медиа файлы (изображения, аудио и видео). Основное отличие этих типов файлов – это количество уникальных слов на единицу памяти. Иными словами, текстовые файлы состоят только лишь из слов, в то время как документы помимо этого содержат форматирование и, возможно, графические элементы. Медиа файлы имеют большой размер по сравнению с текстом и документами, однако они содержат ограниченное число индексируемой информации. По этой причине для вычисления быстродействия других частей алгоритма помимо построения зашифрованного индекса используются текстовые файлы. Вычисление времени работы алгоритмов поиска, добавления и удаления файлов производится с помощью текстовых файлов различного размера и типа.

Для проведения экспериментов с алгоритмом генерации зашифрованного индекса используются файловые коллекции разных размеров. Коллекции текстовых файлов и документов варьируют в размере от 1 до 8 мегабайт, коллекции медиа файлов – от 100 до 500 мегабайт. 

Для  тестирования процедуры поиска сначала зашифровывается файловая коллекция, состоящая из текстовых файлов. Далее происходит поиск по разным типам запросов. Ввиду особенностей реализации процедуры поиска время работы зависит от количества файлов, относящихся к искомому слову. Таким образом, чтобы прочитать и расшифровать записи о файлах, требуется тем больше времени, чем больше список файлов у искомого слова в зашифрованном индексе. В связи с этим для оценки времени поиска поиск производится по слову, которого нет в коллекции, редко встречаемому слову (вхождение в один файл) и по частоупотребляемому (вхождение во все файлы). Кроме того, учитывается длина запроса: два слова, три слова или четыре слова. Время работы алгоритма генерации поисковых токенов зависит, прежде всего, от количества слов в запросе, поэтому проверяются запросы по два, три и четыре слова.

Для тестирования процедуры добавления файлов используются текстовые файлы разных размеров: 1 килобайт, 10 килобайт, 100 килобайт и 1 мегабайт. Как уже было сказано выше операция индексирования оригинальных документов не учитывается при оценивании, но полученный индекс далее используется для обновления существующего индекса, следовательно, размер добавляемого файла влияет на производительность алгоритма. Кроме того, на работу алгоритма добавления влияет структура добавляемого файла, а именно наличие в добавляемом файле слов, которые уже имеются в коллекции. Для генерации токена добавления последний фактор не существенен, поскольку генерация происходит без участия готового зашифрованного индекса. В связи с этим генерация токена происходит только с файлами разного размера:  1 килобайт, 10 килобайт, 100 килобайт и 1 мегабайт.

Оценивание операций удаления файла и генерации токена для удаления имеют те же особенности, что и операции добавления и генерации токена для добавления. Эксперименты с операцией удаления проводятся с теми же тестовыми данными, что и операция добавления.

Результаты экспериментов

В табл. 5 показаны результаты экспериментов для алгоритма построения зашифрованного индекса. Представлены два ряда данных: длительность процесса построения зашифрованного индекса файлов (Индекс) и длительность процесса шифрования файлов (Шифрование).

Таблица 5

Построение зашифрованного индекса



На рис. 11 показано соотношение времени на построение зашифрованного индекса и на шифрование для трех типов данных. Наиболее длительной является операция с набором медиа файлов в 500 мегабайт (30 секунд). Однако построение зашифрованного индекса в данном случае занимает порядка 140 мс, а шифрование файлов длится все оставшееся время. Вторая по длительности операция – шифрования восьми мегабайт текстовых файлов. В этом случае шифрование файлов составляет не более 13% от всего времени работы алгоритма.  Наборы pdf-файлов и документов MS Office шифруются не более 10 секунд.

В табл. 6 указаны результаты экспериментов для алгоритма поиска. Наиболее длительный алгоритм работает порядка 1 мс (поиск частоупотребляемого слова), наиболее быстрый – поиск в зашифрованном индексе слова, которого нет в коллекции – 8 мкс. В табл. 7 находятся результаты оценки алгоритма генерации поискового токена. Наиболее длительная операция – это генерация поискового токена для словосочетания из четырех слов.



Рисунок 11. Время шифрования разных типов данных

Таблица 6

Поиск в зашифрованной коллекции



Таблица 7

Генерация поискового токена



В табл. 8 указаны результаты оценки операции добавления файла в зашифрованную коллекцию. Наиболее длительная операция – добавление текстового файла размером в 1 мегабайт (72 мс). Как уже было сказано выше, на длительность операции влияет не только размер добавляемого файла, но и его структура. Под «новым файлом» подразумевается текстовый файл, который содержит слова, которых еще нет в индексе. В то же время «похожий файл» состоит из слов, большинство из которых уже есть в индексе. Как видно из табл. 8 добавление нового файла занимает несколько больше времени. Генерация токена для добавления, как видно из табл. 9, занимает больше времени, чем поиск. Дольше других операций длится операция генерации токена для файла размером 1 мегабайт -  4.6 секунд.

Таблица 8

Добавление файла в зашифрованную коллекцию



Таблица 9

Генерация токена для добавления



Табл. 10 отражает длительность операции удаления. В зависимости от размера (от 1 килобайта до 1 мегабайта) время удаления файла колеблется от 4 до 200 мс. Как и в случае с добавлением файла, удаление нового файла длится дольше, чем удаление похожего файла. Под новым файлом подразумевается файл, содержимое которого не повторяется в остальных документах коллекции. Например, новый файл – это текстовый документа на русском языке в коллекции из англоязычных документов. Похожий файл – это файл, содержимое которого пересекается с содержимым документов коллекции. Генерация токена для удаления, как видно из табл. 11 длится не более 100 мкс.

Таблица 10

Удаление файла из зашифрованной коллекции



Таблица 11

Генерация токена для удаления



Анализ полученных результатов

На первый взгляд может показаться, что скорость, с которой происходит первоначальное шифрование пользовательской коллекции, недостаточна для практического применения в современных системах: шифрование набора файлов размером в 8 мегабайт длится почти 25 секунд, а набор файлов размером в 1 Гб будет зашифрован не менее, чем за час. Однако, стоит заметить, что речь идет о файлах формата txt, которые содержат только индексируемый текст и ничего более. Как правило, пользователь на своем персональном компьютере хранит множество файлов, формат которых отличается от txt. Как видно из рис. 11, подобные файловые коллекции аналогичного размера шифруются гораздо быстрее. Кроме того, если речь идет не о пользователе персонального компьютера, а о корпоративной информационной системе, то время шифрования может быть уменьшено за счет использования больших вычислительных мощностей, чем те, с помощью которых были проведены данные эксперименты.

Остальные операции схемы проходят значительно быстрее. Так, например, поиск по зашифрованным файлам при работе с тестовыми примерами не превышал 1мс. Работа с функцией добавления и удаления файлов не превышает 0.2 сек, а генерация токена для добавления достигает 4.6 сек при работе с текстовым файлом размером в 1 мегабайт. По аналогии с шифрованием, при использовании вычислительного оборудования корпоративной информационной системы, ресурсы которого превышают ресурсы компьютера, на котором производились эксперименты, вышеуказанные временные показатели могут быть улучшены. Подводя итог всему сказанному, следует отметить, что генерация зашифрованного индекса и шифрование файловой коллекции – самый длительный этап во всей схеме, последующие операции по работе со сформированными данными для хранения на серверной стороне выполняются гораздо быстрее.  




Заключение

По мере того, как становится всё больше скептиков относительно хранения файлов в интернете, и появляются новые облачные сервисы, вопрос безопасного хранения файлов в сети становится актуальным. Возможным решением является идея шифрования файлов на клиентской стороне, однако недостатки современных программных продуктов убеждают в необходимости изучения и разработки схем эффективного взаимодействия пользователя и удаленного сервера. Кроме того, следует упомянуть, что подобные схемы имеют серьезный потенциал развития внутри корпоративных облачных решений.

Подводя итог проделанной работы, следует отметить, что цели, сформулированные во введении, достигнуты. Были изучены современные подходы поиска по зашифрованным данным, были сформулированы критерии их сравнения и проведен сравнительный анализ. Далее были выбраны компоненты для программы, и была реализована схема симметричного шифрования с возможностью поиска. Кроме того, был спроектирован графический интерфейс для визуализации взаимодействия клиента и сервера в облачной среде, который наглядно иллюстрирует возможности алгоритма. В итоге было проведена оценка эффективности реализованного алгоритма и проанализирована применимость в реальном облаке.

Оценка разработанной программы показала, что она может быть использована для работы в реальном облаке. Программа позволяет пользователю шифровать файловую коллекцию, которая затем посылается на удаленный сервер. Далее пользователь может производить поиск по ключевым словам, добавлять и удалять файлы, обновляя зашифрованный индекс за приемлемое время.

В качестве направлений для дальнейшей работы и усовершенствования можно выделить два основных направления. Во-первых, это, безусловно, применение в реальной облачной системе хранения файлов. Данное направление работы должно включать в себя реализацию особенностей хранения данных в сети, файловых операций, взаимодействия клиента и сервера, индексирования больших коллекций размеров. Во-вторых, в качестве перспективного направления можно выделить улучшение поисковых свойств алгоритма, в частности,  поддержку логических запросов.  

   


Список использованных источников

Anderson, R. Security Engineering: A Guide to Building Dependable Distributed Systems / R. Anderson. - New York: John Wiley & Sons, 2001.  -640 с.

Apache Software Foundation. Apache Lucene [Электронный ресурс]. - Режим доступа: http://lucene.apache.org/ (дата обращения 21.05.14).

Apache Software Foundation. Apache Tika [Электронный ресурс]. - Режим доступа: http://tika.apache.org/ (дата обращения 21.05.14).

Baeza-Yates, R. Modern Information Retrieval / R. Baeza-Yates, B. Ribeiro-Neto. - New York: ACM Press, 1999. - 513 с.

Biryukov, A. Related-Key Cryptanalysis of the Full AES-192 and AES-256 / A. Biryukov, D. Khovratovich // ASIACRYPT '09 Proceedings of the 15th International Conference on the Theory and Application of Cryptology and Information Security: Advances in Cryptology. -2009. -C. 1-18.

Boldyreva, A. Order-Preserving Symmetric Encryption / A. Boldyreva, N. Chenette, Y. Lee, A. O'Neill // EUROCRYPT '09 Proceedings of the 28th Annual International Conference on Advances in Cryptology. -2012. -С. 224-241.

Boneh, D.  Functional Encryption: Definitions and Challenges / D. Boneh, A. Sahai, B. Waters // TCC'11 Proceedings of the 8th conference on Theory of cryptography. -2011. -C. 253-273.

Boneh, D.  Identity-Based Encryption from the Weil Pairing / D. Boneh, M. Franklin // SIAM Journal on Computing -2003. -N 3. -C. 586-615.

Boneh, D. Public Key Encryption with Keyword Search / D. Boneh , G. D. Crescenzo , R. Ostrovsky , G. Persiano // IACR Cryptology ePrint Archive -2003.

Boxcryptor. ТЕХНИЧЕСКИЙ ОБЗОР [Электронный ресурс]. - Режим доступа: https://www.boxcryptor.com/ru/%D1%82%D0%B5%D1%85%D0%BD%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9-%D0%BE%D0%B1%D0%B7%D0%BE%D1%80 (дата обращения 21.05.14).

Chang ,Y.  Privacy preserving keyword searches on remote encrypted data / Y. Chang, M. Mitzenmacher // ACNS'05 Proceedings of the Third international conference on Applied Cryptography and Network Security. -2005. -С. 442-455.

Ciphercloud. Technology Overview [Электронный ресурс]. - Режим доступа: http://www.ciphercloud.com/technologies/technology-overview/ (дата обращения 21.05.14).

Cryptography World. DES [Электронный ресурс]. - Режим доступа: http://www.cryptographyworld.com/des.htm (дата обращения 21.05.14).

Curtmola, R. Searchable symmetric encryption: improved definitions and efficient constructions / R. Curtmola, J. Garay, S. Kamara, R. Ostrovsky // CCS '06 Proceedings of the 13th ACM conference on Computer and communications security. -2006. С. 79-88.

Dropbox. Your stuff is safe with Dropbox [Электронный ресурс]. - Режим доступа: https://www.dropbox.com/security#protection (дата обращения 21.05.14). 

Gentry, C. Fully homomorphic encryption using ideal lattices / C. Gentry; под ред.  М. Mitzenmacher // STOC. -2009. -С. 169-178.

Goh, E.-J. Secure indexes. / E.-J. Goh // IACR Cryptology ePrint Archive -2003. -C. 216.

Goldreich, O. Software protection and simulation on oblivious RAMs / O. Goldreich, R. Ostrovsky // Journal of the ACM - 1996. - N 3. - С. 431-473.

Java Platform Standard Ed. 7. Class SecureRandom [Электронный ресурс]. - Режим доступа: http://docs.oracle.com/javase/7/docs/api/java/security/SecureRandom.html/ (дата обращения 21.05.14).

Java Platform Standard Ed. 7. Package java.security [Электронный ресурс]. - Режим доступа: http://docs.oracle.com/javase/7/docs/api/java/security/package-summary.html/ (дата обращения 21.05.14).

Java SE Documentation. Java Cryptography Architecture (JCA) Reference Guide [Электронный ресурс]. -Режим доступа:  http://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html (дата обращения 21.05.14).

Java SE Documentation. Java Cryptography Architecture Standard Algorithm Name Documentation [Электронный ресурс]. -Режим доступа: http://docs.oracle.com/javase/7/docs/technotes/guides/security/StandardNames.html/ (дата обращения 21.05.14).

Kamara, S. Cryptographic Cloud Storage / S. Kamara,  K. Lauter // FC'10 Proceedings of The 14th international conference on Financial cryptography and data security. -2010.

Kamara, S. Dynamic searchable symmetric encryption / S. Kamara, C. Papamanthou, T. Roeder // CCS '12 Proceedings of the 2012 ACM conference on Computer and communications security. - 2012. -С. 965-976.

Kurosawa, K. UC-Secure Searchable Symmetric Encryption / K. Kurosawa, Y. Ohtaki //  Proceedings from FC'12: The 16th international conference on Financial cryptography and data security. -2012. -С. 285-298.

Liesdonk, P. Computationally Efficient Searchable Symmetric Encryption / P. Liesdonk, S. Sedghi, J. Doumen, P. Hartel, W. Jonker // SDM 2010 7th VLDB Workshop. -2010. С. 87-100.

National Institute of Standards and Technology. Announcing the ADVANCED ENCRYPTION STANDARD (AES) [Электронный ресурс]. - Режим доступа: http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf (дата обращения 21.05.14).

National Institute of Standards and Technology. DATA ENCRYPTION STANDARD (DES) [Электронный ресурс]. - Режим доступа: http://csrc.nist.gov/publications/fips/fips46-3/fips46-3.pdf (дата обращения 21.05.14). 

Perspecsys. Security and Usability [Электронный ресурс]. - Режим доступа: http://perspecsys.com/how-we-help/cloud-usability/security-usability/ (дата обращения 21.05.14).

Ponemon Institute. Encryption in the Cloud: Who is responsible for data protection in the cloud? [Электронный ресурс]. - Режим доступа: http://www.ponemon.org/local/upload/file/Encryption_in_the _Cloud%20FINAL_6_2.pdf (дата обращения 20.01.14).

Rivest, R.L. On Data Banks and Privacy Homomorphisms / R. L. Rivest, L. Adleman, M. L. Dertouzos // Foundations of Secure Computation -1978. -С. 169-179.

 Rivest, R. L. The RC5 Encryption Algorithm / R. L. Rivest - Springer Berlin Heidelberg, 1995. - 375 c.

Schneier, B. Applied Cryptography / B. Schneier - New York: John Wiley & Sons, 1995, -784 с.

Schneier on Security. The Blowfish Encryption Algorithm [Электронный ресурс]. - Режим доступа: https://www.schneier.com/blowfish.html/ (дата обращения 21.05.14).

 SecretSync. Safely Syncs Your Confidential Files [Электронный ресурс]. - Режим доступа: www.truecrypt.org/ (дата обращения 21.05.14).

Song, D. Practical Techniques for Searches on Encrypted Data / D. Song, D. Wagner, A. Perrig // SP '00 Proceedings of the 2000 IEEE Symposium on Security and Privacy. -2000. -C. 44-55.

Storage Newsletter. How Businesses Are and Will Use Cloud Storage [Электронный ресурс]. - Режим доступа: http://www.storagenewsletter.com/rubriques/market-reportsresearch/use-cloud-storage-twinstrata (дата обращения 21.05.14).

The Internet Engineering Task Force. A Description of the RC2 Encryption Algorithm [Электронный ресурс]. - Режим доступа: http://tools.ietf.org/html/rfc2268 (дата обращения 21.05.14).

TrueCrypt. TrueCrypt - Free Open-Source On-The-Fly Disk Encryption. [Электронный ресурс]. - Режим доступа: http://getsecretsync.appspot.com/download/lifehacker/ (дата обращения 21.05.14).

Вигерс, К.И. Разработка требований к программному обеспечению / К. И. Вигерс. - М.: Русская редакция, 2004. - 576 с.

