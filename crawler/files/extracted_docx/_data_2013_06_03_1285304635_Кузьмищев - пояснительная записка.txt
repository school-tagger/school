Московский институт электроники и математики НИУ ВШЭ

Кафедра Информационно-коммуникационных технологий








ПОЯСНИТЕЛЬНАЯ ЗАПИСКА

к дипломному проекту

На тему: ≪Разработка виртуального стенда для изучения методик построения VPN соединений≫










Студент: Кузьмищев Антон Сергеевич



Руководитель проекта: 			 Фомин Сергей Сергеевич



Допущен к защите 	     			___________ 2013 г.





Консультанты проекта:



Специальная часть				С. С. Фомин



Охрана труда 		 		Е. Б. Михайлов



Зав. кафедрой  проф.  д.т.н. 			В. Н. Азаров













Москва 2013


Аннотация

Разработка виртуальной среды для проведения практических занятий по освоению протоколов VPN соединений дает возможность студентам магистратуры глубже изучить тематику построения защищенных VPN соединений. 

Виртуальная среда представляет собой программно-аппаратный комплекс, в котором реализуются различные модели подключения сетей (сеть-хост, сеть-сеть) и способы их взаимодействия. 

В работе рассмотрены типы протоколов VPN (IPSec, PPTP, L2TP), обзор программных реализаций VPN серверов (PoPToP, MPD5, OpenVPN), практические рекомендации по настройке нескольких видов серверов VPN в ОС FreeBSD для приведенных типов соединений, с натурными экспериментами. 

В качестве программной базы для реализации виртуальной среды используется система виртуализации Oracle VM VirtualBox. 

Конечный результат работы представляет собой виртуальную среду с подключаемыми соединениями по протоколу VPN, на котором студенты смогут оттачивать навыки работы с VPN.







Введение

Создание виртуальной среды для работы с VPN актуально тем, что студенты смогут получить практический навык работы в процессе обучения и применить его в дальнейшем на практике. В работе содержатся все необходимые сведения для самостоятельной настройки VPN сервера и реализации подключений. 

Целью данной работы является создание виртуальной среды, реализующей различные виды соединений VPN.

Задачи, решаемые в данной работе:

	1) Обзор протоколов построения VPN соединений;

	2) Анализ существующих программных средств реализаций VPN сервера;

	3) Выбор программной базы для реализации VPN в виртуальной среде;

	4) Выбор операционных систем;

	5) Анализ и выбор систем виртуализации;

6) Разработка виртуальной среды для проведения практических занятий по освоению протоколов построения VPN соединений;

	7) Создание учебно-методического пособия для практических занятий.

Работа будет полезна студентам младших курсов, людям пытающимся разобраться с сетевыми технологиями самостоятельно, а также обычным пользователям.


1. Обзорно-аналитическая часть

1.1. Обзор протоколов

Технология VPN (англ. Virtual Private Network – виртуальная частная сеть) позволяет обеспечить одно или несколько соединений, поверх уже существующей сети (например, Интернет), а с помощью современных криптографических средств (шифрование, аутентификация, криптографические ключи) добиться максимальной защищенности передаваемой информации.

Если обратиться к модели OSI, то VPN чаще всего реализуется на уровне не выше сетевого, т.к. именно на этих уровнях можно использовать криптографию, оставляя без изменения транспортные протоколы.

Таким образом, VPN представляет собой защищенное соединение поверх существующей сети, осуществляемое посредством инкапсуляции данных, чаще всего в протокол IP.

В свою очередь, протоколов реализации VPN существует не так много. Рассмотрим каждый из них.

1.1.1. IPSEC

IPsec [2] (англ. IP Security) – это набор протоколов, обеспечивающих безопасность передачи данных поверх IP протокола. Принцип, по которому достигается требуемый уровень безопасности, состоит в добавлении к IP пакету собственных заголовков.

IPsec – стандарт Интернет, поэтому он обладает “Рабочим предложением” (RFC – Requests For Comments). Рассмотрим ряд RFC относящихся к IPsec:

RFC 2401 – SA (Security Architecture for the Internet Protocol)

Так называемая концепция “Защищенного виртуального соединения” (SA). Является фундаментальной в IPSec. Представляет собой двунаправленное соединение для каждого используемого протокола (AH - аутентифицирующий заголовок, или ESP – инкапсуляция зашифрованных данных).

Определены два режима SA: режим транспорта и режим туннелирования.

Транспортный режим SA обеспечивает безопасную связь между двумя хостами. В IPv4 заголовок протокола безопасности транспортного режима появляется сразу после IP заголовка и всех опций и перед любыми протоколами более высокого уровня (ТСР или UDP). В случае ESP транспортный режим SA обеспечивает сервисы безопасности только для протоколов более высокого уровня, но не для IP-заголовка. В случае AH защита также распространяется на отдельные части IP-заголовка.

Другим режимом SA является режим туннелирования. Если хотя бы одним из концов соединения является шлюз безопасности, то SA обязательно должна выполняться в туннелирующем режиме. SA между двумя шлюзами безопасности всегда находится в туннелирующем режиме, так же, как и SA между хостом и шлюзом безопасности. Заметим, что когда трафик предназначен для шлюза безопасности, например, в случае SNMP-команд, шлюз безопасности рассматривается как хост, и допустим транспортный режим. Два хоста могут при желании так же устанавливать туннелирующий режим.

Так как защищенные виртуальные соединения (SA) являются , то для организации  канала, как минимум, нужны два SA. Помимо этого, каждый протокол (ESP/AH) должен иметь свою собственную SA для каждого направления, то есть, связка AH+ESP требует наличия четырех SA. Все эти данные располагаются в SADB (SA Data Base).

Помимо базы данных SADB, реализации IPsec поддерживают базу данных SPD (Security Policy Database - База данных политик безопасности). Запись в SPD состоит из набора значений полей IP-заголовка и полей заголовка протокола верхнего уровня. Эти поля называются селекторами. Селекторы используются для фильтрации исходящих пакетов, с целью поставить каждый пакет в соответствие с определенным SA. Когда формируется пакет, сравниваются значения соответствующих полей в пакете (селекторные поля) с теми, которые содержатся SPD. Находятся соответствующие SA. Затем определяется SA (в случае, если оно имеется) для пакета и сопряженный с ним индекс параметров безопасности (SPI). После чего выполняются операции IPsec (операции протокола AH или ESP).

RFC 2402 – AH (Authentication Header)

Протокол заголовка идентификации (рис. 1.1). Протокол обеспечивает целостность передаваемых по защищенному каналу данных, путем проверки того, что ни один байт в защищаемой информации не был изменен во время передачи. Подробно, с диаграммами, структура данного заголовка описывается в соответствующем RFC.

Важно отметить, что использование AH может вызывать проблемы при прохождении пакета через NAT устройство. Как  известно, NAT меняет IP адрес, а значит пакет меняется и контрольная сумма AH – становится не верной.

АH служит для подтверждения факта связи с целевым узлом и что данные, которые мы получаем при передаче, не искажены. 

Формат заголовка AH проиллюстрирован на рисунке 1.1. Рассмотрим его состав.

Next Header (8 bits) 

Тип заголовка протокола, идущего после заголовка AH. По этому полю приемный IP-sec модуль узнает о защищаемом протоколе верхнего уровня. Значения этого поля для разных протоколов можно посмотреть в .

Payload Len (8 bits)

Это поле определяет общий размер АН-заголовка в 32-битовых словах, минус 2. Несмотря на это, при использовании IPv6 длина заголовка должна быть кратна 8 байтам.



Рис. 1.1 Формат протокола заголовка идентификации



Reserved (16 bits)

Зарезервировано. Заполняется нулями.

Security Parameters Index (32 bits)

Индекс параметров безопасности. Значение этого поля вместе с IP-адресом получателя и протоколом безопасности (АН-протокол), однозначно определяет защищенное виртуальное соединение (SA) для данного пакета. Диапазон значений SPI 1...255 зарезервирован IANA.

Sequence Number (32 bits)

Последовательный номер. Служит для защиты от повторной передачи. Поле содержит монотонно возрастающее значение параметра. Несмотря на то, что получатель может отказаться от услуги по защите от повторной передачи пакетов, оно является обязательным и всегда присутствует в AH-заголовке. Передающий IPsec-модуль всегда использует это поле, но получатель может его и не обрабатывать.

Integrity Check Value

Контрольная сумма. Должна быть кратна 8-байтам для IPv6, и 4-байтам для IPv4.

RFC 2406 – ESP (IP Encapsulating Security Payload)

Инкапсулирующий протокол безопасности (рис. 1.2). ESP также может обеспечивать целостность соединения, аутентификацию исходных данных и дополнительно anti-replay сервис. Целостность обеспечивается только для протоколов более высокого уровня. Хотя бы один из этих сервисов должен быть задействован при использовании ESP.



Рис. 1.2 Структура инкапсулирующего протокола безопасности



Security Parameters Index (32 bits)

Индекс параметров безопасности. Значение этого поля вместе с IP-адресом получателя и протоколом безопасности (АН-протокол), однозначно определяет защищенное виртуальное соединение(SA) для данного пакета. Диапазон значений SPI 1...255 зарезервирован IANA для последующего использования.

Sequence Number (32 bits)

Последовательный номер. Служит для защиты от повторной передачи. Поле содержит монотонно возрастающее значение параметра. Несмотря на то, что получатель может и отказаться от услуги по защите от повторной передачи пакетов, оно всегда присутствует в AH-заголовке. Отправитель (передающий IPsec-модуль) должен всегда использовать это поле, но получатель может и не нуждаться в его обработке.

Payload data (variable)

Это поле содержит данные в соответствии с полем "Next Header". Это поле является обязательным и состоит из целого числа байтов. Если алгоритм, который используется для шифрования этого поля, требует данных для синхронизации криптопроцессов (например, вектор инициализации — "Initialization Vector"), то это поле может содержать эти данные в явном виде.

Padding (0-255 octets)

Дополнение. Необходимо, например, для алгоритмов, которые требуют, чтобы открытый текст был кратен некоторому числу байтов), например, размеру блока для блочного шифра.

Pad Length (8 bits)

Размер дополнения(в байтах).

Next Header (8 bits)

Это поле определяет тип данных, содержащихся в поле "Payload data".

Integrity Check Value

Контрольная сумма. Должна быть кратна 8-байтам для IPv6, и 4-байтам для IPv4.

RFC 2409 – IKE (The Internet key Exchange)

Протокол, предназначенный для обмена ключами между двумя узлами VPN. Протокол предусматривает генерацию ключей вручную и в автоматическом режиме. Обмен данными в IKE происходит в 2 фазы. В первой фазе устанавливается SA IKE. Во второй SA IKE используется для согласования протокола (обычно IPSec).

Фаза Один и Фаза Два

Теперь давайте посмотрим как всё это работает вместе. Установка и поддержка VPN туннеля происходит в два этапа. На первом этапе (фазе) два узла договариваются о методе идентификации, алгоритме шифрования, хэш алгоритме и группе Диффи Хеллмана (Diffie Hellman – алгоритм, позволяющий двум или более пользователям обменяться без посредников ключом). Они также идентифицируют друг друга. Всё это может пройти в результате обмена тремя нешифрованными пакетами (т.н. агрессивный режим) или через обмен шестью нешифрованными пакетами (стандартный режим - main mode). Предполагая, что операция завершилась успешно, создаётся SA первой Фазы - Phase 1 SA (также называемый IKE SA) и процесс переходит к Фазе Два.

На втором этапе генерируются данные ключей, узлы договариваются насчёт используемой политики. Этот режим, также называемый быстрым режимом (quick mode), отличается от первой фазы тем, что может установиться только после первого этапа, когда все пакеты второй фазы шифруются. Такое положение дел усложняет решение проблем в случае неполадок на второй фазе при успешном завершении первой. Правильное завершение второй фазы приводит к появлению Phase 2 SA или IPSec SA, и на этом установка туннеля считается завершённой.

Допустим, туннель между узлами был успешно установлен и ожидает пакетов. Однако, узлам необходимо переидентифицировать друг друга и сравнить политику через определённое время. Это время известно как время жизни Phase One или IKE SA lifetime.

Узлы также должны сменить ключ для шифрования данных через другой отрезок времени, который называется временем жизни Phase Two или IPSec SA lifetime. Phase Two lifetime короче, чем у первой фазы, т.к. ключ необходимо менять чаще. Типичное время жизни Phase Two - 60 минут. Для Phase One оно равно 24 часам.

1.1.2. PPTP

PPTP [5][6] (англ. Point-to-point transfer protocol) – протокол соединения “точка-точка”. Создан для инкапсуляции PPP кадров в пакет IP. Инициирует сессию по протоколу GRE (протокол туннелирования сетевых пакетов, ирующий пакеты сетевого уровня в IP пакеты) с другой стороной и создает TCP соединение для управления GRE трафиком по порту 1723. Протокол поддерживает шифрование данных MPPE (Microsoft point-to-point encryption). Для аутентификации клиентов, могут использоваться различные механизмы, наиболее безопасные из них:  и .

Процесс связи по протоколу PPTP

Поскольку вся идея дистанционного доступа состоит в разрешении машине клиента подключаться по телефонной линии к машине сервера, соединение PPTP инициируется клиентом, который использует служебное средство Windows NT - Remote Access Service (RAS) - для установления PPP-соединения с поставщиком услуг Internet. Затем при активизированном соединении PPP с помощью сервера, подключенного к Internet и действующего как сервер RAS, клиент применяет RAS для выполнения второго соединения. На этот раз в поле номера телефона указывается IP-адрес (имя или номер), и клиент, для того чтобы осуществить соединение, вместо COM-порта использует VPN-порт (VPN-порты конфигурируются на машинах клиента и сервера в процессе инсталляции PPTP).

Ввод IP-адреса инициирует передачу запроса серверу на начало сеанса. Клиент ожидает от сервера подтверждения имени пользователя и пароля и ответа сообщением, что соединение установлено. В этот момент начинает свою работу канал PPTP, и клиент может приступить к туннелированию пакетов серверу. 

В основе обмена данными по протоколу PPTP лежит управляющее соединение PPTP - последовательность управляющих сообщений, которые устанавливают и обслуживают туннель. Полное соединение PPTP состоит только из одного соединения TCP/IP, которое требует передачи эхо-команд для поддержания его открытым, пока выполняются транзакции. В таблице 1.1 показаны эти сообщения и их функциональное назначение.

Таблица 1.1. Управляющие сообщения PPTP



1.1.3. L2TP

L2TP [7] [8] (англ. Layer 2 tunneling protocol) – протокол туннелирования второго уровня. Главное достоинство L2TP в том, что этот протокол позволяет создавать туннель не только в IP но и, к примеру, в ATM сетях (сети в которых используется асинхронный способ передачи данных).

Транспортной средой для протокола является – UDP (протокол пользовательских дейтаграмм). Шифрование данных обеспечивает комплекс средств, предлагаемый протоколом безопасности IPSec.

Не смотря на то, что L2TP действует на подобии канального уровня модели OSI, он является протоколом Сеансового уровня и использует зарегистрированный UDP порт – 1701.

L2TP использует два вида пакетов, управляющие и информационные сообщения. 

Управляющие сообщения используются при установлении, поддержании и закрытии туннелей. 

Информационные сообщения используются для инкапсуляции PPP-кадров пересылаемых по туннелю. Управляющие сообщения используют надежный контрольный канал в пределах L2TP, чтобы гарантировать доставку. Информационные сообщения если происходит их потеря, не пересылаются повторно.

Таблица 1.2. Структура протокола L2TP



В табл. 1.2. показано взаимоотношение PPP-кадров и управляющих сообщений по управляющему и информационному каналам L2TP. PPP-кадры передаются через ненадежный канал данных, инкапсулированные сначала в L2TP, а затем в транспортные пакеты, такие как UDP, Frame Relay, ATM и т.д. Управляющие сообщения посылаются через надежный управляющий канал L2TP, который передает пакеты в пределах того же пакетного транспорта.

Порядковые номера необходимы во всех управляющих сообщениях и используются в управляющем канале для обеспечения надежной доставки. Информационные сообщения могут использовать порядковые номера, чтобы восстановить порядок пакетов и детектировать потерю кадров. Все коды посылаются в порядке, принятом для сетей (старшие октеты первые).

Формат заголовка L2TP

Пакеты L2TP для контрольного и информационного каналов используют один и тот же формат заголовка. Заметим, что поля длина, Ns и Nr - опционные для информационных пакетов, являются обязательными для всех управляющих сообщений.

Заголовок имеет следующий формат:

Таблица 3. Формат заголовка L2TP



Бит тип (T) характеризует разновидность пакета. Он устанавливается равным 0 для информационных сообщений и 1 - для управляющих.

Если бит длины (L) равен 1, поле длина присутствует. Для управляющих сообщений этот бит должен быть равен 1.

Биты (X) зарезервированы для будущих применений. Все зарезервированные биты должны быть установлены равными 0 для исходящих сообщений и игнорироваться для входящих.

Если бит последовательности (S) равен 1, поля Ns и Nr присутствуют. Бит S для управляющих сообщений должен быть равен 1.

Если бит смещения (O) равен 1, поле величины смещения присутствует. Бит O для управляющих сообщений должен быть равен 0.

Если бит приоритета (Р) равен 1, это информационное сообщение должно обслуживаться с предпочтением при обработке очередей и передаче. Запрос эхо LCP (Link Control Protocol) используется для канала, в качестве контроля keepalive, его следует посылать с битом приоритета равным 1. Без этого, временные периоды локальной перегрузки могут вызвать интерференцию с сообщениями keepalive и потерю связи. Эта особенность характерна только для информационных сообщений. Бит P должен быть равен 0 для всех управляющих сообщений.

Поле “Версия” должно быть равно 2, указывая версию заголовка информационного сообщения L2TP. Значение 1 зарезервировано для детектирования пакетов L2F [RFC-2341], в условиях, когда они приходят вперемешку с L2TP-пакетами. Пакеты, полученные с неизвестным значением поля “Версия”, должны отбрасываться. 

Поле “Длина” указывает общую длину сообщения в октетах.

ID-туннеля содержит идентификатор управляющего соединения. Идентификаторы туннеля L2TP имеют только локальное значение. То есть, разные концы одного туннеля должны иметь разные ID. ID-туннеля в каждом сообщении должно быть тем, которое ожидает получатель. ID-туннеля выбираются при формировании туннеля.

ID-сессии определяет идентификатор для сессии данного туннеля. Сессии L2TP именуются с помощью идентификаторов, которые имеют только локальное значение. ID-сессии в каждом сообщении должно быть тем, которое ожидает получатель. ID-сессии выбираются при формировании сессии.

(Ns) определяет порядковый номер информационного или управляющего сообщения, начиная с нуля и увеличиваясь на 1 (по модулю 216) для каждого посланного сообщения. 

(Nr) содержит порядковый номер, который ожидается для следующего сообщения. Таким образом, Nr делается равным Ns последнего по порядку полученного сообщения плюс один (по модулю 216). В информационных сообщениях, Nr зарезервировано и, если присутствует (как это определяется S- битом), должно игнорироваться при получении. 

Поле величина смещения (Offset Size), если имеется, специфицирует число октетов после заголовка L2TP, где должно начинаться поле данных. Содержимое заполнителя смещения не определено. Если поле смещения присутствует, заголовок L2TP завершается после завершающего октета заполнителя смещения.

представляющий собой комбинацию технологий PPTP и L2F (Layer Two Forwarding). Транспортная среда для протокола L2TP — UDP. Шифрование данных обеспечивает комплекс средств, предлагаемых протоколом безопасности IPSec. Доступны следующие методы шифрования: DES (Data Encryption Standard) с 56-бит ключом и 3DES (Triple DES) с тремя 56-бит ключами. 

1.2.Обзор программного обеспечения

В настоящее время существует большое количество программных реализаций VPN-серверов, поддерживающих различные протоколы VPN, такие как: PPTP, L2TP, PPPoE. Обратим внимание на самые распространенные из них.

1.2.1. PoPToP

PoPToP – open source реализация PPTP сервера как в Linux, так и во FreeBSD. В обеих операционных системах сервер можно собрать из исходных кодов. Подробнее о проекте можно узнать на сайте - http://poptop.sourceforge.net/. Важно отметить, что данный программный продукт поддерживает только PPTP протокол, что не очень подходит для решения задачи изучения протоколов VPN в силу не поддержки остальных протоколов.

По структуре своей, сервер очень прост. Состоит из:

/etc/ppp/ppp.conf – основной конфигурационный файл, описывающий VPN сервер.

/etc/ppp/options.pptpd – конфигурационный файл с описанием опций сервера (например, тип шифрования).

/etc/ppp/ppp.secret – файл с описанием логинов и паролей для аутентификации клиентов.

Примечание: расположение конфигурационных файлов зависит от выбора ОС. Вышеописанные пути к конфигурационным файлам были взяты на примере ос FreeBSD.

Настройка сервера производится довольно просто. Всю необходимую информацию можно прочитать на сайте проекта.

1.2.2. MPD5

MPD [12] (Multi-protocol daemon) – это реализация базирующегося на netgraph PPP протокола во FreeBSD.  Из достоинств следует отметить поддержку таких протоколов как: pptp, l2tp, pppoe. Установка производится как из системы портов, так и из исходных кодов. Программа включает в себя следующие конфигурационные файлы:

mpd.conf – основной файл конфигурации сервера. Может определять одну или более конфигураций сервера. Если конфигурация не задана – задается конфигурация по умолчанию “default”.

mpd.secret - Этот файл содержит пары логин и пароль. Здесь mpd ищет всю информацию для аутентификации.

mpd.script – файл содержит скрипты для устройств.

Подробная документация по установки и настройки находится на сайте: 



или на официальном сайте проекта:



1.2.3. OpenVPN

OpenVPN [13] – является свободной реализацией протокола VPN с открытым исходным кодом. Предназначен для соединений типа “точка-точка” или “сервер-клиенты”. Основным достоинством этого протокола является возможность установления соединения компьютерами, находящимися за NAT. 

Возможна установка из исходных кодов. Во FreeBSD так же доступна из портов.

Подробная инструкция по установке и настройке находится на официальном сайте проекта:

 

Русская версия документации: 



OpenVPN проводит все сетевые операции через , либо -порт. Также возможна работа через прокси-сервер.

Сервер может быть настроен на назначение сетевых настроек клиенту. Например: IP-адрес, настройки маршрутизации и параметры соединения.

OpenVPN предлагает два различных варианта сетевых интерфейсов, используя драйвер . Возможно создать Layer 3-based IP туннель, называемый TUN, и Layer 2-based Ethernet — TAP, способный передавать  трафик. Также возможно использование библиотеки компрессии , для сжатия потока данных. Используемый порт 1194 выделен  для работы данной программы. Версия 2.0 позволяет контролировать несколько одновременных туннелей, в отличие от версии 1.0, позволявшей создавать только 1 туннель на 1 процесс.

Использование в OpenVPN стандартных протоколов  и  позволяет ему стать альтернативой  в ситуациях, когда Интернет-провайдер блокирует некоторые протоколы.

1.2.4. Выбор программного обеспечения и ОС

Для реализации поставленной задачи, среди множества семейств операционных систем (Linux, Windows, FreeBSD, и т.д.), однозначно подходит FreeBSD. Эта операционная система хороша тем, что изначально ориентирована на обслуживание сетей и множества пользователей. FreeBSD может служить основной в роли сервера для таких сервисов как: DNS, VPN, DHCP, SAMBA, MAIL и т.д. Для реализации VPN эта система подходит идеально по нескольким причинам:

Поддержка маршрутизации пакетов на уровне ядра.

Поддержка IPSec на уровне ядра.

Поддержка PPTP, L2TP посредством демона MPD5. 

Из всех программных средств, описанных выше, особое внимание уделяется утилите MPD5. Исходя из выбора операционной системы, выбор программной реализации VPN-сервера очевиден. С помощью MPD будут осуществляться подключения по протоколам PPTP и L2TP.

1.3. Обзор средств виртуализации

1.3.1. VIrtualBox

Платформа  [16] [17] представляет собой настольную систему виртуализации для Windows, Linux и Mac OS хостов, поддерживающую операционные системы Windows, Linux, OS/2 Warp, OpenBSD и FreeBSD в качестве гостевых. На данный момент Oracle VirtualBox включает в себя следующие возможности:

нативная x86-виртуализация, не требующая наличия поддержки аппаратных техник Intel VT или AMD-V (которая, однако, может быть включена в настройках);

дружественный пользовательский интерфейс (построенный с помощью графической библиотеки Qt);

поддержка Windows, Linux и Mac OS хостовых систем (версия для Mac OS в данный момент находится в стадии бета-тестирования);

наличие Guest VM Additions для упрощения взаимодействия с хостовыми ОС и оптимизации их быстродействия;

поддержка многопроцессорных и многоядерных систем (только в качестве гостевых, поддержка представления многопроцессорности в гостевых системах отсутствует);

стабильность (обеспечиваемая компанией Oracle);

поддержка виртуализации аудиоустройств;

высокая производительность (по отзывам множества экспертов выше, чем у продуктов VMware);

поддержка различных видов сетевого взаимодействия (NAT, Host Networking via Bridged, Internal);

поддержка дерева сохраненных состояний виртуальной машины (snapshots), к которым может быть произведен откат из любого состояния гостевой системы;

описание настроек виртуальной машины в XML-формате;

поддержка разделяемых папок для простого обмена файлами между хостовой и гостевой системами.

Эмулируемое аппаратное окружение

Продукт VirtualBox эмулирует следующие компоненты аппаратного обеспечения в виртуальной машине:

жесткие диски эмулируются в специальном формате контейнеров VDI (Virtual Disk Images), который в данный момент не совместим с форматами виртуальных дисков других производителей;

видеоадаптер эмулируется как стандартный VESA с 8 Мб видеопамяти, при этом установка Guest VM Additions (только для Windows и Linux хостов) позволяет увеличить производительность виртуального видеоадаптера и динамически менять размер окна виртуальной машины

аудиоконтроллер на базе Intel ICH AC'97;

сетевой адаптер эмулируется как интерфейс AMD PCNet;

в издании с закрытым исходным кодом эмулируются также контроллеры USB, при этом USB-устройства, вставленные в разъемы хоста, автоматически подхватываются в гостевой системе.

Платформа VirtualBox исполняет код гостевой системы прямой передачей инструкций процессору хоста.

Уникальные функции VirtualBox

Помимо стандартных функций, присущих большинству настольных систем виртуализации, платформа VirtualBox обладает также набором уникальных возможностей, присущих только ей:

Ярко выраженная модульность системы. Платформа VirtualBox имеет модульную архитектуру с хорошо описанными компонентами и предоставляет удобные интерфейсы доступа к виртуальным машинам, которые позволяют контролировать гостевые системы как через GUI, так и через командную строку и удаленно. К тому же, компания Oracle предоставляет отличную среду разработки (SDK – Software Development Kit), и поскольку код платформы открыт, не требуется дополнительных усилий, чтобы написать расширение к системе. В данный момент ведется большая работа по переноса продукта на различные хостовые платформы и разработчикам предоставляются все необходимые инструменты и интерфейсы для доработки VirtualBox.

Виртуальная машина может действовать как RDP-сервер. В отличие от других платформ виртуализации, VirtualBox может действовать как RDP-сервер и управляться любым клиентом, поддерживающим протокол RDP. Также поддерживается функция USB over RDP. Стоит отметить, что компания VMware в вышедшей недавно платформе VMware Workstation 6 также предоставляет функцию взаимодействия с RDP-сервером, поэтому эту функцию VirtualBox на данный момент нельзя назвать уникальной.

Компонент iSCSI initiator является одной из закрытых частей платформы VirtualBox. Он позволяет использовать внешние устройства по протоколу iSCSI в качестве виртуальных дисков в гостевой системе без дополнительной поддержки со стороны гостевой ОС.

Поддерживаемые гостевые и хостовые системы

Компания Oracle и независимые разработчики, принимающие участие в доработке платформы VirtualBox, постоянно расширяют список поддерживаемых гостевых и хостовых систем. На данный момент продуктом поддерживаются следующие хостовые ОС:

Операционные системы семейства Windows (2000/XP/2003/Vista/7)

Linux-платформы, включая:

Ubuntu 

Debian 

openSUSE 

Mandriva Linux 

Red Hat Enterprise 

Univention Corporate Server 

Mac OS X 

FreeBSD 

1.3.2. VMware

VMware Workstation [18] — известная программа для виртуализации систем. VMware Workstation является мощным решением для разработчиков программного обеспечения и системных администраторов, создающих и тестирующих полно-комплексные сетевые приложения класса серверов, работающие в различных средах. Уникальная технология VMware MultipleWorlds позволяет изолировать операционные системы и приложения в пределах создаваемых  машин, причем в распоряжении каждой виртуальной машины оказывается стандартный компьютер x86, с собственным процессором и памятью. С помощью данного решения вы сможете на одном компьютере вести процессы разработки, тестирования, отладки и запуск многоуровневых браузерных приложений, эксплуатировать новые операционные системы и унаследованные приложения на одном компьютере, устанавливать новые или обновлять имеющиеся операционные системы без выполнения операций с разделами дисков и перезагрузки компьютера.

Новая платформа предлагает расширенные возможности для разработчиков приложений, инженеров по контролю качества, специалистов по продажам технологических решений и IT-администраторов. Одним из самых заметных нововведений пакета VMware Workstation стала расширенная поддержка 32-битных и 64-битных версий Windows. Пакет VMware Workstation 9 стал первым продуктом с полной поддержкой графической оболочки Aero в системах Windows 8. Существенно расширен перечень трехмерных приложений на базе технологий DirectX 9.0c Shader Model 3 и OpenGL 2.1, которые можно запускать в виртуальных машинах Windows.

Основные возможности VMware Workstation:

Одновременный запуск нескольких гостевых операционных систем на одном компьютере.

Запуск виртуальной машины в окнах рабочего стола основной операционной системы и на полный экран.

Установка виртуальных машин без разбиения дисков.

Запуск уже установленных на компьютере ОС без их переустановки или конфигурирования.

Запуск приложений операционной системы Windows на компьютере с ОС Linux и наоборот.

Создание и тестирование приложений одновременно для разных систем.

Запуск непротестированных приложений без риска нарушить устойчивую работу системы или потерять критичные данные.

Совместное использование файлов и приложений разными виртуальными машинами за счет использования виртуальной .

Запуск клиент-серверных и веб-приложений на одном ПК.

Запуск на одном ПК нескольких виртуальных машин и  работы локальной сети.

1.3.3. Выбор средства виртуализации

В чем платформы VirtualBox и VMware Workstation обе хороши:

Понятный графический интерфейс.

Удобный редактор сетевого взаимодействия на хосте.

Диски виртуальных машин, увеличивающиеся по мере наполнения их данными (Thin Provisioning).

Технология мгновенных снимков (снапшотов).

Технология приложений в хостовой ОС из гостевой ОС в бесшовных окнах (то есть, приложение из виртуальной машины "выносится" в рабочую область хостовой системы, как будто оно в ней и работает).

Поддержка большого количества гостевых ОС, поддержка Windows и Linux в качестве гостевых ОС.

Поддержка 64-битных гостевых ОС.

Поддержка Intel VT и AMD-V.

USB 2.0 устройства в виртуальных машинах.

Воспроизведение звука на устройствах хоста из виртуальной машины.

Буфер обмена между гостевой и хостовой ОС.

Поддержка 3D-графики для игр и других приложений.

Поддержка импорта виртуальных модулей (Virtual Appliances).

Улучшенные драйверы в гостевой ОС: VMware Tools и VirtualBox Guest Additions (оба пакета обновляются автоматически).

Обе платформы поддерживают техники Memory Overcommit (так называемый Memory Ballooning - перераспределение свободной физической памяти между гостевыми ОС виртуальных машин).

Обе платформы поддерживают многопроцессорные виртуальные машины (не менее 8 виртуальных процессоров).

Расширение виртуальных дисков (в Workstation - удобнее).

Копирование файлов между виртуальной машиной и ОС хоста.

Обе платформы имеют поддержку доступа к консоли виртуальной машины через RDP-сервер.

Почему можно выбрать VirtualBox, а не VMware Workstation:

VirtualBox абсолютно бесплатен, а VMware Workstaion стоит 8283р. по российскому сегменту рынка на 2013 г (при покупке 1 лицензии).

VMware Workstation работает только в хостовых ОС Windows и Linux, а VirtualBox поддерживает хосты Windows, Linux, Mac OS X и Solaris.

Технология "Teleportation", позволяющая переместить запущенную виртуальную машину на другой хост VirtualBox, без необходимости ее остановки. Данная функция отсутствует в VMware Workstation.

VirtualBox имеет возможность работы не только со своим форматом VDI, но и VMDK, и VHD. VMware Workstation имеет возможность исполнять виртуальные машины только из образов виртуальных дисков VMDK (хотя есть бесплатный продукт VMware Converter для импорта виртуальных машин из других форматов).

VirtualBox имеет больше параметров для работы из командной строки (управление ВМ, устройствами, снапшотами и многим другим).

VirtualBox лучше поддерживает аудио для Linux-хостов (Workstation отключает звук в хостовой ОС, VirtualBox может играть параллельно).

VirtualBox имеет возможность ограничения потребления ресурсов CPU и ввода-вывода, у VMware Workstation этого нет (это умеет только VMware vSphere).

VirtualBox имеет возможность регулировки видеопамяти.

Почему можно выбрать VMware Workstation, а не VirtualBox:

VMware Workstation - коммерческий продукт, а значит вы всегда сможете рассчитывать на поддержку.

VMware Workstation имеет больше возможностей для поддержки 3D-графики, как то: Windows Aero user interface, OpenGL 2.1 и Shader Model 3.0. Сама 3D-акселерация работает стабильней, чем в VirtualBox.

VMware Workstation имеет драйвер универсальной печати ThinPrint (не требуется установка драйверов в гостевую ОС).

Создание снапшотов через заданные интервалы времени (), что позволяет защитить виртуальные машины по аналогии с возможностью автосохранения (например, как в Microsoft Word).

Compact Virtual Disks - сжатие виртуальных дисков для передачи под нужды других систем.

VMware Workstation имеет более широкий функционал по работе с виртуальным сетевым взаимодействием - коммутаторы, DHCP, NAT и прочее (хотя VirtualBox также имеет NAT, Bridge Networking - в Workstation это субъективно удобнее).

VMware Workstation имеет функционал связанных клонов (Linked Clones) для виртуальных машин.

Запись активности виртуальной машины в видеоформате, а также в виде последовательности действий пользователя (Guest Record / Replay).

Workstation имеет возможности интеграции со средами разработки и тестирования (например, Eclipse), а также специализированные функции для разработчиков ПО (но у VirtualBox лучше API).

Защита виртуальных машин 256-битным шифрованием.

В Workstation несколько приятных мелочей – например, ярлыков на приложения из меню "Пуск", функция "приостановить виртуальную машину".

Исходя из всего выше сказанного, выбор падает на Virtualbox, по главной причине – цена. Virtualbox бесплатен и выполняет все необходимые функции для задачи создания виртуальной среды.




2. Разработка структурных моделей защищенных сетей

Для реализации подключений будут использоваться следующие модели сетей:

2.1. Сеть 1

Рис. 2.1 Сеть 1

Рисунок 2.1 иллюстрирует, что в качестве серверной ОС выступает FreeBSD 9.1, она обслуживает клиентские хосты для предоставления им доступа к сети Интернет. Данная ОС выступает в качестве серверной не случайно, дело в том, что программное обеспечение FreeBSD, прежде чем попасть в релиз, тщательно проверяется и устраняются уязвимости, к сожалению это не всегда позволяет идти в ногу со временем, но для реализации VPN эта ОС обладает набором необходимого и надежного ПО. В качестве клиентских ОС используется дистрибутив ОС Linux Ubuntu 12.10, популярная на сегодняшний день своей широчайшей поддержкой в мире свободного программного обеспечения. Для данной задачи использование этой операционной системы позволит без лишних действий и привлечения сторонних инструментов, получить необходимый набор пользовательских программ и рабочего окружения.

Сеть 1 имеет адресное пространство 192.168.100.0 с сетевой маской 255.255.255.0. На Сервере (Server_1) работает DHCP-сервер, выдающий клиентам IP-адреса из диапазона 192.168.100.10-192.168.100.13, а так же выдающий настройки используемых DNS серверов и шлюза по умолчанию. В качестве шлюза по умолчанию так же выступает Server_1, в ядре операционной системы которого включен IP-FORWARDING и для управления правилами прохождения трафика используется встроенный в ядро фильтр пакетов IPFW. Т.о., любая из клиентских машин получает доступ в Интернет, получая по DHCP настройки.

Сеть 1 будет использоваться для демонстрации соединения сеть-сеть и хост-сеть.

Таблица 2.1 Таблица пользователей и паролей Сети 1




2.2. Сеть 2

                  Рис. 2.2 Сеть 2

Сеть 2 (рис. 2.2) является копией Сети 1 (рис. 2.1), за исключением того, что в ней используется другая адресация - 192.168.200.0/255.255.255.0 и отличные от сети 1 MAC-адреса хостов и сервера. Это необходимо для того, чтобы не возникало проблем с адресацией при соединении Сети 1 и Сети 2.

Сеть 2 будет использоваться для демонстрации соединения сеть-сеть и хост-сеть.

Таблица 2.2 Таблица пользователей и паролей Сети 2

2.3. Сеть 3

       Рис. 2.3 Сеть 3

Сеть 3 (рис. 2.3) состоит из двух серверов Server_1 и Server_2. На обоих серверах настроены статические адреса.

Сеть 3 предназначена для демонстрации работы протокола L2TP и будет реализовывать собой соединение хост-хост.

Таблица 2.3 (Таблица пользователей и паролей Сети 3)




2.4. Сеть 4

Рис. 2.4 Сеть 4

Сеть 4 (рис 2.4) состоит из одного сервера (Server_3), отвечающего за подсеть 192.168.44.0 с маской 255.255.255.0. Сервер 3 подключен к сети Интернет и имеет реальный IP – 192.168.5.23.

Сеть 4 будет использоваться для соединения сеть-сеть с сетью 5.

Таблица 2.4 (Таблица пользователей и паролей Сети 4)




2.5. Сеть 5

Рис. 2.5 Сеть 5

Сеть 5 (рис 2.5), как и сеть 4 (рис. 2.4), состоит из одного сервера (Server_4). Server_4 отвечает за сеть 192.168.55.0/255.255.255.0 и имеет реальный IP – 192.168.5.21.

Сеть 5 будет использоваться для соединения сеть-сеть с сетью 4.

Таблица 2.5 (Таблица пользователей и паролей Сети 5)




3. Планирование подключений моделей сетей в программном обеспечении

3.1. OpenVPN

В Unix-подобных операционных системах, для реализации openVPN туннеля используется виртуальный драйвер ядра. Этот драйвер эмулирует сетевые устройства tun или TAP.

TAP симулирует Ethernet устройство и работает на канальном уровне модели OSI, оперируя кадрами Ethernet.

TUN (сетевой туннель) работает на сетевом уровне модели OSI, оперируя IP пакетами. TAP используется для создания сетевого моста, тогда как TUN - для маршрутизации.

Пакет, посылаемый операционной системой через TUN/TAP устройство, обрабатывается программой, которая контролирует это устройство. Сама программа также может отправлять пакеты через TUN/TAP устройство. В таком случае TUN/TAP устройство доставляет (или «внедряет») такой пакет в сетевой стек операционной системы, эмулируя таким образом доставку пакета с внешнего устройства.

Для реализации схемы соединения “Сеть-сеть” будем использовать tun-адаптер.

Рис. 2.6 Соединение сеть-сеть при работе с туннелем OpenVPN

На рисунке 2.6 показано, что Сеть 1 соединена через Интернет с Сетью 2 с помощью двух сетевых адаптеров tun0.

Концепция OpenVPN подразумевает клиент-серверную модель. В качестве клиента будет выступать Server_2, а в качестве сервера – Server_1. Для настройки tun интерфейса необходимы специальные файлы конфигурации, как для клиента, так и для сервера.

На сервере Server_1 будет создан файл конфигурации server.ovpn, а на клиенте Server_2 будет создан файл конфигурации client.ovpn.

Важно учитывать тот факт, что за настройки маршрутизации и настройки для обоих tun интерфейсов, при объединении двух сетей посредством openVPN соединения, отвечает сервер (Server_1). Именно в файле конфигурации сервера описываются: сеть за клиентом, сеть за сервером, маршруты и настройки tun-интерфейса, выдаваемые клиенту.

Сервер (Server_1) будет иметь адрес tun-интерфейса – 10.10.10.1. Клиент (Server_2) – 10.10.10.2.

Для избежания возможных сложностей со стороны ipfw (пакетного фильтра FreeBSD), на серверах Server_1 и Server_2 в настройках фаерволла включена политика по умолчанию – DEFAULT TO ACCEPT (пропускать весь трафик).

Помимо файлов конфигурации для установления соединения между клиентом и сервером, OpenVPN использует обмен криптографическими  ключами и сертификатами.

Первый шаг в построении конфигурации OpenVPN 2.0 заключается в создании инфраструктуры открытых ключей (Public Key Infrastructure, PKI). PKI состоит из:

отдельного сертификата (также известного как открытый ключ) и секретного ключа для каждого сервера и клиента;

главного сертификата центра сертификации (Certificate Authority, CA) и ключа, который используется для подписи каждого сертификата для сервера и клиентов.

OpenVPN поддерживает двунаправленную аутентификацию на основе сертификатов, это означает что клиент должен проверять подлинность сертификата сервера, а сервер должен проверять подлинность сертификата клиента до того как они начнут доверять друг другу.

Сервер и клиент будут аутентифицировать друг друга, сначала проверив что представленный сертификат подписан центром сертификации (CA), а затем путем проверки информации в заголовках уже аутентифицированного сертификата, таких как "common name" сертификата (этот термин оставлен в тексте "как есть" по причине отсутствия общеупотрбительного варианта перевода, само же понятие в общем случае обозначает имя объекта, которому выдается сертификат) сертификата и тип сертификата (клиент или сервер).

Эта модель безопасности с точки зрения VPN имеет ряд желательных функций:

Серверу необходим только свой сертификат/ключ - у него нет необходимости знать индивидуальные сертификаты каждого клиента, который может подключиться к нему.

Сервер будет принимать только клиентов, чьи сертификаты были подписаны главным CA-сертификатом (который мы будем генерировать ниже). Поскольку сервер может выполнить эту проверку подписи без необходимости доступа непосредственно к закрытому ключу CA, есть возможность для CA-ключа (наиболее чувствительного ключа во всем PKI) находиться на совершенно другой машине, даже без сетевого подключения.

Если закрытый ключ скомпрометирован, его можно отключить, добавив его сертификат к CRL (certificate revocation list, список отозванных сертификатов). CRL позволяет выборочно отклонять скомпрометированные сертификаты без необходимости перестройки всего PKI.

Сервер может применять клиент-специфичные права доступа на основании встроенных областей сертификата, таких как Common Name.

В используемой модели (рис. 2.6), в качестве центра сертификации выступает Server_1. На нем, будут создан публичный ключ (ca.key) и главный сертификат центра сертификации (ca.crt), на основе которого будет проверяться подлинность подписи сертификата клиента Server_2. Важно отметить, что ключи и сертификаты для клиентов генерируются на Server_1 и впоследствии, передаются (любыми возможными путями), на машину клиента Server_2. Так же, будет создан файл ta.key – файл, необходимый для tls-аутентификации. TLS (англ. Transport Layer Security) — безопасность транспортного уровня, как и его предшественник SSL (англ. Secure Socket Layers — уровень защищённых сокетов) — криптографические протоколы, обеспечивающие защищённую передачу данных между узлами в сети Интернет.

На клиенте Server_2 будут 4 файла: публичный ключ (са.key), сертификат клиента (client.crt), ключ клиента (client.key), tls-ключ (ta.key).

Для модели соединения “хост-сеть” (рис. 2.7)  требуются те же условия что и для соединения “сеть-сеть”(рис. 2.6), но с тем отличием, что клиент не имеет за собой сети и имеет другие имена файлов сертификата и ключа. Так же, важно, что в файле конфигурации клиента на сервере (только в этом случае), не будет записи о сети, находящейся за клиентом.

Рис. 2.7 Соединение хост-сеть при работе с туннелем OpenVPN




3.2. MPD

Программный продукт MPD5 (Multi-Protocol-Daemon) предоставляет поддержку протоколов PPTP, L2TP и IPSec. Этих возможностей достаточно для того чтобы реализовать соединение “хост-сеть” для ознакомления с этими протоколами.

3.2.1. PPTP

PPTP работает, устанавливая обычную  сессию с противоположной стороной с помощью протокола . Второе соединение на -порте 1723 используется для инициации и управления GRE-соединением. PPTP сложно перенаправлять за , так как он требует одновременного установления двух сетевых сессий.

Для протокола PPTP будем использовать следующую схему:

Рис. 2.8 Соединение хост-сеть при работе с туннелем PPTP

В качестве клиента будет выступать хост Client_2_2 под управлением ОС Ubuntu 12.10 (рис. 2.8). В качестве сервера – выступает сервер Server_1 (Рис. 2.8) под управлением ОС FreeBSD 9.1.

Для соединения с сетью за Server_1, ОС Ubuntu будет использовать встроенный в систему по умолчанию, pptp-клиент. При соединении с Server_1, на Client_2_2 загружается специальный драйвер ppp, и создается виртуальный адаптер ppp0. Это необходимо для инкапсуляции ppp пакетов в IP-кадры и передачи по шифрованному туннелю пакетов серверу.

На Server_1 запущен MPD5-сервер, который прослушивает соединения на своем реальном IP-адресе (192.168.5.23). Для инкапсуляции ppp пакетов в IP-кадр, на сервере загружается драйвер виртуального устройства ng0.

На этом же устройстве настроен DHCP-сервер, который выдает пользователям IP-адреса в диапазоне 192.168.7.55 – 192.168.7.99. В нашем случае – клиенту Client_2_2 выдается фиксированный адрес 192.168.7.90.

Аутентификация пользователя на сервере Server_1 будет проходить с использованием файла, в котором хранится база данных логинов и паролей.

PPTP-трафик может быть зашифрован с помощью . Для  клиентов могут использоваться различные механизмы, самые защищенные из которых —  и .

3.2.2. L2TP

MPD5 может быть настроен на работу по протоколу L2TP. Для демонстрации работы протокола L2TP будем использовать модель хост-хост следующего вида (рис. 2.9):

Рис. 2.9 Соединение хост-хост при работе с туннелем L2TP

В модели на рисунке 2.9 в качестве клиента используется Server_1, а в качестве сервера -  Server_2. Оба под управлением ОС FreeBSD 9.1. На обоих серверах установлен MPD5. Только на Server_1 MPD5 выступает в роли клиента. На обоих серверах есть виртуальный адаптер ng0. L2TP работает на Сеансовом уровне модели OSI и использует зарегистрированный порт: 1701.  Клиенту присваивается адрес 10.10.0.5, а серверу 10.10.0.1.




3.3. IPSec

Протокол IPSec поддерживается ядром FreeBSD. Для его реализации будет использоваться виртуальный сетевой интерфейс gif.

Этот интерфейс поддерживается ядром FreeBSD и предназначен для реализации IPSec туннеля.

Для демонстрации работы протокола IPSec будем использовать схему, показанную на рисунке 2.10.

Рис. 2.10 соединение сеть-сеть при работе с IPSec туннелем

В модели на рисунке 2.10 в качестве сервера используется Server_3, на котором настроен виртуальный интерфейс gif1, а в качестве клиента используется Server_4 с настроенным интерфейсом gif0. Оба сервера имеют реальные IP-адреса:

Server_3: 192.168.5.23

Server_4: 192.168.5.21

Gif1 имеет IP-адрес 192.168.44.1 и маску 255.255.255.252. Маска 255.255.255.252 говорит о том, что интерфейс настроен на режим работы точка-точка.

Интерфейс gif1 соединяется через интернет с интерфейсом gif0 сервера Server_4, который имеет IP-адрес 192.168.55.1 и маску 255.255.255.252.

Принцип, по которому производиться обмен данными прост:

Каждый пакет, отправленный с сервера 3 (Server_3)  в сеть за сервером 4 (Server_4) отправляется на виртуальный интерфейс gif1, который шифрует этот пакет. После его отправки пакета, на интерфейс gif0 сервера 4 (Server_4) приходит зашифрованный пакет, который дешифруется и отправляется дальше по адресу назначения.

Шифрование производиться на основе публичного пароля, который заранее известен обоим серверам. После обмена паролями и подтверждения его правильности, создаются ключи, которые с течением времени изменяются. В результате создается пара SA.

SA (Secuiruty Assotiation) - связь (ассоциация) безопасности. Это термин IPSec для обозначения соединения. SA всегда создается парой, т.к. шифрование производиться в обе стороны.




4. Планирование подключений моделей сетей в виртуальной среде

4.1. VirtualBox

Для реализации подключения моделей будет использоваться программный продукт VirtualBox. Создано несколько виртуальных машин, для всех типов соединений. На рисунке 2.11 это показано.



Рис. 2.11 снимок созданных виртуальных машин

VirtualBox позволяет создавать виртуальные сети, и настраивать сетевые адаптеры виртуальных машин на работу в этих сетях. Всего будет пять сетей: Net1, Net2, Net3, Net4 и Net5.

4.1.1. Net1 (Сеть 1)

В сети Net1 находятся виртуальные машины Server_1, Client_1_1, Client_1_2, Client_1_3 (рис. 2.11). Server_1 выступает в роли сервера, обслуживающего Net1 и предоставляющий клиентам доступ в Интернет.

Net1 соединена с Net2 за счет сервера Server_1, который соединен мостом с корневой машиной.

Сеть Net1 будет использоваться для соединения сеть-сеть (рис. 2.6) и для соединения хост-сеть (рис. 2.7).

Таблица 2.6 Характеристики виртуальных машин сети Net1



У виртуальных машин Client_1_2 и Client_1_3 (рис. 2.11) полностью совпадают конфигурации с Client_1_1, За исключением того момента, что Client_1_2 имеет IP: 192.168.100.11, а Client_1_3 имеет IP: 192.168.100.12.

4.1.2. Net2 (Сеть 2)

В сети Net2 находятся виртуальные машины Server_2, Client_2_1, Client_2_2, Client_2_3 (рис. 2.11). Server_2 выступает в роли сервера, обслуживающую Net2 и предоставляющий клиентам доступ в Интернет.

Net2 соединена с Net1 за счет сервера Server_2, который соединен мостом с корневой машиной.

Сеть Net2 будет использоваться для соединения сеть-сеть (рис. 2.6) и для соединения хост-сеть (рис. 2.7).

Таблица 2.7 Характеристики виртуальных машин сети Net2



У виртуальных машин Client_2_2 и Client_2_3 полностью совпадают конфигурации с Client_2_1, За исключением того момента, что Client_2_2 имеет IP: 192.168.200.11, а Client_2_3 имеет IP: 192.168.200.12.

На рисунке 2.12 показана схема соединения сетей Net1 и Net2.

Рис. 2.12 Схема соединения Сети 1 и Сети 2 в VirtualBox

4.1.3. Net3 (Сеть 3)

В сети Net3 будут  находиться виртуальные машины  FreeBSD_l2tp_client (копия Server_1) и FreeBSD_l2tp_server (копия Server_2) (рис. 2.11).

Net3 будет использоваться для реализации соединения хост-хост (рис. 2.9).

Таблица 2.8 Характеристики виртуальных машин сети Net3

На рисунке 2.13 показана схема соединения сети Net3:

Рис. 2.13 Схема соединения сети Net3

4.1.4. Net4 (Сеть 4)

В сети Net4 находится сервер FreeBSD_IPSEC_server (рис. 2.11). Этот сервер является шлюзом для сети 192.168.44.0/255.255.255.0 и имеет реальный IP-адрес 192.168.5.23.

Сеть Net4 будет использоваться для реализации соединения сеть-сеть с сетью Net5 (рис 2.10).



Таблица 2.9 Характеристика виртуальной машины сети 4

4.1.5. Net5 (Сеть 5)

В сети Net5 находится сервер FreeBSD_IPSEC_client (рис. 2.11). Этот сервер является шлюзом для сети 192.168.55.0/255.255.255.0 и имеет реальный IP-адрес 192.168.5.21.

Сеть Net5 будет использоваться для реализации соединения сеть-сеть с сетью Net4 (рис 2.10).

На рисунке 2.14 показана схема соединения сети Net5 и сети Net4 в программной среде Virtualbox.

Рис 2.14 Схема соединения сети 4 и сети 5 в Virtualbox




5. Разработка методики работы с моделями сетей

Для всех моделей сетей будет использоваться одинаковый подход. Первым делом для каждой модели устанавливается программное обеспечение. Производится настройка сервера и клиента, редактируются конфигурационные файлы и проверяется наличие соединения между хостами сети и сервером, путем использования встроенной в Linux и FreeBSD утилиты Ping.

Ping позволяет обмениваться icmp пакетами для того чтобы определить, есть ли соединение с пингуемым хостом или нет. Ping посылает в сеть icmp-запрос и, если на него приходит icmp-ответ, то удаленная машина доступна.

Далее, после проверки связи путем использования утилиты ping производится прослушивание сетевых интерфейсов с использованием утилиты tcpdump (она так же является встроенной). Tcpdump позволяет прослушивать любые сетевые интерфейсы и регистрировать пакеты, проходящие через них, а также позволяет использовать фильтры, отбрасывая пакеты других протоколов и показывая только те, которые интересуют пользователя.

Таким образом, алгоритм работы с моделями сетей будет следующий:

Установка программного обеспечения (openvpn, mpd).

Настройка конфигурационных файлов сервера.

Настройка конфигурационных файлов клиента.

Проверка работоспособности программного обеспечения сервера, путем отслеживания .log файлов и изменения вывода команды ifconfig (для просмотра свойств туннельных адаптеров).

Проверка работоспособности программного обеспечения клиента, путем отслеживания .log файлов и изменения вывода команды ifconfig (для просмотра свойств туннельных адаптеров).

Запуск сервера.

Запуск клиента.

Проверка установления соединения путем использования команды ping до клиента.

Проверка установления соединения путем использования команды ping до клиента.

Устранение неисправностей (если такие есть).

Проверка правильности прохождения пакетов, путем использования программы tcpdump на сервере.

Проверка правильности прохождения пакетов, путем использования программы tcpdump на клиенте.

Устранение неисправностей (если такие есть).

Использование этого алгоритма поможет настроить VPN-соединения и определить неисправности на разных этапах настройки.




6. Реализация виртуальной среды

Реализация виртуальной среды состояла из следующих этапов:

1. Установка на корневую машину программного средства виртуализации VirtualBox.

2. Создание макетов сетей в VirtualBox. 

2.1 Создание макета сети Net1 (Сеть 1).

2.1.1 Создание виртуальной машины Server_1. Установка ОС FreeBSD 9.1 RELEASE. Установка и настройка OpenVPN. Установка и настройка MPD5 для работы с протоколом PPTP.

2.1.2 Создание клиентских виртуальных машин (Client_1_1, Client_1_2, Client 1_3). Установка ОС Ubuntu Linux 12.10 на каждую машину.

2.2 Создание макета сети Net2 (Сеть 2).

2.2.1 Создание виртуальной машины Server_2. Установка ОС FreeBSD 9.1 RELEASE. Установка и настройка OpenVPN. 

2.2.2 Создание клиентских виртуальных машин (Client_2_1, Client_2_2, Client 2_3). Установка ОС Ubuntu Linux 12.10 на каждую машину.

2.3 Создание макета сети Net3 (Сеть 3).

2.3.1 Создание виртуальной машины FreeBSD_L2TP_client для сети Net3. Установка ОС FreeBSD 9.1 RELEASE. Установка и настройка MPD5 для работы с протоколом L2TP в качестве клиента.

2.3.2 Создание виртуальной машины FreeBSD_L2TP_server для сети Net3. Установка ОС FreeBSD 9.1 RELEASE. Установка и настройка MPD5 для работы с протоколом L2TP в качестве сервера.

2.4 Создание макета сети Net4 (Сеть 4).

2.4.1 Создание виртуальной машины FreeBSD_IPSec_Server для сети Net4. Установка ОС FreeBSD 9.1 RELEASE. Включение поддержки IPSec в ядре. Настройка IPSec на FreeBSD_IPSec_server.

2.4 Создание макета сети Net5 (Сеть 5).

2.4.1 Создание виртуальной машины FreeBSD_IPSec_slient для сети Net4. Установка ОС FreeBSD 9.1 RELEASE. Включение поддержки IPSec в ядре. Настройка IPSec на FreeBSD_IPSec_client.

3. Тестирование настроенных соединений. Устранение неисправностей.

Примечание: развернутое руководство по установке и настройке программного обеспечения для реализации шифрованных VPN соединений содержится в приложении 1.




7. Охрана труда

Охрана труда – система сохранения здоровья и жизни работников в процессе рабочей деятельности. Охрана труда включает в себя правовые, социально-экономические, организационно-технические, санитарно-гигиенические, лечебно-профилактические, реабилитационные и иные мероприятия.

Полностью безопасных и безвредных производственных процессов не бывает. Задача охраны труда – минимизировать вероятность заболевания или поражения работающего с одновременным обеспечением комфорта при максимальной производительности труда. В ходе эксплуатации возможны вредные и опасные производственные факторы.

Опасные производственные факторы - это факторы, воздействие которых на работающего в определенных условиях приводит к травме или другому внезапному резкому ухудшению здоровья.

Вредные производственные факторы - это факторы, воздействие которых на работающего в определенных условиях приводит к заболеванию или снижению работоспособности.

В данном разделе дипломного проекта будет произведен  расчет информационной нагрузки оператора ЭВМ и спроектировано оптимальное рабочее место с точки зрения эргономики.







7.1 Исследование возможных опасных и вредных факторов при эксплуатации ЭВМ и их влияние на пользователей

При работе над ВКР использовались:

Сеть 220 В;

Помещения сухие, температура +5 - 30 градусов Цельсия, относительная влажность меньше или равна 60%, коэффициент заполнения менее 0,2;

Компьютер (монитор SAMSUNG SyncMaster 730BF, системный блок, клавиатура, мышь), принтер.

Характеристики монитора SAMSUNG SyncMaster 730BF: разрешение по горизонтали (max) 1280 пикселей; разрешение по вертикали (max) - 1024 пикселей; легко регулируемые контрастность и яркость.

Пользователь сидит за компьютером, следовательно, на него воздействует ультрафиолетовое излучение, статическое электричество, низкочастотные магнитные поля. Кроме того, компьютер подключен к сети, следовательно, существует опасность поражения электрическим током. На зрение влияет неправильное и недостаточное освещение помещения. На психику – вибрации и шум, монотонный труд. Так же влияет неправильная посадка за рабочим столом. 

Из анализа вышеприведенных рисков видна необходимость соблюдать правила безопасности на рабочем месте и предусмотреть меры защиты от вредоносных факторов.

Рассмотрим вредные и опасные факторы при эксплуатации  указанных элементов вычислительной техники.

Вычислительная техника питается от сети 220В 50Гц, а безопасное напряжение U < 40В, следовательно, появляется опасный фактор – поражение электрическим током. 

Проходя через организм, электрический ток производит 3 вида воздействия: термическое, электролитическое и биологическое.

Термическое действие проявляется в ожогах наружных и внутренних участков тела, нагреве кровеносных сосудов и крови и т.п., что вызывает в них серьёзные функциональные расстройства.

Электролитическое — в разложении крови и другой органической жидкости, вызывая тем самым значительные нарушения их физико-химических составов и ткани в целом.

Биологическое действие выражается в раздражении и возбуждении живых тканей организма, что может сопровождаться непроизвольными судорожными сокращениями мышц, в том числе мышц сердца и лёгких. При этом могут возникнуть различные нарушения в организме, включая механическое повреждение тканей, а также нарушение и даже полное прекращение деятельности органов дыхания и кровообращения.

Различают два основных вида поражения организма: электрические травмы и электрические удары. Часто оба вида поражения сопутствуют друг другу. Тем не менее они различны и должны рассматриваться раздельно

Во время работы на персональных ЭВМ при прикосновении к любому из элементов оборудования могут возникнуть разрядные токи статического электричества. Вследствие этого происходит электризация пыли и мелких частиц,  которые притягивается к экрану. Собравшаяся на экране электризованная пыль ухудшает видимость, а при повышении подвижности воздуха, попадает на лицо и в легкие человека, вызывает заболевания кожи и  дыхательных путей.

Особенно электростатический эффект наблюдается у компьютеров, которые находятся в помещении с полами, покрытыми синтетическими коврами.

Дисплейные мониторы представляют собой источники интенсивных электромагнитных полей.  Многочисленные катушки внутри монитора дают электромагнитное излучение низкой частоты.  Распространяется оно в основном в стороны и назад, поскольку экран ослабляет это излучение.

Электромагнитные поля с частотой 60 Гц и выше могут инициировать изменения в клетках животных (вплоть до нарушения синтеза ДНК). В отличие от рентгеновского излучения, электромагнитные волны обладают необычным свойством: опасность их воздействия при снижении интенсивности не уменьшается,  мало того, некоторые поля действуют на клетки тела только при малых интенсивностях или на конкретных частотах. 

Переменное электромагнитное поле, совершающее колебания с частотой порядка 60 Гц, вовлекает в аналогичные колебания молекулы любого типа, независимо от того, находятся они в мозге человека или в его теле. 

Результатом этого является изменение активности ферментов и клеточного иммунитета, причем сходные процессы наблюдаются в организмах при возникновении опухолей.

Степень воздействия электромагнитных излучений на оператора ЭВМ зависит от продолжительности облучения, характера и режима излучения, индивидуальных особенностей организма. Длительное воздействие ЭМП низких частот вызывает функциональные нарушения сердечно-сосудистой и центральной нервной систем человека, некоторые изменения в составе крови. При интенсивном длительном характере излучения могут возникнуть злокачественные опухоли, катаракта глаз. 

Во время работы компьютера дисплей создает ультрафиолетовое излучение, при  повышении плотности которого >10 Вт/м2, оно становиться  для человека вредным фактором. Его воздействие особенно сказывается при длительной работе с компьютером. 

Ультрафиолетовое излучение - электромагнитное излучение в области, которая примыкает к коротким волнам и лежит в диапазоне длин волн ~ 200 - 400 нм.

Различают следующие спектральные области:

200 - 280 нм - бактерицидная область спектра.

280 - 315 нм - Зрительная область спектра (самая вредная).

315 - 400 нм - Оздоровительная область спектра.

При длительном воздействии и больших дозах могут быть следующие  последствия: серьезные повреждения глаз (катаракта), рак кожи, кожно-биологический эффект (гибель клеток, мутация, канцерогенные накопления), фототоксичные реакции.

Энергетической характеристикой является плотность потока мощности [Вт/м2]. Биологический эффект воздействия определяется внесистемной единицей эр: 1 эр - это поток (280 - 315 нм), который соответствует потоку мощностью 1 Вт. 

Воздействие ультрафиолетового излучения сказывается при длительной работе за компьютером. Максимальная доза облучения:  7.5 мэр*ч/м2 за рабочую смену;  60 мэр*ч/м2 в сутки.



7.2 Методы и средства защиты от воздействия на пользователя опасных и вредных факторов.

Защиту от поражения электротоком осуществляют: обеспечением недоступности токоведущих частей от случайных прикосновений; электрическим разделением сети; устранением опасности поражения при появлении напряжения на частях машины; применением специальных электрозащитных средств.

Зануление - это преднамеренное электрическое соединение с нулевым защитным проводником металлических нетоковедущих частей ЭЛУ, которые могут оказаться под напряжением. Применяется в 3-хфазных сетях с заземленной нейтралью при напряжении менее 1000В. Основа принципа защиты занулением: защита человека осуществляется тем, что при замыкании одной из фаз на заземляющий корпус, в цепи появляется ток замыкания, который отключает от потребителя сеть. Ток короткого замыкания еще до срабатывания защиты вызывает перераспределение в сети, приводящее к снижению напряжения на корпусе относительно земли.  где НЗП - нулевой защитный проводник.

Техническим средством защиты от поражения электрического тока является зануление, схема подключения ЭВМ показана на рис. 18.



Рис. 18. Схема подключения ЭВМ

По заданным параметрам определим возможный Jк.з.:

 (1),

где: 

Jк.з. - ток короткого замыкания [А];

Uф - фазовое напряжение [B];

rm - сопротивление катушек трансформатора [Ом];

rнзп - сопротивление нулевого защитного проводника [Ом];

Uф = 220 В;  Ом ( по паспорту).



 

                                                       (2),





где:

- удельное сопротивление материала проводника [Ом*м];

l - длина проводника [м];

s – площадь поперечного сечения проводника [мм2].



По заданным параметрам определим возможный :

рмедь= 0,0175 Ом*м

 =400 м  ;  =150 м  ;  =50 м ; 







;      9,1





По величине  определяет с каким  необходимо в цепь питания включать автомат.

 (формула 3), где K – качество автомата.

 

Отсюда следует, что для отключения ПЭВМ от сети в случае короткого замыкания или других неисправностей в цепь питания ПЭВМ необходимо ставить автомат с   Jном= 8 А. 

При повышении напряженности поля Е>15 кВ/м, статическое электричество может привести к сбою в работе ПВЭМ , вплоть до исчезновения информации с ячеек памяти, т.к. элементы вычислительной техники питаются от U = 3-12В. 

Для защиты от статического электричества предусмотрены специальные шнуры питания с встроенным заземлением. Там, где это не используется (отсутствует розетка) необходимо заземлять корпуса оборудования. 

Также для защиты от воздействия электрического тока все корпуса оборудования, клавиатура, защелки дисководов и кнопки управления выполнены из изоляционного материала. 

Следует использовать:

Контурное заземление;

Экраны для снятия статического электричества;

Использовать антистатическое покрытие полов;

Влажная уборка помещения.

Кроме того, защита осуществляется: проветриванием без присутствия пользователя, влажной уборкой, нейтрализаторами статического электричества, подвижность воздуха в помещении должна быть не более 0.2 м/с.

Для снижения уровня воздействия электромагнитных полей НЧ желательно пользоваться следующими мерами: 

экранирование экрана монитора. Поверхность экрана покрывается слоем оксида олова, либо в стекло ЭЛТ добавляется оксид свинца; 

удаление рабочего места от источника электромагнитного поля. Оператор должен находиться на расстоянии вытянутой руки от экрана монитора; 

рациональное размещение оборудования. Необходимо располагать ПЭВМ на расстоянии не менее  от боковых и задних стенок других мониторов; 

ограничение времени работы за ПЭВМ. Время непрерывной работы должно составлять не более 4 ч в сутки. За неделю суммарное время работы не должно превышать 20 ч. 

Для защиты от ультрафиолетового излучения применяют:  защитные фильтры или специальные очки (толщина стекол 2мм, насыщенных свинцом); одежду из фланели и поплина; делают побелку стен и потолка (ослабляет на 45-50%).




8. Заключение

В данной дипломной работе рассмотрены основные протоколы VPN на которых строятся шифрованные туннели. 

Раздел 1.1. посвящен обзору протоколов VPN соединений. 

Раздел 1.2. посвящен обзору программного обеспечения для реализации VPN соединений.

Раздел 1.3. посвящен обзору средств виртуализации для создания виртуальной среды.

На основе разделов 1.1-1.3 был сделан выбор реализуемых протоколов и программного обеспечения.

В качестве реализуемых протоколов были выбраны:

IPSec.

PPTP.

L2TP.

В качестве используемой серверной ОС была выбрана FreeBSD. За счет поддержки программного обеспечения MPD5 и протокола IPSec на уровне ядра.

Для реализации виртуальной среды выбран программный пакет VirtualBox. Обоснование выбора содержится в разделе 1.3.3. (выбор средства виртуализации).

В результате выполнения дипломной работы была реализована виртуальная среда для работы с VPN соединениями. Готовая виртуальная среда представляет собой совокупность виртуальных машин с реализованными протоколами VPN и настроенными на взаимодействие друг с другом. Виртуальные машины записаны на внешнем носителе (жестком диске).

Для работы с виртуальной средой создана инструкция оператора (см. ПРИЛОЖЕНИЕ 1). Данная инструкция содержит набор всех необходимых сведений для работы с VPN протоколами и их настройке.




Список используемой литературы

Олифер В. Г.,Олифер Н. П. Компьютерные сети. Принципы, технологии, протоколы. — 4-е. — СПб: Питер, 2010

Andrew Mason. . — Cisco Press, 2002.

, № ,  — Мы начинаем VPN. Игорь Орещенков

Маркус Feilner  — Издательство: Packt Publishing — 11 мая, 2006.

Ссылки на Web-источники

http://tools.ietf.org/html/ —  сайт с описанием RFC стандартов.

https://ru.wikipedia.org/wiki/IPsec — статья "IPSec".

http://fandi.ru/development/freebsd-ipsec/#link8 — статья “Удаленный доступ к FreeBSD из Win XP по IPSec”.

http://www.freebsd.org/doc/ru/books/handbook/ipsec.html — глава 15.10.”VPN через Ipsec”.

https://ru.wikipedia.org/wiki/PPTP — статья "PPTP".

http://kunegin.narod.ru/ref5/ipsec/doc05.htm — Статья "PPTP".

https://ru.wikipedia.org/wiki/L2tp —  статья "L2TP".

http://book.itep.ru/4/44/l2pr.htm — глава "Протокол туннелей на сетевом уровне L2 (L2TP) ".

http://homenet.beeline.ru/index.php?showtopic=254605 — Статья "FreeBSD 8.0 Mpd5 l2tp client".

http://ru.wikipedia.org/wiki/Multi-link_PPP_daemon — статья "MPD".

http://www.lissyara.su/articles/freebsd/security/vpn_mpd5/ — статья "Установка VPN сервера mpd5 + сжатие и шифрование".

http://wiki.lissyara.su/wiki/Перевод_документации_по_mpd5/ — Статья "Перевод документации по MPD5".

http://ru.wikipedia.org/wiki/OpenVPN — статья "OpenVPN".

http://www.lissyara.su/articles/freebsd/security/openvpn/ — статья "Openvpn + FreeBSD".

http://lithium.opennet.ru/articles/openvpn/openvpn-howto.html#scope — статья "OpenVPN HOWTO".

http://ru.wikipedia.org/wiki/VirtualBox — статья "VirtualBox".

http://www.ixbt.com/cm/virtualization-virtualbox.shtml — Александр Самойленко. "Открытая платформа виртуализации VirtualBox".

http://ru.wikipedia.org/wiki/VMware — статья "VMware".


ПРИЛОЖЕНИЕ 1. Инструкция оператора по настройке и управлению виртуальной средой

Данный раздел содержит методические указания по настройке и управлению виртуальной средой. В методических указаниях рассмотрены процессы установки, настройки, проверки соединений по каждым из протоколов VPN:

OpenVPN.

PPTP.

L2TP.

IPSec.

Каждый из перечисленных разделов подробно описывается и содержит практические указания для работы с каждым из протоколов.




Московский институт электроники и математики НИУ ВШЭ

Кафедра Информационно-коммуникационных технологий



































ИНСТРУКЦИЯ ОПЕРАТОРА ПО НАСТРОЙКЕ И УПРАВЛЕНИЮ ВИРТУАЛЬНОЙ СРЕДОЙ























































Москва, 2013


Аннотация

Настоящее руководство предназначено для изучения студентами основ создания и настройки шифрованных VPN соединений. Даны подробные инструкции и примеры настройки программного обеспечения для работы с протоколами:

IPSec

PPTP

L2TP

Инструкция оператора даст возможность студентам магистратуры глубже изучить тематику построения защищенных VPN соединений.







1. Назначение виртуальной среды

Виртуальная среда предназначена для освоения студентами протоколов зашифрованных VPN-соединений и получения студентами практических навыков по работе с ними.

2. Условия корректной работы виртуальной среды

Для работы виртуальной среды необходимо, чтобы корневая машина имела одну из операционных систем:

Windows XP/Windows 7/Windows 8

Ubuntu/Debian/Arch или другой поддерживающий VirualBox дистрибутив Linux

Mac OS

Помимо требований к ОС, есть минимальные аппаратные требования (для работы без GUI-интерфейса):

Процессор: Intel core i7

ОЗУ: 16 Gb

Место на жестком диске: 67Gb

Объем видео памяти: 512Mb

Рекомендуемые аппаратные требования (для работы с GUI интерфейсом):

Процессор: AMD Fx(tm)-8350 Eight-Core Processor

ОЗУ: 32 Gb

Место на жестком диске: 67Gb

Объем видео памяти: 2Gb

3. Работа виртуальной среды

Работа виртуальной среды зависит от следующий условий:

Наличие программы Virtualbox

Наличие образов виртуальных машин

3.1 Установка программы Virtualbox

3.1.2 Windows

Установка в операционной системе Windows очень проста. Необходимо перейти на официальный сайт загрузки программы:



Далее, необходимо нажать на ссылку загрузки для Windows.

После загрузки установочного пакета, необходимо запустить его и следовать инструкциям установщика. Установка происходит в несколько кликов и очень проста. После установки, следует запустить программу и вы увидите окно с дружественным интерфейсом.

3.1.3 Linux Ubuntu

Для установки Virtualbox в ОС Linux Ubuntu необходимо запустить терминал и ввести команду на установку:

sudo apt-get install virtualbox

Эта команда позволит автоматически установить программу со всеми зависимостями, необходимыми для её нормальной работы. 

Для запуска программы необходимо ввести в терминале virtualbox или запустить её из главного меню операционной системы.

3.1.4 FreeBSD

Для установки программы необходимо сперва обновить коллекцию портов командами:

portsnap fetch 

portsnap extract

Первая команда скачивает новое дерево портов, а вторая, в свою очередь, его извлекает. Очень важно чтобы порты были свежими, т.к. это может повлиять на актуальность версии программы. Если дерево портов не обновлено, то версия программы может быть устаревшей.

Теперь необходимо перейти в каталог, содержащий саму программу и дать команду на компиляцию модулей ядра для virtualbox и самой программы:

cd /usr/ports/emulators/virtualbox-ose-kmod

make install clean

cd /usr/ports/emulators/virtualbox-ose

make install clean

Примечание: т.к. чаще всего ОС FreeBSD используют без графического окружения, то и Virtialbox стоит ставить без поддержки графики (опции QT4, X11), как показано на рисунке 1.1

                                                          Рисунок 1.1 Опции сборки Virtualbox

После установки, необходимо добавить запуск модулей при старте системы:

echo vboxdrv_load="YES" >> /boot/loader.conf

Эта команда добавит в файл loader.conf опцию загрузки драйверов Virtualbox модулем.

В файл /etc/rc.conf необходимо добавить строку, для автозапуска Virtualbox добавляем:

vboxnet_enable="YES"

Теперь нужно переназначить каталоги для хранения файлов самих виртуальных машин:

mkdir /home/setevoy/VMs


chmod -R 777 /home/setevoy/VMs/


VBoxManage setproperty machinefolder /home/setevoy/VMs/

Первая команда – создает каталог VMs в домашнем каталоге пользователя. Этот путь может быть изменен на любой другой.

Вторая команда – назначает права доступа 777(разрешить всем писать, удалять файлы) на только что созданный каталог VMs.

Третья команда – задает папку для хранения Virtualbox’ом виртуальных машин.

Далее, необходимо перезагрузить компьютер. После перезагрузки Virtualbox должен запуститься в фоновом режиме и ожидать команд пользователя. 

Ознакомиться с подробным списком консольных команд VIrtualbox можно по адресу:



На этом ресурсе находится перевод документации по работе с Virtualbox и команды для работы без GUI-интерфейса.




3.2 Импорт виртуальных машин.

Виртуальная среда не может быть функционировать без виртуальных машин, созданных и настроенных для реализации схем: сеть-сеть, хост-сеть, хост-хост. Импорт должен производиться с носителя, приложенного к данному руководству. Носителем является жесткий диск, в корне которого расположены 12 виртуальных машин.

Импорт производится нажатием кнопок Файл->Импорт конфигураций; или сочетанием горячих клавиш ctrl+I (рис. 1.2).

                 Рисунок 1.2 Импорт конфигураций виртуальных машин

После импорта конфигураций, будет список из виртуальных машин, перечисленных в таблице 1.











Таблица 1. Список импортированных виртуальных машин



Виртуальные машины в таблице 1, принадлежат к разным моделям соединений. Существуют следующие модели:

Модель сеть-сеть. Включает в себя виртуальные машины: Server_1, Client_1_1, Client_1_2, Client_1_3, Server_2, Client_2_1, Client_2_2, Client_2_3. Модель реализуется посредством протокола OpenVPN. 

Модель хост-сеть. Включает в себя виртуальные машины: Server_1, Client_1_1, Client_1_2, Client_1_3, Server_2, Client_2_1. Модель реализуется посредством протокола OpenVPN.

Модель хост-сеть. Включает в себя виртуальные машины: Server_1, Client_1_1, Client_1_2, Client_1_3, Server_2, Client_2_2. Модель реализуется посредством протокола PPTP.

Модель хост-хост. Включает в себя виртуальные машины: FreeBSD_L2tp_client, FreeBSD_L2tp_server. Модель реализуется посредством протокола L2TP.

Модель сеть-сеть. Включает в себя виртуальные машины: FreeBSD_IPSec_client, FreeBSD_IPSec_server. Модель реализуется посредством протокола IPSec.

4. Указания по настройке и работе с протоколами

Примечание: В работе при соединении серверов в режиме “мост” с корневой машиной серверам выдаются IP-адреса, используемые ниже, как “внешние”. При переносе и запуске виртуальных машин важно понимать, что выдаваемые адреса при смене корневой машины могут быть отличны от тех, что используются в этом методическом указании.

В работе серверами Server_1, FreeBSD_L2TP_server, FreeBSD_IPSEC_server используется “внешний” IP-адрес 192.168.5.23, а серверами Server_2, FreeBSD_L2TP_client, FreeBSD_IPSEC_client используется “внешний” IP-адрес 192.168.5.21.

4.1 Настройка OpenVPN для модели “сеть-сеть”

4.1.1 Настройка сервера Server_1 для работы с openvpn.

Будем настраивать сервер Server_1 в качестве сервера для реализации схемы сеть-сеть (рис. 1.3). В качестве openvpn-клиента будет выступать другой сервер – Server_2. Перейдем к настройке Server_1. 



Рисунок 1.3 Схема соединения сеть-сеть по протоколу OpenVPN

4.1.2 Установка OpenVPN

Обновляем порты до текущей версии:

portsnap fetch

portsnap extract

Переходим в католог, в котором находится OpenVPN и даем команду на сборку пакета:

cd /usr/ports/security/openvpn22/

make install clean

Дожидаемся пока скомпилируется openvpn. Во всех всплывающих окнах оставляем параметры по-умолчанию.

4.1.3 Создание сертификата для сервера

Для создания сертификатов, необходимо отредактировать файл vars, который загружает переменные окружения и файлы настроек, необходимые для создания сертификатов и ключей.

cd /usr/local/share/doc/openvpn/easy-rsa/2.0/

Открываем файл vars любым текстовым редактором (например, nano):

nano vars

Далее, необходимо отредактировать файл в соответствии с нуждами, а именно:

меняем строку KEY_DIR=$EASY_RSA/keys на KEY_DIR=$ EASY_RSA /keys/server 

Это необходимо, для того, чтобы все созданные ключи лежали в каталоге /keys/server. Для порядка.

Так же, устанавливаем значения следующих переменных:

export KEY_COUNTRY="RU"


export KEY_PROVINCE="City"


export KEY_CITY="Moscow"


export KEY_ORG=" MIEM "


export KEY_EMAIL="Kuzmishchev@yandex.ru "


export KEY_CN=changeme


export KEY_NAME=changeme


export KEY_OU=institute

Значения каждой переменной представлены в таблице 2.

Таблица 2. Значения переменных файла vars



Изменение файла необходимо для того, чтобы при запуске скриптов, создающих сертификаты, были подставлены нужные значения. После чего из файла vars вам необходимо экспортировать заданные переменные, делаем файл vars и другие необходимые для создания ключей скрипты исполняемыми и выполняем его (желательно из шелла sh):

sh

 chmod +x vars


 chmod +x build-ca


 chmod +x clean-all


 chmod +x pkitool


 chmod +x vars


 chmod +x whichopensslcnf

. ./vars

Примечание: две точки в строке “. ./vars ” - это не опечатка.

Если все было сделано правильно, то вы увидите следующее сообщение:

NOTE: If you run ./clean-all, I will be doing a rm -rf on /usr/local/share/doc/openvpn/easy-rsa/2.0/server

Теперь очищаем от старых сертификатов и ключей папку:

./clean-all

Если при этом будет какое то сообщение:

Please source the vars script first (i.e. "source ./vars")


Make sure you have edited it to reflect your configuration.

Это значит, что вы допустили ошибку и переменные из файла vars не загружены. Необходимо проверить правильность внесенных изменений.

	Далее, необходимо создать Certificate Authority (центр сертификации) для сервера:

./build-ca

После ввода этой команды, скрипт будет задавать нам вопросы относительно создания центра сертификации пользователей, для наглядности, ниже приведен снимок экрана виртуальной машины сервера (рис. 1.4):



Рисунок 1.4 Создание центра сертификации для сервера

После выполнения выше приведенного действия, в папке keys/server появятся два новых файла ca.key и ca.crt.

Создаем сертификат X.509 для сервера с помощью скрипта build-key-server. Действия аналогичны созданию центра сертификации. Заполняем поля точно так же. Поля с паролями оставляем пустыми(!). В конце будет предложено подписать созданный сертификат – соглашаемся.

./build-key-server server

Ниже (рис. 1.5), представлен снимок экрана виртуальной машины, начиная с момента ввода пароля:



Рисунок 1.5 Создание ключа для сервера

4.1.4 Создание сертификата для клиента

Сертификат для клиента создается скриптом build-key, в качестве аргумента ему передается имя сертификата (как и в случае со скриптом build-key-server рис. 1.5):

./build-key client

В данном действии важно, указывая common name, помнить, что это поле должно быть отличным от server, т.к. common name – это имя-идентификатор, и оно должно быть отлично от ранее созданных и совпадать с именем сертификата, которое мы передаем скрипту build-key.

4.1.5 Создание ключа Диффи-Хеллмана

Ключ Диффи-Хеллмана - позволяет двум или более пользователям обменяться без посредников ключом, который может быть использован затем для симметричного шифрования.

Данный алгоритм не применяется для шифрования сообщений или формирования электронной подписи. Его назначение – в распределении ключей. 

Ключ Диффи-Хеллмана создается скриптом build-dh.

./build-dh

	На рисунке 1.6, результат выполнения скрипта build-dh:



Рисунок 1.6 Создание ключа Диффи-Хеллмана

	Подробнее об алгоритме Диффи-Хеллмана можно почитать на сайте Википедии:



	Итак, в папке /usr/local/share/doc/openvpn/easy-rsa/2.0/keys/server мы должны увидеть новые файлы (рис.1.7):



Рисунок 1.7 Список файлов каталога /keys/server

Из всех этих файлов, серверу достанутся: ca.crt, dh1024.pem, server.crt, server.key.

Клиент получит следующие файлы: client.key, client.crt, dh1024.pem.

4.1.6 Создание Tls-ключа

Этот ключ необходим для TLS аутентификации клиентов на сервере. Он создается в одном экземпляре и передается клиентам. Для его создания, необходимо в каталоге /usr/local/share/doc/openvpn/easy-rsa/2.0/keys/server выполнить следующую команду:

openvpn --genkey --secret ta.key

После этого, в директории появится файл ta.key. 

Примечание: файл ta.key так же необходимо передавать клиенту, т.к. без него клиент не пройдет аутентификацию.

4.1.7 Настройка сервера OpenVPN

Теперь необходимо определиться с каталогом, в котором будет запускаться openvpn. Создадим его:

mkdir /usr/local/etc/openvpn

Перейдя в этот каталог, создадим еще два:

cd /usr/local/etc/openvpn

mkdir ccd

mkdir keys

Где:

ccd – client config directory (папка, с файлами настроек для клиентов); 

keys – папка с ключами.

Теперь, когда у нас есть все необходимые фалы, переносим в папку /usr/local/etc/openvpn/keys содержимое папки /usr/local/share/doc/openvpn/easy-rsa/2.0/keys/server:

cp ca.crt ta.key dh1024.pem server.crt server.key /usr/local/etc/openvpn/keys

Создаем конфигурационный файл сервера server.ovpn в директории /usr/local/etc/openvpn следующего содержания: 

# порт на котором работает сервер

port 2000

# протокол обмена данными

proto tcp

# - используемый тип устройства и его номер 

dev tun0

# указываем файл CA

ca /usr/local/etc/openvpn/keys/ca.crt

# указываем файл с сертификатом сервера

cert /usr/local/etc/openvpn/keys/server.crt

# указываем файл с ключем сервера

key /usr/local/etc/openvpn/keys/server.key

# указываем файл с ключем Диффи Хелмана

dh /usr/local/etc/openvpn/keys/dh1024.pem

# для дополнительной безопасности при

# использовании TLS, создайте файл ta.key

# для защиты от DoS атак и атак на порты.

# сгенерируйте с помощью следующей команды ключ:

#

#   openvpn --genkey --secret ta.key

#

# сервер и каждый клиент должны иметь копию этого ключа.

# второй параметр (tls-auth) выставляется в '0' для сервера и '1' для клиентов.

tls-server

tls-auth keys/ta.key 0

# задаем IP-адрес сервера и маску подсети

# (виртуальной сети) - можно произвольную, 

server 10.10.10.0 255.255.255.0

# задаем МАРШРУТ, который передаём клиенту

# и маску подсети для того, чтобы он "видел"

# сеть за openvpn сервером (сеть 192.168.1.0/24)

push "route 192.168.100.0 255.255.255.0"

# указываем, где хранятся файлы с

# настройками IP-адресов клиентов

client-config-dir ccd

# добавляем маршрут на сеть за клиентом

route 192.168.200.0 255.255.255.0

# включаем шифрование пакетов

cipher BF-CBC

# проверка связи каждые 10 секунд. Если в течении 120

# секунд ответа нет, то считается что соединение прервано

keepalive 10 120

# включаем сжатие трафика

comp-lzo

# максимальное количество клиентов

max-clients 2

persist-key

# не закрывать и переоткрывать TUN\TAP

# устройство, после получения

# сигнала SIGUSR1 или команды ping-restart

persist-tun

# логирование (не забудьте создать этот каталог /var/log/openvpn/)

status /var/log/openvpn/openvpn-status.log

log /var/log/openvpn/openvpn.log

# Уровень информации для отладки

verb 3

Теперь необходимо создать файл настроек для клиента (ccd/client):

ifconfig-push 10.10.10.2 10.10.10.1

iroute 192.168.200.0 255.255.255.0

На этом настройка сервера закончена. Остается добавить в главный конфигурационный файл /etc/rc.conf строки для автоматического запуска openvpn сервера:

openvpn_enable="YES" # YES or NO

openvpn_if="tun" # какой драйвер загружать, можно установить "tun", "tap" или "tun tap"

openvpn_configfile="/usr/local/etc/openvpn/server.ovpn" # путь к конфигурационному файлу

openvpn_dir="/usr/local/etc/openvpn" # каталог с настройками

	После перезагрузки сервер должен запуститься. Если этого не произошло, то необходимо смотреть лог-файлы и искать неисправность. При успешном запуске сервера, команда ifconfig tun0 должна вывести следующий результат:

Рисунок 1.8 Результат команды ifconfig tun0 на Server_1

4.1.4 Настройка Server_2 для работы с openvpn

	Вся последовательность действий по настройке openvpn на сервере Server_2 совпадает с действиями по настройке сервера Server_1 с тем отличием, что для Server_2 будет использоваться другой файл конфигурации, который необходимо создать. 

4.1.5 Настройка клиента

Создадим конфигурационный файл client.ovpn в папке /usr/local/etc/openvpn со следующим содержанием:

dev tun0

proto tcp

remote 192.168.5.23# реальный IP сервера Server_1

port 2000 # порт по которому устанавливать соединение

client

ca keys/ca.crt

cert keys/client.crt

key keys/client.key

tls-client

tls-auth keys/ta.key 1

cipher BF-CBC

comp-lzo

persist-key

persist-tun

verb 3

	После этого, необходимо скопировать с сервера Server_1 ключи и сертификаты для клиента в директорию /usr/local/etc/openvpn/keys. Нам нужны следующие файлы: ca.crt, ta.key, dh1024.pem, client.key, client.crt.

	Так же, как и в случае с Server_1, добавляем в главный конфигурационный файл /etc/rc.conf сервера Server_2 добавляем строки:

openvpn_enable="YES" # YES or NO

openvpn_if="tun" # какой драйвер загружать, можно установить "tun", "tap" или "tun tap"

openvpn_configfile="/usr/local/etc/openvpn/client.ovpn" # путь к конфигурационному файлу

openvpn_dir="/usr/local/etc/openvpn" # директория с настройками

	После перезагрузки, можно проверить работоспособность туннеля. Первым делом, проверим состояние виртуального интерфейса tun0, отвечающего за openvpn соединение. Делаем ifconfig tun0 на сервере Server_2 (рис. 1.9):

Рисунок 1.9 Результат команды ifconfig tun0 на Server_2

	По результату команды видно, что поднят туннель между сервером Server_1 и Server_2. Об этом свидетельствуют адреса, выдаваемые на tun-интерфейсах. Server_1 получает адрес 10.10.10.1 (рис 1.8), а Server_2 получает адрес 10.10.10.2 (рис. 1.9). Теперь, необходимо убедиться в работоспособности туннеля. Проверим это командой ping с сервера Server_2 (рис. 1.10):

                    Рисунок 1.10 результат команды ping сервера Server_2 (по внутреннему адресу туннеля)

	По результату видно, что обмен пакетами по внутренним адресам туннеля производится без проблем. Теперь, посмотрим что покажет tcpdump. 

Запустим tcpdump на интерфейсе tun0 сервера Server_1. В свою очередь, на сервере Server_2 будем обмениваться пакетами с помощью команды ping с сервером Server_1 по адресу локальной сети, за которую он отвечает (рис. 1.11). Для этого, на сервере Server_1 введем команду:

tcpdump –i tun0

	А на сервере Server_2 начинаем обмен пакетами с Server_1:

ping 192.168.100.1

                                 Рисунок 1.11 результат работы tcpdump и ping

	По результатам на рисунке 1.11 очевидно, что vpn туннель поднят и соединяет две сети.

4.2 Настройка OpenVPN для модели “хост-сеть”

4.2.1 Настройка Server_1 для работы с openvpn.

Выше был приведен пример создания сертификата для клиента. Для реализации схемы хост-сеть (рис. 1.12) необходимо создать новый сертификат и файл настроек на Server_1 для клиента с именем host, в роли которого выступает Client_2_1.

Рисунок 1.12 схема хост-сеть OpenVPN

Создание файла настроек для клиента host на Server_1:

#cd /usr/local/etc/openvpn/ccd

#touch host

Теперь открываем созданный файл, и добавляем в него строку:

ifconfig-push 10.10.10.6 10.10.10.5

Эта строчка говорит: настроить виртуальный адаптер tun0 на IP-адрес 10.10.10.6 и маску 255.255.255.252. Сохраняем изменения. 

Теперь необходимо создать сертификат и ключ для клиента:

#./build-key host

	Важно не забыть при заполнении полей (как на рис 1.4 ) в поле common name внести host. Host – как и в случае соединения сеть-сеть, является именем-идентификатором и не должно совпадать с другими именами. 

4.2.2 Настройка openvpn в Ubuntu Linux

Примечание: Для полной правдоподобности эксперимента и исключения конфликтов в сетевой адресации, рекомендуется во время проверки работоспособности openvpn туннеля отключить в настройках виртуальной машины Client_2_1 сетевой адаптер, настроенный на внутреннюю сеть и включить второй сетевой адаптер, настроенный на соединение типа мост с корневой машиной.

Запускаем клиентскую машину, и открываем терминал, как показано на рисунке:

                         Рисунок 1.13 терминал на хосте Client_2_1

	Далее, необходимо установить openvpn. Для этого необходимо выполнить следующую команду:

sudo apt-get update

sudo apt-get install openvpn

	После этого необходимо перейти в каталог /etc/openvpn и создать в ней папку keys и конфигурационный файл с именем host.conf:

cd /etc/openvpn/

sudo mkdir keys

sudo touch host.conf

	В папке keys будут храниться ключ и сертификат (host.key и host.crt) созданные на Server_1. Так же, в неё необходимо переместить с сервера Server_1 файлы ta.key, ca.crt и dh1024.pem.

	Для обмена файлами между виртуальными машинами был настроен ftp-server на корневой машине (на которой запущен VirtualBox). Т.к. Server_1 и Server_2 связаны с сетевым адаптером корневой машины соединением типа “мост”, то они могут обмениваться файлами между собой, находясь в одной сети с корневой машиной.

	После скачивания в папку keys файлов ca.crt, dh1024.pem, ta.key, host.key, host.crt с ftp-сервера корневой машины, необходимо отредактировать созданный конфигурационный файл /etc/openvpn/host.conf. 

	Приводим его к следующему виду:

dev tun0

proto tcp

remote 192.168.5.23

port 2000

client

ca /etc/openvpn/keys/ca.crt

cert /etc/openvpn/keys/host.crt

key /etc/openvpn/keys/host.key

dh /etc/openvpn/keys/dh1024.pem

tls-client

tls-auth /etc/openvpn/keys/ta.key 1

ns-cert-type server

cipher BF-CBC

comp-lzo

persist-key

persist-tun

log /var/log/openvpn.log

verb 3

	После сохранения изменений в конфигурационном файле необходимо перезапустить openvpn сервис. В Ubuntu это делается так:

#sudo service openvpn restart

И, если все прошло удачно, то вы будете получать PING reply от сервера Server_1 с ip адресом 10.10.10.1 (openvpn тунель) и 192.168.100.1 (внутренняя сеть за Server_1 рис. 1.12).

	Результат команды ifconfig tun0 хоста Client_2_1:

                       Рисунок 1.14 результат команды ifconfig на хосте Client_2_1

	Результат команды ping 10.10.10.1 на хосте Client_2_1:

                        Рисунок 1.15 результат команды ping Server_1(по адресу внутри туннеля) на хосте Client_2_1

	Результат команды ping 192.168.100.1 на хосте Client_2_1:

                        Рисунок 1.16 результат команды ping сервера Server_1(по адресу сети) на хосте Client_2_1

	Результат команды ping 192.168.100.10 (при условии что запущен Client_1_1) на машине Client_2_1:

                                                  Рисунок 1.17 результат команды ping хоста Client_1_1 на хосте Client_2_1

	По результатам команды ping видно, что openvpn туннель работает. Так же, можно запустить во время работы команды ping утилиту tcpdump либо на хосте Client_2_1, либо на сервере Server_1. Результатом её работы будет как на рисунке 1.18:

                                        Рисунок 1.18 результат работы tcpdump на сервере Server_1

4.3 Настройка PPTP для модели хост-сеть

Будет реализована схема на рисунке 1.19

Рисунок 1.19 соединение хост-сеть по протоколу PPTP

Примечание: Чтобы не загромождать комментариями конфигурационные файлы серверов и клиентов в данном методическом указании, рекомендуется обратиться к ресурсу:

 

На этом ресурсе находится подробный перевод документации по программному продукту MPD5 и точные разъяснения значений всех используемых опций

4.3.1 Установка MPD5 на сервере Server_1 и настройка для работы с PPTP

Первым делом, необходимо обновить порты до последней версии. Это делается командами:

portsnap fetch

portsnap extact

Далее устанавливаем MPD5.

cd /usr/ports/net/mpd5

make install clean

Теперь, необходимо создать два файла: файл конфигурации сервера (mpd.conf) и файл в котором будут храниться пары логин и пароль (mpd.secret).

/usr/local/etc/mpd5/> touch mpd.conf

/usr/local/etc/mpd5/> touch mpd.secret

После этого, открываем текстовым редактором nano конфигурационный файл mpd.conf и приводим его к следующему содержанию:

nano /usr/local/etc/mpd5/mpd.conf



startup:

# Задаем пароль для доступа в web-intarface

# т.е меняем password на свой пароль

        set user admin password admin

# set user password cancer

# Настраиваем порт на доступ к консоли управления mpd

        set console self 127.0.0.1 5005

        set console open

# Настройка web-интерфейса

        set web self 0.0.0.0 5006

        set web open

#Описываем шаблон по умолчанию

default:

        load pptp_server

#Описываем шаблон pptp_server

pptp_server:

# Определяем диапазон выдаваемых удалённым клиентам IP-адресов

# Пусть они будут с ...50 по ...99

        set ippool add poolsat 192.168.7.50 192.168.7.99

        create bundle template B

        set iface enable proxy-arp

        set iface idle 0

        set iface enable tcpmssfix

        set ipcp yes vjcomp

# IP адрес сервера, который мы будем показывать клиентам

        set ipcp ranges 192.168.7.1/32 ippool poolsat

# Здесь указываем DNS сервер

        set ipcp dns 8.8.8.8

# Включение Microsoft Point-to-Point шифрования (MPPE)

        set bundle enable compression

        set ccp yes mppc

        set mppc yes compress e40 e56 e128 stateless

# Create clonable link template named L

        create link template L pptp

# Set bundle template to use

        set link action bundle B

# Multilink adds some overhead, but gives full 1500 MTU

        set link enable multilink

        set link yes acfcomp protocomp

        set link no pap chap eap

        set link enable chap

        set link enable chap-msv1

        set link enable chap-msv2

# We reducing link mtu to avoid GRE packet fragmentation.

        set link mtu 1460

        set link keep-alive 10 60

# Configure PPTP and open link

# Тут указывается IP сетевой карты или имя интерфейса (em0) смотрящего в интернет

        set pptp self 192.168.5.23

# Allow to accept calls

        set link enable incoming

Примечание: Важно, чтобы файл настроек был без пробелов(!). MPD не любит пробелы. Рекомендуется вместо пробелов использовать TAB.

Записываем в файл mpd.secret логины и пароли для доступа к MPD-серверу:

nano /usr/local/etc/mpd5/mpd.secret



User1		123321		192.168.7.90

Теперь, необходимо добавить строки в syslog.conf для того чтобы можно было смотреть логи MPD-сервера:

nano /etc/syslog.conf



!mpd

*.*						/var/log/mpd.log

Перезапускаем syslogd:

/etc/syslogd restart

И добавляем mpd в автозапуск

echo 'mpd_enable="YES"' >> /etc/rc.conf

Теперь можно запустить mpd5:

/usr/local/etc/rc.d/mpd5 start

Если будет выводиться сообщение об ошибке, то необходимо открыть логи и искать неисправность. На этом настройка MPD5 в качестве pptp-сервера закончена.

4.3.2 Настройка PPTP клиента в Ubuntu linux 

Для создания PPTP соединения в Ubuntu linux не нужно устанавливать никаких дополнительных программных пакетов. В Ubuntu уже включен по умолчанию пакет NetworkManager. Он позволяет управлять сетью в графической среде GNOME в Ubuntu linux. У NetworkManager’a есть плагин network-manager-pptp, который так же по умолчанию включен в ОС Ubuntu linux и позволяет создавать pptp-соединения с сервером без особого труда.

Для создания pptp-соединения необходимо щелкнуть правой кнопкой мыши по значку с сетью (верхний правый угол экрана), выбрать пункт “Соединения VPN” -> “Настроить VPN…” как показано на рисунке 1.20.  Далее, необхдим оперейти во вкладку VPN, нажать кнопку “добавить”. Выбрать “Microsoft point-to-point protocol” и заполнить форму, как показано на рисунке 1.20. 

В поле “Шлюз” заносим  внешний адрес сервера Server_1 (в нашем случае это ip 192.168.5.23).

В поля “Имя пользователя” и “Пароль” вводим данные, которые сохраняли в файле mpd.secrets (см. п. 4.3.1) и нажимаем кнопку “Сохранить”.

Рисунок 1.20 Настройка PPTP-соединения в Ubuntu linux

На этом настройка PPTP-соединения закончена. Можно щелкнуть правой кнопкой мыши по созданному подключению, и должна появиться надпись как показано на рисунке 1.21:

                              Рисунок 1.21 сообщение авторизации

Теперь можно открыть терминал и протестировать работоспособность PPTP-туннеля. Для начала, посмотрим появилось ли у нас соединение ppp0:

ifconfig ppp0

Результат показан на рисунке 1.22:

Рисунок 1.22 результат команды ifconfig на хосте Client_2_2

На рисунке 1.22 видно, что появилось новое соединение ppp0, адрес, выданный клиенту – 192.168.7.90, адрес шлюза – 192.168.7.1.

Будем с хоста Client_2_2 делать ping хоста Client_1_1 за сервером Server_1. Пусть в это время на сервере Server_1 работает tcpdump интерфейса ng0, созданного сервером mpd. Результат этих действий на рисунке 1.23:

                                         Рисунок 1.23 результат работы ping и tcpdump

На рисунке 1.22 видно, что обмен пакетами в туннеле происходит корректно. PPTP-туннель работает.

4.4 Настройка L2TP для модели хост-хост

Будет реализована схема на рис 1.24

Рисунок 1.24 соединение хост-хост по протоколу L2TP

4.4.1Настройка сервера FreeBSD_L2TP_server в качестве L2TP-сервера

Для настройки протокола L2TP необходим установленный программный пакет MPD5, процесс установки которого описан в пункте 4.3.1. Вся настройка MPD5 для работы в качестве L2TP сервера сводиться к тому, что просто редактируется файл mpd.conf до следующего вида:

startup:

        set user foo bar admin

        set user foo1 bar1

        set console self 127.0.0.1 5005

        set console open

        set web self 0.0.0.0 5006

        set web open

default:

        load l2tp_server

l2tp_server:

# Создаем диапазон присваеваемых IP адрессов.

# Define dynamic IP address pool.

        set ippool add pool1 10.10.0.5 10.10.0.100

# Create clonable bundle template named B

        create bundle template B

        set iface enable proxy-arp

        set iface idle 1800

        set iface enable tcpmssfix

        set ipcp yes vjcomp

# Specify IP address pool for dynamic assigment.

        set ipcp ranges 10.10.0.1/24 ippool pool1

        set ipcp dns 10.10.0.1

# The five lines below enable Microsoft Point-to-Point encryption

# (MPPE) using the ng_mppc(8) netgraph node type.

        set bundle enable compression

        set ccp yes mppc

        set mppc yes e40

        set mppc yes e128

        set mppc yes stateless

# Create clonable link template named L

        create link template L l2tp

# Set bundle template to use

        set link action bundle B

# Multilink adds some overhead, but gives full 1500 MTU.

        set link enable multilink

        set link yes acfcomp protocomp

        set link no pap chap

        set link enable chap

        set link keep-alive 10 60

# We reducing link mtu to avoid GRE packet fragmentation

        set link mtu 1460

# Configure l2tp

# IP адресс нашего VPN сервера. (Собственно адресс машины с фряхой)

        set l2tp self 192.168.222.1

# Allow to accept calls

        set link enable incoming

Сохраняем изменения и редактируем уже файл с паролями (mpd.secret):

test	testpass		10.10.0.5

Добавляем mpd в автозапуск

echo 'mpd_enable="YES"' >> /etc/rc.conf

Теперь можно запустить mpd5:

/usr/local/etc/rc.d/mpd5 start

Если будет выводиться сообщение об ошибке, то необходимо открыть логи и искать неисправность.

Этими действиями мы настроили MPD5 на работу в режиме L2TP сервера. 

4.4.2 Настройка сервера FreeBSD_L2TP_client в качестве L2TP-клиента

Для того чтобы MPD5 работал в качестве L2TP-клиента, необходимо привести файл конфигурации mpd.conf к следующему виду:

startup:

default:
        load MIEM_L2TP


MIEM_L2TP:
        create bundle static L2TP
        set bundle disable compression
        set bundle disable round-robin
        set bundle disable encryption
        set bundle disable crypt-reqd
        set bundle disable bw-manage
        set bundle disable ipv6cp
        set bundle enable ipcp
        set ipcp no vjcomp
        set iface mtu 1460
        set iface idle 0
        set iface enable tcpmssfix

# пути к скриптам настроек для соединения
        set iface up-script /usr/local/etc/mpd5/up.sh
        set iface down-script /usr/local/etc/mpd5/down.sh
        create link static L2 l2tp
        set link action bundle L2TP
        set link latency 0
        set link max-redial 0
        set link disable incoming acfcomp protocomp magicnum check-magic shortseq
        set link deny chap-msv2 chap-msv1 pap eap acfcomp protocomp shortseq
        set link accept chap-md5
        set link keep-alive 10 75

# адрес сервера, к которому подключаться
        set l2tp peer 192.168.222.1

#Поля логин и пароль
        set auth authname "test"
        set auth password "testpass"

        open

Теперь, необходимо создать два sh-скрипта, которые будут применять настройки маршрутизации на момент включения интерфейса и его отключения.

Создадим скрипты настроек маршрутизации по-умолчанию при запуске туннеля и его остановке (файлы up.sh и down.sh) и дадим им права на выполнение:

touch /usr/local/etc/mpd5/up.sh

chmod +x /usr/local/etc/mpd5/up.sh

touch /usr/local/etc/mpd5/up.sh

chmod +x /usr/local/etc/mpd5/up.sh

Отредактируем файл up.sh до следующего вида:

#!/bin/sh
# Set gateway
gw=`netstat -rn | awk '$1=="default"{print $2}'`
route delete $4
route add $4 $gw
route delete default
route add default $4
echo $4  > /tmp/mpd_dr
echo $gw > /tmp/mpd_gw

Файл down.sh должен иметь вид:

#!/bin/sh
dr=`cat /tmp/mpd_dr`
gw=`cat /tmp/mpd_gw`
route delete $dr
route delete default
route add default $gw
rm -f /tmp/mpd_dr
rm -f /tmp/mpd_gw

После этих действий можно запускать MPD на сервере FreeBSD_L2TP_client.

Добавляем mpd в автозапуск и запускаем:

echo 'mpd_enable="YES"' >> /etc/rc.conf

/usr/local/etc/rc.d/mpd5 start

Если будет выводиться сообщение об ошибке, то необходимо открыть логи и искать неисправность.

Этими действиями мы настроили MPD5 на работу в режиме L2TP клиента.

Теперь,  необходимо убедиться, что на обоих серверах создано новое сетевое соединение и что сервера могут свободно общаться через L2TP-туннель. Для этого выполним команду ifconfig на обоих серверах. На каждом должно появиться новое устройство ng0, что демонстрирует рисунок 1.25 и 1.26.

Рис. 1.25 ifсonfig на сервере FreeBSD_L2TP_server

Рис. 1.26 ifсonfig на сервере FreeBSD_L2TP_client

Как видно из рисунков 1.25 и 1.26 серверу выдается адрес 10.10.0.1, а клиенту 10.10.0.5.

Теперь, необходимо проверить прохождение пакетов через наш туннель. Будем обмениваться icmp-пакетами с помошью команды ping с сервером FreeBSD_L2TP_server с сервера FreeBSD_L2TP_server. В это время на сервере FreeBSD_L2TP_server будет запущена утилита tcpdump, которая будет прослушивать туннельный адаптер ng0. Рис. 1.27 это демонстрирует.

                                              Рис. 1.27 ifсonfig и tcpdump на серверах FreeBSD_L2TP_client и FreeBSD_L2TP_server

По рисунку 1.27 видно, что туннель работает и пакеты идут. На этом настройка L2TP закончена.




4.5 Настройка IPSec для модели сеть-сеть

Будет реализована схема на рисунке 1.28:

Рис 1.28 соединение сеть-сеть по протоколу IPSec

Примечание: IPSec не работает с NAT. Хотя в официальной документации сказано, что на сегодняшний день реализована возможность работы IPSec через NAT, путем включения в ядро опции:

options IPSEC_NAT_T

Это не так. Нормально данная опция работает только с оборудованием фирмы CISCO. Что к данной модели – не применимо. 

Убедитесь, что в rc.conf отсутствует опция включения NAT.




4.5.1 Включение поддержки IPSec в ядре FreeBSD на серверах FreeBSD_IPSec_server и FreeBSD_IPSec_client

Поддержка IPSec есть в ядре FreeBSD, но по умолчанию она отключена. Для того чтобы её включить, необходимо перекомпилировать ядро ОС со следующими опциями:

options IPSEC – включает поддержку IPSec;

options IPSEC_NAT_T – включает поддержку работы протокола IPSec за NAT;

options IPSEC_FILTERTUNNEL - функция представлена для расширения возможности фильтровать туннелируемые пакеты;

options IPSEC_DEBUG – включает отладочный режим, для подробного отчета в логах;

device crypto – включение поддержки gif интерфейса, через который будет идти зашифрованный трафик.

Для этого создадим свой файл конфигурации ядра в каталоге kernels в домашней директории пользователя server, скопировав его из системного каталога /usr/src/sys/i386/conf/:

mkdir /home/server/kernels

cp /usr/src/sys/i386/conf/GENERIC /home/server/kernels/server

cd /usr/src/sys/i386/conf

ln –s /home/server/kernels/server

Теперь, необходимо открыть его и добавить опции ядра:

nano server

options IPSEC

options IPSEC_NAT_T

options IPSEC_FILTERTUNNEL

options IPSEC_DEBUG

device crypto

Теперь, переходим в каталог /usr/src и даем команду на сборку, установку ядра и последующую перезагрузку.

make buildkernel KERNCONF=server

make installkernel KERNCONF=server

reboot 

После того, как сервера перезагрузятся, необходимо настроить gif интерфейс для создания туннеля, через который будет идти зашифрованный трафик.

4.5.2 Настройка виртуального интерфейса gif

Для настройки gif интерфейсов, необходимо на обоих серверах открыть файл /etc/rc.conf и добавить в него строки:

gif_interfaces=”gif1” # на клиенте – gif0

gifconfig_gif1=192.168.5.23 192.168.5.21 # настраиваем интерфейс на #соединение по реальным IP-адресам.

# на клиенте эта строчка примет вид gifconfig_gif1=192.168.5.21 192.168.5.23

static_routes=”vpn” # заводим статический маршрут под именем vpn

route_vpn=”192.168.55.0/24 –interface gif1” # любой пакет адресованный в #сеть 192.168.55.0/24 будет принудительно проходить через gif-интерфейс.

#на клиенте это выглядело бы так: route_vpn=”192.168.44.0/24 –interface gif0”

export route_vpn # загрузить статический маршрут при каждом запуске сервера.

После добавления этих строк в конфигурационные файлы серверов FreeBSD_IPSec_server и FreeBSD_IPSec_client, необходимо перезагрузить сервера и ввести команду ifconfig gif1 на сервере и ifconfig gif0 на клиенте. Результаты этих команд показаны на рисунке 1.29.

Рис 1.29 результат команды ifconfig gif 1 и ifconfig gif0

Далее, необходимо проверить, работает ли туннель. Если с сервера FreeBSD_IPSec_server делать ping до сервера FreeBSD_IPSec_client, то пакеты должны идти. Рисунок 1.30 демонстрирует это:

                                         Рис 1.30 Обмен пакетами между FreeBSD_IPSec_server и FreeBSD_IPSec_client

После того, как туннель заработал, можно перейти непосредственно к настройке IPSec. Для настройки параметров безопасности (security associations) есть два варианта. Можно настроить их вручную для обоих серверов, задав алгоритм шифрования, ключи для шифрования и так далее, или использовать демоны, реализующие Internet Key Exchange protocol (IKE), который сделает это за нас.

Рекомендуется второе. Помимо прочего, этот способ более прост.

Редактирование и отображение политики безопасности выполняется с помощью setkey. По аналогии, setkey используется для настройки таблиц политики безопасности ядра так же, как route используется для настройки таблиц маршрутизации ядра. Setkey также может отображать текущие параметры безопасности, и продолжая аналогию дальше, это соответствует netstat –r.

Существует множество демонов для управления параметрами безопасности в FreeBSD. Здесь будет описано использование одного из них, racoon — он доступен в составе порта ipsec-tools.

4.5.3 Настройка демона racoon

Даемон racoon должен работать на обоих серверах. На каждом из серверов он настраивается с IP адресом другого конца VPN, и секретным ключом (должен быть одним и тем же на обоих серверах).

Эти два демона подключаются друг к другу, подтверждают, что они именно те, за кого себя выдают (используя секретный ключ, заданный нами). Затем демоны генерируют новый секретный ключ и используют его для шифрования трафика через VPN. Они периодически изменяют этот ключ, так что даже если атакующий сломает один из ключей (что теоретически почти невозможно) это не даст ему слишком много — он сломал ключ, который два демона уже сменили на другой.

Настройки racoon сохраняются в файле /usr/local/etc/racoon/racoon.conf. Другим компонентом настройки racoon, который потребуется изменить, является «предварительный ключ», который racoon ищет в файле /usr/local/etc/raccoon/raccoon.conf.

Необходимо отметить, что предварительный ключ не используется для шифрования трафика через VPN соединение. Это просто маркер, позволяющий управляющим ключами и двум демонам доверять друг другу.

Psk.txt содержит строку для каждого удаленного сервера, с которым происходит соединение. В нашем примере два сервера. Каждый файл psk.txt будет содержать одну строку (каждый конец VPN общается только с другим концом).

На сервере FreeBSD_IPSec_server эта строка будет выглядеть так:

192.168.5.21            hello

То есть публичный IP-адрес противоположной стороны, пробел и текстовая строка c секретной фразой. 

На сервере FreeBSD_IPSec_client эта строка будет выглядеть так:

192.168.5.23            hello

То есть публичный IP адрес удаленной стороны и та же секретная фраза. 

Теперь отредактируем на обоих серверах файл racoon.conf до следующего вида:

path pre_shared_key "/usr/local/etc/racoon/psk.txt"; 

log info; 

padding { 

        maximum_length 20;

        randomize off;    

        strict_check off; 

        exclusive_tail off;

}

listen {

        isakmp 192.168.5.23; # на клиенте будет 192.168.5.21

        strict_address;

#        adminsock "/var/db/racoon/racoon.sock";

}

timer {

        counter 5;

        interval 20 sec;

        persend 1;

        phase1 30 sec;

        phase2 15 sec;

}

remote 192.168.5.21 { # на клиенте будет 192.168.5.23

        exchange_mode aggressive,main;

        lifetime time 24 hour;

        my_identifier address;

        peers_identifier address;

        passive off;

        generate_policy off;

        proposal {

                encryption_algorithm 3des;

                hash_algorithm sha1;

                authentication_method pre_shared_key;

                dh_group 2;

        }

}

sainfo anonymous {

        encryption_algorithm 3des;

        authentication_algorithm hmac_md5, hmac_sha1;

        lifetime time 1 hour ;

        compression_algorithm deflate;

}

После изменения конфигурационного файла, необходимо добавить правила политик безопасности для трафика, который мы будем шифровать. Например, для трафика идущего от сервера FreeBSD_IPSec_server это правило будет эквивалентно словам:

Если пакет отправляется с 192.168.5.23, и предназначен для 192.168.5.21, расшифровать его, используя необходимые параметры безопасности.

Если пакет отправляется с 192.168.5.21, и предназначен для 192.168.5.23, расшифровать его, используя необходимые параметры безопасности.

Для сервера FreeBSD_IPSec_client будет то же самое, но наоборот (в обратную сторону).

Теперь, нам необходимо создать эти правила на обоих серверах. На сервере FreeBSD_IPSec_server отредактируем файл /usr/local/etc/ipsec.conf до следующего содержания:

flush;

spdflush;

spdadd 192.168.44.0/24 192.168.55.0/24 any -P out ipsec esp/tunnel/192.168.5.23-192.168.5.21/require;

spdadd 192.168.55.0/24 192.168.44.0/24 any -P in ipsec esp/tunnel/192.168.5.21-192.168.5.23/require;

На сервере FreeBSD_IPSec_client этот файл будет иметь обратный вид:

flush;

spdflush;

spdadd 192.168.55.0/24 192.168.44.0/24 any -P out ipsec esp/tunnel/192.168.5.21-192.168.5.23/require;

spdadd 192.168.44.0/24 192.168.55.0/24 any -P in ipsec esp/tunnel/192.168.5.23-192.168.5.21/require;

После этого необходимо запустить racoon и IPSec на обоих серверах. Это делается добавлением в rc.conf следующих строк:

ipsec_enable="YES"

ipsec_file="/usr/local/etc/ipsec.conf"

racoon_enable="YES"

racoon_create_dirs="YES"

Сохраняем изменения, перезагружаем сервера.

После перезагрузки, необходимо убедиться в том, что туннель работает правильно. Для этого, на сервере FreeBSD_IPSec_server запустим tcpdump на интерфейсе gif1, а с сервера FreeBSD_IPSec_client будет командой ping обмениваться пакетами с FreeBSD_IPSec_server (рис. 1.31). 

                                           Рис. 1.31 Результат ping и tcpdump

Еще немного теории.

Существует 2 базы. SAD и SPD. С обеими работа осуществляется через утилиту setkey.

SA [setkey -D] - связь (ассоциация) безопасности. Это термин IPSec для обозначения соединения. При установленном соединении для каждого используемого протокола создается пара SA. Пара, т.к. SA - это однонаправленное соединение, а данные передаются в обоих направлениях. SA- пары хранятся на каждом узле. Если есть SA - соединение установлено. 

SPD [setkey -DP] - база политик безопасности. Политики безопасности указывают, какой именно трафик надо шифровать. И какой трафик приходит шифрованным. Если на одном сервере укажем, например, что исходящий трафик на порту 1701 надо шифровать, а на соседе не указываем, что на порт 1701 приходит шифрованный трафик, то ничего работать не будет.
Данная база может заполняться из setkey.conf путем setkey -f setkey.conf. Но в конфигурационном файле raccoon.conf есть интересная опция generate_policy on;. Если на Сервере FreeBSD_IPSec_server ее поставить в on, то на сервере будут создаваться политики, соответствующие политикам на клиенте. Например, если на клиенте FreeBSD_IPSec_client мы укажем, что исходящий трафик на порт 1701 необходимо шифровать, то на сервере автоматически создастся правило, что входящий трафик с данного клиента на порт 1701 будет шифрованным. Для начала рекомендую поставить on и оставить политики на сервере пустыми. Они заполнятся в соответствии с клиентом. На клиенте же необходимо заполнять вручную. Если взаимодействие политик будет настроено неправильно, шифрование не заработает и SA не создастся.

Реультат команды setkey –D сервера FreeBSD_IPSec_server показан на рисунке 1.32:

Рис. 1.32 setkey –D на сервере FreeBSD_IPSec_server

Реультат команды setkey –DP сервера FreeBSD_IPSec_server показан на рисунке 1.33:

                              Рис 1.33 setkey –DP на сервере FreeBSD_IPSec_server

Видно, что ассоциации и политики шифрования трафика созданы.

