АННОТАЦИЯ

В рамках данной дипломной рассматривается разработка программного обеспечения для блока и сам блок управления временными интервалами с использованием в качестве управляющего элемента российского микроконтроллера. 

В первом разделе рассматриваются теоретические аспекты разработки устройства, основные этапы разработки, аппаратные и программные средства для разработки и отладки программного обеспечения микроконтроллера. 

Во втором разделе производится практическая разработка проектируемого устройства: разрабатываются структурная и функциональные схемы, алгоритм управления и программное обеспечение микроконтроллера; производится выбор элементной базы; построение электрической схемы.

В третьем разделе показан тестовый пример, отражающий в себе работу микроконтроллера, который находится в составе блока управления временными интервалами(УВИ).




 




Введение

Научная деятельность в России не стоит на месте, в том числе и сфера науки, связанная с инженерными боеприпасами. Такой вид боеприпасов обладает рядом функций, таких как обнаружение цели, классификация цели и управление временем срабатывания устройства. Важным свойством, характеризующим этот вид вооружения, является наличие «электронного мозга», способного выполнять различные задачи, такие как классификация цели или расчет временного интервала, после которого устройство  сработает. С каждым годом разрабатывается все больше новых и современных видов таких боеприпасов. 

Блоки, составляющие устройства такого типа, разрабатываются так же на основе более современных и совершенных элементов, что позволяет уменьшить габариты, увеличить точность работы, понизить энергопотребление, усовершенствовать интеллект изделия, что позволит устройству функционировать в соответствии с установленными требованиями. Блок управления временными интервалами (УВИ), рассмотренный в данной работе, как раз является частью такого современного устройства и служит для точного срабатывания устройства при определенных условиях, то есть при прошествии определенного времени, которое формируется с помощью кода, приходящего на блок УВИ или от внешнего сигнала срабатывания. Реализовать такое устройство будет проще, если в качестве управляющего элемента будет использована программируемая интегральная схема, так как это позволяет перенести основные затраты, связанные с разработкой встраиваемых систем управления, из аппаратной в программную область. Для создания более современных видов таких боеприпасов необходимы наиболее новые и совершенные электронные компоненты. К таким компонентам относятся базовые матричные кристаллы (БМК), программируемые логические интегральные схемы (ПЛИС) и микроконтроллеры. Существует  ряд компаний производящий элементную базу такого типа, к таким компаниям относятся  Intel, Microchip Technology, Texas Instruments, Motorolla, Atmel и другие. Если устройство предназначено для использования в составе инженерного боеприпаса, то одним из важнейших требований к изделию становится применение в его конструкции российской элементной базы для его сборки. Есть несколько российских предприятий, производящих такие микросхемы, это такие предприятия, как ЗАО «ПКК Миландр», ОАО «Ангстрем», НПО Физика, ОАО «НИИЭТ».






1. Анализ предметной области.

Для соответствия современным требованиям, предъявляемым к инженерным боеприпасам, необходимо создания интеллектуальной системы с возможностью формирования временных интервалов в широком диапазоне с максимально возможной точностью для обеспечения решения специфических задач инженерных боеприпасов. 

Блок управления временными интервалами, рассмотренный в данной работе, может быть реализован с помощью микроконтроллера, БМК или ПЛИС в качестве управляющего элемента.  Опишем первые два типа элементов. 

Базовый матричный кристалл (БМК) - большая интегральная схема. Он программируется технологически, путем нанесения маски соединений последнего слоя металлизации. Базовый матричный кристалл напоминает библиотеку подпрограмм и функций для языков программирования. На БМК разведены, но не соединены элементарные цепи и логические элементы. Заказчиком разрабатывается схема соединений, так называемая маска. Такая маска наносится в качестве последнего слоя на базовый матричный кристалл и элементарные схемы и разрозненные цепи на БМК складываются в одну большую схему. В итоге заказчик получает готовую большую интегральную схему, которая получается ненамного дороже исходного БМК.

Программируемая логическая интегральная схема (ПЛИС) – это электронный компонент, который используется для создания цифровых интегральных схем. В отличие от обычных цифровых микросхем, логика работы ПЛИС не определяется при изготовлении, а задается посредством программирования. Для программирования используются программаторы и отладочные среды, позволяющие задать желаемую структуру цифрового устройства в виде принципиальной электрической схемы или программы на специальных языках описания аппаратуры: Verilog, VHDL, AHDL и другие. 

Микроконтроллер - микросхема, которая предназначена для управления электронными устройствами. Типичный микроконтроллер сочетает в себе функции процессора и периферийных устройств, содержит ОЗУ и  ПЗУ. По сути, это однокристальный компьютер, способный выполнять простые задачи управления.

БМК не подходит нам из-за своей уникального типа программирования и дороговизны, а ПЛИС из-за отсутствия российских компаний, которые их бы производили. А микроконтроллер полностью удовлетворяет требованиям, приведенным к поставленной задаче, так как он прост в программировании и в России достаточно предприятий, производящих микроконтроллеры.

1.1. Общие сведения о микроконтроллерах.

	Можно считать, что микроконтроллер (МК) - это компьютер, расположенный на одной микросхеме. Отсюда, как следствие, и его основные положительные качества: небольшие размеры; высокие производительность, надежность, отказоустойчивость и способность быть адаптированным для выполнения практически любой задачи.

	Микроконтроллер помимо центрального процессора (ЦП) содержит память и многочисленные устройства ввода/вывода: аналого-цифровые преобразователи, последовательные и параллельные каналы передачи информации, таймеры реального времени, широтно-импульсные модуляторы (ШИМ), генераторы программируемых импульсов и многие другие устройства. Основное назначение микроконтроллера - использование в системах автоматического управления, встроенных в самые различные устройства: кредитные карточки, фотоаппараты, сотовые телефоны, музыкальные центры, телевизоры, видеомагнитофоны и видеокамеры, стиральные машины, микроволновые печи, системы охранной сигнализации, системы зажигания бензиновых двигателей, электроприводы локомотивов, ядерные реакторы и огромное множество других устройств. Встраиваемые системы управления стали настолько многочисленным явлением, что фактически сформировалась новая отрасль экономики, получившая название встраиваемые системы (Embedded Systems).

	Широкое распространение имеют МК фирмы ATMEL, которые располагают большими функциональными возможностями.

	Применение микроконтроллеров можно разделить на два этапа: 

Программирование, когда пользователь разрабатывает программу и прошивает ее непосредственно в кристалл.

Согласование спроектированных исполнительных устройств с запрограммированным МК.




1.2. Выбор микроконтроллера

Именно выбор микроконтроллера является одним из самых важных решений, от которых зависит успех задуманного проекта. При выборе микроконтроллера необходимо учесть огромное количество факторов.

В основном случаях микроконтроллеры применяться там, где первостепенной задачей является уменьшение габаритов, потребляемой мощности, увеличение времени работы от одного источника питания , увеличение устойчивости к внешним воздействиям. Быстродействие, естественно, меньше чем у мощных процессоров, но его вполне достаточно для выполнения большинства требуемых от устройства задач. К тому же технология совершенствуется, и быстродействие микроконтроллеров растет очень быстро. Новые поколения микроконтроллеров могут выполнять более сложные расчеты за очень маленькие промежутки времени. Но, хотя производители стремятся обеспечить работу своих изделий на высоких частотах, они, в то же время, предоставляют клиентам выбор, выпуская модификации, рассчитанные на разные напряжения питания и частоты. 

На сегодняшний день на рынке микроконтроллеров активно работают более 40 разработчиков и производителей. Производители предлагают широкий выбор микроконтроллеров, отличающихся как техническими характеристиками, так и перечнем встроенных периферийных устройств, благодаря чему разработчики могут подобрать микроконтроллер, обладающий наиболее подходящим функционалом и который будет подходить для решения конкретной задачи. 

Критериями для выбора микроконтроллеров чаще всего являются: 

Быстродействие.

Габариты и тип корпуса.

Энергопотребление, наличие энергосберегающего режима работы, необходимость охлаждения.

Наличие встроенных периферийные устройства, начиная от EEPROM-памяти и заканчивая LAN или LCD-контроллером.

Надежность.

На сегодняшний день существует большое количество фирм выпускающих микроконтроллеры, это: Intel, Microchip Technology, Texas Instruments, Motorolla, Atmel и другие.



В микроконтроллере нам важно наличие встроенного EEPROM (Electrically Erasable Programmable Read-Only Memory). Эта память организована в виде отдельного пространства данных, в котором могут считываться и записываться отдельные байты. ЭСППЗУ имеет срок службы не менее 100 000 циклов записи/считывания. Доступ между ЭСППЗУ и ЦПУ описан далее с указанием регистров адреса, регистров данных и регистра управления ЭСППЗУ.

Для решения нашей задачи нам потребуется российский микроконтроллер, и наш выбор падает на интегральную микросхему 1887ВЕ1У , изготовленную предприятием ОАО «НИИЭТ» в городе Воронеж, так  как она является аналогом микроконтроллера ATmega 8535, подходящего для решаемой задачи по характеристикам, но с военной приемкой, что является требованием заказчика. Потребителями продукции ОАО "НИИЭТ" являются свыше 200 предприятий, и их изделия применяются более чем в 40 регионах России.






1.3. Описание микроконтроллера МИ 1887ВЕ1У

1.3.1. Назначение и область применения

Микросхемы 1887ВЕ1У предназначены для применения в системах встроенного управления комплексами радиосвязи специального назначения.

В области промышленного производства микросхема 1887ВЕ1У может быть использована для управления робототехническими комплексами, в системах автоматизации технологических процессов, в системах автоматизированного управления электроприводом, оргтехнике, вычислительной технике, телекоммуникационной технике и т. п. Особенно перспективно применение микросхем 1887ВЕ1У в портативной носимой аппаратуре и приборах, имеющих жесткие ограничения по соотношению быстродействие/потребляемая мощность/стоимость.



 1.3.2.Краткое техническое описание ИС 1887ВЕ1У

Схема является КМОП 8-битным микроконтроллером, построенным на расширенной AVR RISC архитектуре. Используя команды, исполняемые за один машинный такт, контроллер достигает производительности в 1 MIPS на рабочей частоте 1 МГц, что позволяет разработчику эффективно оптимизировать потребление энергии за счёт выбора оптимальной производительности.

AVR ядро сочетает расширенный набор команд с 32 рабочими регистрами общего назначения. Все 32 регистра соединены с АЛУ, что обеспечивает доступ к двум независимым регистрам на время исполнения команды за один машинный такт. Благодаря выбранной архитектуре достигнута высокая производительность, в 10 раз превосходящая скорость соответствующего CISC микроконтроллера. Микроконтроллер содержит 8К байт внутрисистемной программируемой флэш-памяти (Flash) программ с возможностью чтения в процессе записи, 512 байтов ЭСППЗУ, 512 байтов СОЗУ, 32 входа/выхода общего назначения, 32 рабочих регистра, три гибких таймера/счётчика с режимом сравнения, внешние и внутренние прерывания, последовательный программируемый UART, 8-канальный 10-битный АЦП, программируемый сторожевой таймер с внутренним генератором, последовательный SPI порт и шесть выбираемых программным способом режимов сбережения энергии.

В режиме холостого хода ЦПУ не функционирует, в то время как функционируют СОЗУ, таймеры/счётчики, SPI порт и система прерываний. В микроконтроллере существует специальный режим подавления шума АЦП, при этом в целом в спящем режиме функционируют только АЦП и асинхронный таймер для исключения цифровых шумов в процессе преобразования АЦП. В режиме микропотребления процессор сохраняет содержимое всех регистров, останавливает генератор тактовых сигналов, приостанавливает все другие функции кристалла до прихода внешнего прерывания или поступления внешней команды RESET. В режиме ожидания работает генератор тактовых частот, в то время как остальные блоки находятся в спящем режиме. Благодаря этому переход в нормальный

режим работы происходит гораздо быстрее. В расширенном режиме ожидания в рабочем состоянии находятся основной генератор и асинхронный таймер.

Микросхемы выпускаются при использовании технологии энергонезависимой памяти высокой плотности. Встроенная Flash позволяет перепрограммировать память программ внутрисистемно через последовательный SPI интерфейс стандартным программатором энергонезависимой памяти или встроенной загрузочной программой, работающей в ядре ЦПУ. Загрузочная программа может использовать любой интерфейс для экспорта рабочей программы во флэш-память.

Комбинация расширенной 8-битной RISC архитектуры ЦПУ и внутрисистемной флэш-памяти обеспечивают микроконтроллеру высокую гибкость и экономическую эффективность во встраиваемых системах управления.



1.3.3. Особенности архитектуры

- быстродействующая архитектура типа «регистр-регистр»;

- регистровое ОЗУ емкостью до 512 байт;

- последовательный периферийный интерфейс SPI;

SPI (англ. Serial Peripheral Interface — последовательный периферийный интерфейс) — последовательный синхронный стандарт передачи данных в режиме полного дуплекса, разработанный компанией Motorola для обеспечения простого и недорогого сопряжения микроконтроллеров и периферии. SPI также иногда называют четырёхпроводным (англ. four-wire) интерфейсом.

- последовательный синхронно-асинхронный приемопередатчик UART;



Универсальный асинхронный приёмопередатчик (УАПП, англ. Universal Asynchronous Receiver-Transmitter (UART)) — узел вычислительных устройств, предназначенный для связи с другими цифровыми устройствами. Преобразует заданный набор данных в последовательный вид так, чтобы было возможно передать их по однопроводной цифровой линии другому аналогичному устройству. При этом интервалы времени между передаваемыми блоками данных не являются постоянными: блоки данных выделяются с помощью стартовых и стоповых битов (Асинхронная передача данных). Метод преобразования хорошо стандартизован и широко применялся в компьютерной технике.

- двухпроводной последовательный интерфейс TWI;

- 16-разрядный таймер/счетчик;

- два 8-разрядных таймера/счетчика;

- 8-разрядный сторожевой таймер;

- 8-канальный 10-разрядный аналого-цифровой преобразователь;

- аналоговый компаратор;

- 4-канальный ШИМ;

- четыре 8-разрядных порта ввода-вывода;

- режимы холостого хода IDLE и хранения POWERDOWN.











Рис. 1



1.3.4. Функциональное описание ИС 1887ВЕ1У

Микроконтроллер 1887ВЕ1У содержит 8 Kбайт внутрисистемной программируемой флэш-памяти с возможностью считывания во время записи, ЭСППЗУ емкостью 512 байт, 512 байт СОЗУ, 32 линии ввода-вывода общего назначения, 32 рабочих регистра общего назначения, три гибких таймера/счетчика с режимами сравнения, внутренние и внешние прерывания, последовательный программируемый универсальный синхронноасинхронный последовательный порт UART, побайтно ориентированный двухпроводной последовательный интерфейс, 8-канальный 10-разрядный АЦП с дополнительным дифференциальным входным каскадом с программируемым усилением. Микроконтроллер имеет также программируемый сторожевой таймер с внутренним генератором, последовательный периферийный интерфейс SPI и шесть энергосберегающих режимов (sleep), выбираемых программно. Режим холостого хода останавливает ЦПУ, в то время как СОЗУ, таймеры/счетчики, SPI интерфейс и система прерывания продолжают работать. Режим

микропотребления сохраняет содержимое регистров, но приостанавливает генератор, отключая все остальные функции кристалла до наступления следующего прерывания или общего сброса. В режиме хранения продолжает работать асинхронный таймер, в то время как остальная часть устройства находится в спящем режиме. Режим пониженного шума АЦП останавливает ЦПУ и все периферийные модули для того, чтобы свести к минимуму

шум при переключении во время АЦП преобразований. В режиме ожидания работает кварцевый генератор, в то время как остальная часть устройства находится в спящем режиме. Это позволяет обеспечить очень быстрый запуск при малой потребляемой мощности. В длительном режиме ожидания продолжают работать основной генератор и асинхронный таймер.

Прибор изготавливается с использованием технологии по производству нестираемой памяти с высокой плотностью упаковки. Встроенная в кристалл флэш-память с внутрисистемным программированием позволяет перепрограммировать память с помощью последовательного SPI интерфейса или же с помощью также встроенной в кристалл памяти загрузки. Программа загрузки может использовать любой интерфейс для загрузки прикладных программ в флэш-память. Программное обеспечение (ПО) в секции загрузки

флэш-памяти будет продолжать работать во время обновления секции приложений флэш-памяти, благодаря чему обеспечивается реальное считывание во время записи. Благодаря объединению 8-разрядного RISC ЦПУ со встроенной самопрограммируемой флэш-памятью на одном кристалле, контроллер 1887ВЕ1У является маломощным микроконтроллером, обеспечивающим чрезвычайно гибкое и экономичное решение для многих видов применения систем встроенного управления.

ИС 1887ВЕ1У поддерживает полный набор программ и средств системной разработки, включая С-компиляторы, макроассемблеры, средства отладки и моделирования, внутрисхемные эмуляторы и оценочные комплекты.




1.3.5.Ядро микроконтроллера



Рис. 2

Для того чтобы максимально улучшить характеристики и параллелизм, в микропроцессоре используется Гарвардская архитектура с отдельными устройствами памяти и шинами для программ и данных. Команды в памяти программ выполняются на едином уровне конвейеризации. Во время исполнения одной команды следующая команда предварительно извлекается из памяти программ. Такой принцип позволяет исполнять команды за

каждый тактовый цикл. Память программ представляет собой внутрипроцессорную перепрограммируемую флэш-память. Регистр файлов с ускоренным доступом содержит 32 8-разрядных рабочих регистра общего назначения с единым временем доступа за тактовый цикл. Это позволяет обеспечить работу АЛУ за один цикл. В типичном режиме работы АЛУ из файла регистра берутся два операнда, выполняется операция, и результат опять сохраняется в файле регистра; все это выполняется за один тактовый цикл.

Шесть из 32 регистров могут использоваться как три 16-разрядных указателя адреса регистра для адресации пространства данных, позволяя обеспечить эффективные вычисления адресов. Один из этих указателей адреса может быть также использован как указатель адреса для таблиц просмотра (look up tables) во флэш-памяти программ. Эти дополнительные регистры функций являются 16-разрядными X-, Y- и Z-регистрами, описанными далее в этом подразделе. АЛУ поддерживает арифметические и логические операции между регистрами или между константой и регистром. АЛУ может выполнить одну операцию с регистром. После арифметической операции регистр состояния обновляется для вывода информации о результатах операции. Поток программы управляется условными и безусловными переходами и командами вызова, которые способны обеспечить непосредственную адресацию ко всему адресному пространству. Большинство команд имеют единый 16-разрядный формат слова. Каждый

адрес программы памяти содержит 16- или 32-разрядную команду.

Пространство флэш-памяти программ разделено на две секции: секцию программы загрузки и секцию прикладной программы. Обе секции имеют специальные блокирующие разряды для защиты записи и считывания/записи. Команда SPM, которая осуществляет запись в секцию флэш-памяти прикладных программ, должна находиться в секции программы загрузки.

Во время запросов на прерывание и исполнение подпрограмм, обратный адрес счетчика программ PC хранится в стеке. Стек расположен в СОЗУ общих данных, его размер ограничен только общим объемом СОЗУ и характером использования СОЗУ. Все программы пользователя должны инициализировать SP во время процедуры сброса (до исполнения подпрограмм или прерываний). Указатель стека SP доступен для считывания/записи в пространстве ввода-вывода. СОЗУ данных легко доступно с помощью пяти различных режимов адресации, поддерживаемых архитектурой микроконтроллера. Гибкий модуль прерывания имеет собственные регистры управления в пространстве ввода-вывода с дополнительным разрядом разрешения общего прерывания в регистре со-

стояния. Все прерывания имеют отдельный вектор прерывания в таблице вектора прерывания. Прерывания имеют приоритет в зависимости от положения их вектора. Чем ниже адрес вектора прерывания, тем выше приоритет.

Пространство памяти ввода-вывода содержит 64 адреса для регистров периферийных компонентов микроконтроллера. Доступ к памяти ввода-вывода может осуществляться напрямую или адресацией пространства данных, следующих за аналогичными адресами файла регистров, 0x20 – 0x5F.



Для программирования данного микроконтроллера требуется программатор и программное обеспечение, произведенные Аргуссофт Компани.   



1.4.Сброс и обработка прерываний

ИС 1887ВЕ1У содержит несколько различных источников прерывания. Каждое из этих прерываний и отдельный вектор сброса имеют отдельный программный вектор в пространстве памяти программ. Все прерывания имеют свои отдельные разряды разрешения, которые должны быть установлены вместе с установкой разряда разрешения глобального прерывания в регистре состояний для того, чтобы разрешить прерывание. В зависимости от значения программного счетчика, прерывания могут быть автоматически запрещены, когда программируются биты блокировки BLB02 или BLB12. Подобная особенность повышает безопасность программного обеспечения. Для получения подробной информации см. подраздел 3.20 «Программирование памяти». Младшие адреса в пространстве памяти программ, по умолчанию, определены как векторы сброса и прерывания. Перечень прерываний устанавливает также уровень приоритетов для различных прерываний. Чем ниже адрес, тем выше уровень приоритета.

Сброс имеет наивысший приоритет, а следующим является INT0 – запрос 0 внешнего прерывания. Векторы прерывания могут быть перемещены в начало секции загрузки флэш-памяти путем установки разряда IVSEL в регистре управления общим прерыванием (GICR). Для подробного рассмотрения вопроса по «прерываниям» см. соответствующий подраздел. Вектор сброса может быть также перемещен в начало секции загрузки

флэш-памяти с помощью программирования бита BOOTRST.

При возникновении прерывания бит I разрешения глобального прерывания очищается и все прерывания блокируются. Пользовательское ПО может записывать логическую единицу в бит I для разрешения вложенных прерываний. Все разрешенные прерывания могут прерывать текущее прерывание. Разряд I устанавливается автоматически при исполнении возврата из команды прерывания RETI. Существует два основных типа прерываний. Первый тип запускается событием, которое устанавливает флаг прерывания. Для этого типа прерываний программный счетчик переходит на вектор прерываний для исполнения подпрограммы обработки прерываниями, при этом аппаратно очищается соответствующий флаг прерывания. Флаги прерывания могут также очищаться путем записи логической единицы в позицию разряда соответствующего флага. Если возникает условие прерывания в то время, как соответствующий разряд прерывания сброшен, флаг прерывания будет установлен и запомнен до разрешения прерывания или он будет сброшен программным способом. Подобным образом, если

возникает одно или несколько условий прерывания при сброшенном разряде глобального разрешения прерывания I, соответствующий флаг(и) будет установлен и внесен в память до тех пор, пока установится I, а затем будет выполнена обработка прерываний в порядке приоритета. Второй тип прерываний будет запущен как только возникнет условие прерывания. Эти прерывания не обязательно должны иметь флаги прерывания. Если условие прерывания исчезает до разрешения прерывания, то прерывание не будет запущено. После выхода из прерывания микропроцессор всегда возвращается к основной программе и исполняет еще одну команду до обслуживания любого ждущего прерывания. Обратите внимание на то, что регистр статуса не сохраняется автоматически при возврате из процедуры прерывания. Это должно выполняться программно. При использовании команды CLI для блокировки прерывания, прерывания будут немедленно блокированы. Ни одно прерывание не будет выполняться после команды CLI, даже если оно происходит одновременно с командой CLI. Следующий пример показывает, как это может быть использовано для того, чтобы избежать прерываний во время запланированной последовательности записи ЭСППЗУ.



1.5.Описание внутрисхемного программатора AS-4 



Рис. 3

Программаторы работают со следующими микросхемами:

- AT89S2051/4051/51/52/53/8252/8253 AT86RF401

- ATtiny13/2x/4x/8x, AT90CAN32/64/128, AT90PWM2/3, AT90USB82/162/64x/128x

- ATmega48/8x/16x/32x/64x/128x/256x

- AT25256, AT25HP256, AT25HP512

- AT45DB041, AT45DB081, AT45DB161, AT45DB321, AT45DB642



Тип интерфейса : USB

Скорость обмена : 19,2/115,2/921,6 Кбод 

Потребляемый ток : не более 30 мА при напряжении 5 В

Напряжение питания : 3,3 …5,0 В

Питающее напряжение на программаторы подается от программируемой платы.

Программаторы комплектуется программой ASISP, предназначенной для программирования микроконтроллера, разработанной в АРГУССОФТ Компани.

Программа ASISP функционирует в среде Windows 2000/XP/7, поддерживает русскоязычный и англоязычный интерфейс и имеет следующие возможности:

- выбор номера используемого порта (COM1…COM255)

- последовательная загрузка двух HEX-файлов по различным адресам

- последовательная загрузка двух EEP-файлов по различным адресам

- просмотра и редактирование содержимого памяти программ и данных

- чтение сигнатуры программируемой микросхемы

- чтение калибровочных байтов микросхемы

- быстрый доступ к операциям чтения/записи/верификации/стирания ПЗУ и ЭСПЗУ

- быстрая загрузка файлов в форматах .HEX .BIN и .EEP

- выбор скорости обмена с компьютером (19,2, 115,2 или 921,6 Кбод)

- выбор алгоритма программирования (стандартный и ускоренный)

- выбор периода SCK в диапазоне от 0,25 мкс. до 150 мкс.

- выбор длительности импульса RESET в диапазоне от 20 мс. до 1000 мс.

- программирование битов защиты и FUSE-битов

- запись в ПЗУ и/или в ЭСПЗУ микросхемы серийного номера изделия с автоинкрементом

- режим автоматического программирования в соответствии с установками в файле проекта



На скриншоте изображена работа программы ASISP, где наглядно видно, что записано в микроконтроллер (содержание флеш-памяти вверху, содержание EEPROM внизу)

Рис. 4



Рис. 5



1.6. Описание сред и возможностей программирования микроконтроллеров

Программирование микроконтроллеров обычно осуществляется на языке ассемблера или Си, хотя существуют компиляторы для других языков, например, Форта. Программирование осуществляется либо с помощью программатора, как в нашем случае, но контроллер может прошиваться и с помощью отладочной платы, с возможностью подключения определенного вида контроллеров. Используются также встроенные интерпретаторы Бейсика.

 Известные компиляторы Си для МК:

 — GNU Compiler Collection - Поддерживает ARM, AVR, MSP430 и многие другие архитектуры

— CodeVisionAVR (для AVR)

— IAR (для любых МК)

— WinAVR (для AVR и AVR32)

— Keil (для архитектуры 8051 и ARM)

— HiTECH (для архитектуры 8051 и PIC от Microchip)

— ICCV8 for AVR



Для отладки программ используются программные симуляторы (специальные программы для персональных компьютеров, имитирующие работу микроконтроллера), внутрисхемные эмуляторы (электронные устройства, имитирующие микроконтроллер, которые можно подключить вместо него к разрабатываемому встроенному устройству) и интерфейс JTAG.

При написании дипломного проекта я использовал ICCV8, так как ImageCraft IDE (рис. 6) представляет собой очень простую и в то же время очень эффективную среду разработки для создания приложений, для большого числа семейств микроконтроллеров.

Эта IDE была выбрана мной, так как:

-  она имеет удобное расположение окон среды, редактирование файлов, интуитивную настройку параметров.

 - высокое качество, с точки зрения польза/объем, предоставляемой информации.

 - встроенный ANSI Terminal Emulator, для работы с последовательным портом.

 - Application Builder для генерации кода инициализации периферии микроконтроллера.

 - Code Browser™ для предоставления информации об адресе, типе, объеме памяти всех функций и переменных задействованных в проекте.

 - встроенный Flash / EEPROM загрузчик кода, поддерживающий большое количество программаторов.



Рис. 6




1.7.Постановка задачи

Требуется разработать программное обеспечение для блока управления временными интервалами (УВИ) на основе российского микроконтроллера МИ 1887ВЕ1У. Блок должен потреблять малое количество электроэнергии при относительно долгом времени работы, для этого у микроконтроллера есть несколько спящих режимов, один из которых будет использоваться в данной задаче. Блок УВИ должен работать в двух режимах. 

В режиме 1 происходит считывание и запись кодов, приходящих с блока формирования сигналов и приема квитанции и запись этого кода в память ЭСППЗУ. 

В режиме 2 код, заранее записанный в память, считывается из нее. В зависимости от входящего сигнала, микроконтроллер через определенное время, с помощью таймеров, встроенных в микроконтроллер, будет выдавать сигнал через различные интервалы времени, которые будут вызывать срабатывание блока. Максимальное время работы блока от его запуска до срабатывания: девять суток, большую часть времени которого микроконтроллер будет находится в режиме энергосбережения. Сразу после включения блок должен сформировать сигнал готовности через 120секунд, при этом отсчет этого времени должен производится по двум независимым каналам. Выходной сигнал, формируемый при срабатывании блока, должен иметь форму положительного импульса длительностью  0,1 с. 


2. Разработка конфигурации блока управления.

2.1 Разработка структурной схемы блока управления.

В ходе выполнения дипломного проекта была разработана структурная схема для блока управления временными интервалами. Она изображена на рис. 7.



Рис. 7

Описание структурной схемы блока управления временными интервалами.

Блок выбора режима работы.

Эта часть схемы управляет выбором того, в каком режиме будет работать блок управления временными интервалами (УВИ). Всего режимов работы два. В режиме 1 происходит считывание и запись кодов, приходящих с блока формирования сигналов и приема квитанции и запись этого кода в память. В режиме 2 код, заранее записанный в память, считывается из нее.

Блок формирования сигналов и приема квитанции.

Этот блок управляет формированием кода, который будет определять время выдачи выходного сигнала срабатывания. Код будет сформирован, если блок УВИ работает в режиме 1. После формирования кода и отправки кода на блок обработки внешних сигналов, в блоке обработки внешних сигналов формируется квитанция, которая принимается этим блоком в качестве отчетности того, что информация отправлена и для проверки отправленного на блок ОВС кода. Так же, если блок работает в режиме 2, здесь происходит формирование внешнего сигнала, который, будучи поданным на блок обработки внешних сигналов, вызовет выдачу сигнала срабатывания.

Блок обработки внешних сигналов (ОВС) принимает коды, отвечающие за время появления сигнала срабатывания,  и формирует квитанцию с ответным кодом. Так же это блок принимает внешний сигнал по которому происходит срабатывание блока УВИ.

Блок управления управляет вычислениями, производимые внутри контроллера. Он отвечает за прирост значений счетчиков, отсчитывающих временной интервал срабатывания изделия. Так же внутри него происходит анализ режима работы микроконтроллера, в зависимости от которого внутри блока УВИ будут совершатся различные операции.

Счетчик временных интервалов запускает отсчет времени для получения требуемого временного интервала. 

Блок формирования выходных сигналов в зависимости от работы блока управления формирует выходные сигналы.

Блок индикации выходных сигналов представляет собой группу светодиодов, отображающих работу блока создания выходных сигналов.



Блок управления, блок обработки внешних сигналов, счетчик временных интервалов и блок формирования выходных сигналов могут быть реализованы на микроконтроллере МИ 1887ВЕ1У. 

Микроконтроллер определяет режим работы блока УВИ с помощью блока выбора режима работы.

В режиме 1 принимается код, поступающий из блока формирования сигналов и приема квитанции, определяющий время срабатывания. Так же в этом режиме с блока обработки внешних сигналов на блок формирования сигналов и приема квитанции отправляется отчет о правильности переданного этим блоком кода и записи этого кода в память.

В режиме 2 блок УВИ обеспечивает срабатывание по внешнему сигналу или через временной промежуток, определяемый принятым в режиме 1 кодом, предварительно выдав сигнал готовности. Сигнал готовности и сигнал срабатывания формируются в блоке формирования выходных сигналов и передаются на блок индикации выходных сигналов для фиксирования срабатывания блока при помощи светодиодов.




2.2. Разработка принципиальной схемы блока управления.



Согласно приведенной выше структурной схеме были рассчитаны и разработаны схемотехнические решения блоков и узлов, входящих в нее. На основании которых была разработана схема электрическая принципиальная устройства, представленная в приложении 2. 

Описание работы схемы.

На входы X1, X2, X3, предназначенные для приема кода срабатывания, поступают цифровые входные сигналы, формирующие временные интервалы срабатывания. Резисторы R1 и R13, R2 и R10, R3 и R6 формируют делители напряжения, предназначенные для формирования однозначно заданного цифрового сигнала на входах PA3,  PA4, PA5 микросхемы DD1(1887ВЕ1У). Номиналы резисторов были выбраны следующими R1=R2=R3=10кОм и R6=R10=R13=1МОм. Таким образом при отсутствии сигналов на входах X1, X2, X3 схемы, выводы 44, 41, 40 микросхемы DD1 будут привязаны к земле (нулевой точке) через резисторы R13, R10, R6. При наличии логической 1 на входах Х1, Х2, Х3 схемы, напряжение на входах DD1 будут вычисляться следующим образом:

UPA3 = (UX1*R13)/(R1+R13) 

UPA4 = (UX2*R10)/(R2+R10) 

UPA5 = (UX3*R6)/(R6+R3) 

Для выбранных значений сопротивлений резисторов R1,R2, R3, R6, R10, R13 UPA3 = UPA4 = UPA5

	Контактные точки X1, X2, X3 предназначены не только для ввода информации, но и для ее вывода. Для обеспечения двухсторонней линии передачи данных с внешнего устройства.

	Резисторы R1, R2, R3 также предназначены для ограничения тока входного и выходного сигналов с целью обеспечения корректной работы микросхемы DD1.

	При записи кодов  подается напряжение питания с внешнего устройства к контактной точке X4. Последовательно соединенные резистор R4 и диод VD1 предназначены для ограничения входного тока микросхемы с целью обеспечения корректной работы контроллера. Номинальное значение сопротивления резистора R4 было выбрано равным 220 Ом, исходя из документации на микросхему DD1.   Диод VD1 предназначен для обеспечения отсутствия потенциала в точке X4 при включении основного питания.

	При подаче основного питания на контактную точку X6 происходит подача потенциала питания на выводы #VCC и ∩VCC микросхемы DD1 через диод VD2, предназначенный для запрещения подачи питания на основную схему(схемы выходных каскадов) при программировании. Подача потенциала на выводы #VCC и ∩VCC производится через фильтрующий конденсатор C4 обеспечивающий корректную работу микроконтроллера микросхемы DD1 при нестабильном питании, а так же при наличии внешних помех. 

Резисторы R11 и R9 и R5, входящие в состав инвертирующего звена, собранного на базе биполярного n-p-n транзистора VT1, предназначены для обеспечения его корректной работы. Резистор R11 так же предназначен для ограничения тока управляющего сигнала, поступающего на 19 вывод (PD3) микросхемы DD1, в дежурном режиме. Резистор R5 предназначен для ограничения тока базы транзистора VT1 при подаче управляющего сигнала (логическая единица) на контактную точку X7. Задачей резистора R9 является обеспечение рабочей точки транзистора VT1. Расчет R11, R9, R5 был проведен на основании технической документации на транзистор VT1 (2Т665А-9 аАО.339.559 ТУ). Номинальные значения сопротивлений соответственно равны:

R11 = 100кОм.

R9 = 100кОм.

R5 = 10кОм.  

Задачей выходных цепей R14- HL1, R15- HL2, R16- HL3, R17- HL4, R18 - HL5, R19- HL6 - является индикация выходных сигналов, формируемых на выводах PC0, PC1, PC2, PD1, PD4, PD5 микросхемы DD1. Резисторы R14 - R19 предназначены для ограничения тока выходных сигналов микросхемы DD1. Номинальные значения сопротивлений были рассчитаны на основании технической документации контроллера DD1(К1887ВЕ1У КФДЛ.1295.047ЭТ) и светодиодов HL1 – HL6(3Л341Б аАО.339.189). 

Значения сопротивлений равны: R14 = R15 = R16 = R17 = R18 =R19 = 220Ом

	Так же в состав схемы электрической принципиальной входит кварцевый резонатор ZQ1 (РК 146*-32,768к-8ДШ аЦО.338.110 ТУ), обеспечивающий частоту тактового сигнала равную 32768 Гц. Конденсаторы C2 и C3 предназначены для формирования скважности тактового сигнала, необходимой для корректной работы микросхемы DD1. Номинальные значения емкостей были выбраны на основании технической документации контроллера DD1(К1887ВЕ1У КФДЛ.1295.047ЭТ).

	Так же в состав схемы электрической принципиальной входит разъем программирования XP1 с обвязкой, включающей в себя резисторы R7 и R12, обеспечивающие корректное программирование микросхемы DD1. Номинальные значения резисторов были выбраны на основании технической документации контроллера DD1(К1887ВЕ1У КФДЛ.1295.047ЭТ). 

	Для обеспечения корректной работы блока УВИ в схеме электрической принципиальной предусмотрена цепь начального обнуления. При подаче одного из питаний( X4 или X6) на выходе интегрирующей цепи(R8 - C1) формируется выходной сигнал с запаздыванием 0,1мс по отношению к фронту сигнала питания. Исходя из заданной величины запаздывания были, рассчитаны номинальные значения емкости конденсатора C1 и сопротивления резистора R8. Полученные значения составили:

C1 = 1100пФ.

R8 = 51кОм.




2.3. Разработка алгоритма программы

В дипломном проекте был разработан алгоритм программы для управляющего элемента блока управления временными интервалами.  

Блок-схема алгоритма общей работы программы управляющего элемента блока управления временем срабатывания приведена на рис. 9.

Ход работы программы:

После подачи питания на блок УВИ в микроконтроллере происходит инициация портов. Далее в зависимости от внешнего сигнала выбирается режим работы блока управления временем срабатывания. 

Если установлен режим 1 (считывание входного сигнала), то выполняется чтение внешнего сигнала, приходящего на порт микроконтроллера, и запись этого сигнала в EEPROM. После записи с порта  посылается квитанция о правильности пришедшего входного кода. 	

Если установлен режим 2, задаются начальные значения таймера-счетчика 1 и таймера-счетчика 2 и разрешаются все виды прерываний. Далее из EEPROM считывается записанный ранее код и запускается первый и второй таймеры, в цикле идет ожидание сигнала готовности, и после выдачи этого сигнала запускается бесконечный цикл, в котором ожидается срабатывание по внешнему сигналу или срабатывание в зависимости от кода через 1, 2, 3, 4, 5 суток или, в случае отсутствия внешнего сигнала и кода на срабатывание, срабатывание произойдет через 9 суток. В этом режиме после выдачи сигнала предварительной готовности микроконтроллер начинает работать в режиме пониженного потребления и выходит из него только для кратковременной проверки отсчета времени. 





Блок-схема более подробного алгоритма работы программы управляющего элемента блока приведена на рис. 10, 11, 12, 13, 14, 15, 16, 17, 18, 19.

Ход работы программы:

После запуска блока УВИ в микроконтроллере происходит инициация портов. Далее выбирается режим работы блока управления временем срабатывания, это происходит в зависимости от наличия сигнала на  выводе микроконтроллера PB0. Если выбран режим считывания входного сигнала (режим 1), то выполняется чтение сигнала приходящего на порт А  и запись этого сигнала в 1 байт EEPROM . После записи с порта А посылается квитанция о правильности пришедшего входного кода. 

Если установлен режим 2(режим обработки входного сигнала), то задаются начальные значения таймера-счетчика 1 и таймера-счетчика 2 и разрешаются все виды прерываний. Далее из EEPROM из 1-го байта считывается записанный ранее код и запускается первый и второй таймеры. Далее запускается цикл ожидания сигнала готовности, который передается с PD1 и PD4 через 2 минуты после запуска режима 2, при этом за отсчет времени отвечают таймер-счетчик 1, тактирование которого равно 5 секундам,  и таймер-счетчик 2, работающий в асинхронном режиме, тактирование которого тоже равно 5 секундам, и тактовую частоту  которого задает внешний кварцевый резонатор, частота которого равна 32768 Гц, и после выдачи этих сигналов запускается бесконечный цикл, в котором ожидается срабатывание по внешнему сигналу, который приходит на порт B на PB2 или срабатывание по коду через 1 сутки если код равен 0x38, через 2 суток если код равен 0x08, через 3 суток если код равен 0x10  , через 4 суток если код равен 0x20 , через 5 суток если код равен 0x18 или, в случае отсутствия внешнего сигнала и кода на срабатывание, выдача сигнала срабатывания произойдет через 9 суток .

























































2.4. Написание программы

Для микроконтроллеров существует несколько различных языков программирования, но, наиболее подходящими являются Си и ассемблер, потому что в этих языках в реализованы все необходимые возможности по управлению аппаратными средствами микроконтроллеров.

Ассемблер (assembler) - это низкоуровневый язык программирования, который использует непосредственный набор инструкций микроконтроллера. Создание программы на этом языке требует очень хорошего знания системы команд программируемого чипа и большого количества времени на разработку программы. Ассемблер проигрывает Си в скорости и удобстве разработки программ, но имеет заметные преимущества в размере конечного исполняемого кода, а следовательно, и скорости его выполнения.

Язык Си позволяет создавать программы с гораздо большим комфортом, предоставляя разработчику все преимущества языка высокого уровня. 

Архитектура и система команд AVR создавалась при непосредственном участии разработчиков компилятора языка Си и в ней были учтены все особенности этого языка. Компиляция исходных текстов, написанных на языке Си, осуществляется очень быстро и дает компактный, эффективный код.

Основные преимущества языка Си перед ассемблером: более высокая скорость разработки программ; универсальность, которая не требует досконального изучения архитектуры микроконтроллера; более хорошая документируемость и читаемость алгоритма, наличие библиотек функций, поддержка вычислений значений с плавающей точкой.



     В Си сочетаются возможности программирования низкого уровня со свойствами языка высокого уровня. Возможности низкоуровневого программирования позволяют легко оперировать непосредственно аппаратными средствами, а свойства языка высокого уровня позволяют создавать легко читаемый и легко редактируемый программный код. Практически все компиляторы языка Си имеют возможность использовать ассемблерные вставки для написания участков программы, критичных по времени выполнения и занимаемым ресурсам.

Следовательно, Си - наиболее удобный язык для начинающих знакомиться с микроконтроллерами AVR и для серьезных разработчиков.

Чтобы преобразовать исходный текст программы в файл прошивки микроконтроллера, используются компиляторы.

Фирма Atmel поставляет мощный компилятор ассемблера, который входит в среду разработки AVR Studio, работающую под Windows. Наряду с компилятором, среда разработки содержит отладчик и эмулятор. Эта среда разработки поддерживает как программирование на языке Си, так и на языке Ассемблер. AVR Studio бесплатная и доступна для скачивания на сайте Atmel. 

В настоящее время существует достаточное количество компиляторов Си для AVR. Самым мощным из них считается компилятор фирмы IAR Systems. IAR C Compiler имеет обширные возможности по оптимизации кода и поставляется в составе интегрированной среды разработки IAR Embedded Workbench, включающей в себя также компилятор ассемблера, линкер, менеджер проектов и библиотек, а также отладчик. 

	Фирмой Image Craft выпускается компилятор языка Си, получивший достаточно широкую популярность. Image Craft C Compiler обладает неплохим уровнем оптимизации кода и достаточно низкой ценой.

Не меньшую популярность завоевал Code Vision AVR C Compiler, цена полной версии этого компилятора невысока и составляет 150 EUR. Компилятор поставляется вместе с интегрированной средой разработки, в которую, помимо стандартных возможностей, включена достаточно интересная функция - CodeWizardAVR Automatic Program Generator. Наличие в среде разработки последовательного терминала позволяет производить отладку программ с использованием последовательного порта микроконтроллера.

Очень известной стала интегрированная среда разработки WinAVR. Она включает мощные компиляторы Си и ассемблера, программатор AVRDUDE, отладчик, симулятор и множество других вспомогательных программ и утилит. WinAVR прекрасно интегрируется со средой разработки AVR Studio от Atmel. Ассемблер идентичен по входному коду ассемблеру AVR Studio. Компиляторы Си и ассемблера имеют возможность создания отладочных файлов в формате COFF, что позволяет применять не только встроенные средства, но и использовать мощный симулятор AVR Studio. Еще одним немаловажным плюсом является то, что WinAVR распространяется свободно без ограничений (производители поддерживают GNU General Public License).

При создании данного проекта для прошивки микроконтроллера использовался программный проект созданный в Image Craft восьмой версии. Также для отладки отдельных блоков программы использовалась AVR Studio, так как у нее есть встроенный эмулятор, позволяющий проверить работу программы.

Для того чтобы обеспечить более продолжительную работу блока используются энергосберегающие режимы микроконтроллера.



Для долговременной работы микроконтроллера от одного и того же источника питания нужно использовать спящие режимы. Использование спящих режимов позволяет отключить неиспользуемые модули в микроконтроллере, что позволяет экономить энергию. Всего ИС 1887ВЕ1У имеет шесть режимов сна. Для введения в любой из них необходимо записать логическую единицу в разряд SE регистра MCUCR и выполнить команду «_SLEEP()» (для ImigeCraft 8.05 AVR). С помощью разрядов SM2, SM1 и SM0 в регистре MCUCR выбирается тип спящего режима.  

Виды энергосберегающих режимов ИС 1887ВЕ1У и их выбор:



Регистр управления МПУ – MCUCR



Режим холостого хода:

Останавливается работа ЦПУ, но разрешается при этом, чтобы SPI, UART, аналоговый компаратор, AЦП, двухпроводной последовательный интерфейс, таймеры/счетчики, сторожевой таймер и система прерывания продолжали работать. Подобный спящий режим в основном останавливает clkCPU и clkFLASH, позволяя при этом работать другим тактовым сигналам.



Режим снижения шума АЦП:

Останавливается работа ЦПУ, но разрешается продолжение работы АЦП, внешних прерываний, слежения за адресом двухпроводного последовательного интерфейса, таймера/счетчика 2 и сторожевого таймера (при разрешении его работы). Этот спящий режим в основном останавливает clkI/O, clkCPU и clkFLASH, позволяя при этом работать другим тактовым сигналам. Это уменьшает внешние шумы АЦП, разрешая выполнять измерения с повышенной разрешающей способностью. Если АЦП включен, то преобразование начинается автоматически при вводе данного режима. Кроме прерывания от завершенного преобразования АЦП, только внешний сброс, сброс сторожевого таймера, сброс от схемы контроля за снижением питания (Brown-out Reset), прерывание при совпадении адреса двухпроводного последовательного интерфейса, прерывание таймера/счетчика 2, прерывание готовности SPM/EEPROM, внешние прерывания по уровню на INT0 или INT1, или внешнее прерывание на INT2 могут вывести МПУ из режима понижения шума АЦП.





Режим хранения:

В этом режиме внешний генератор останавливается, в то время как внешние прерывания, слежение за совпадением адреса двухпроводного последовательного интерфейса и сторожевой таймер (если разрешена его работа) продолжают работать. Только внешний сброс, сброс сторожевого таймера, сброс от схемы контроля за снижением питания (Brown-out Reset), прерывание при совпадении адреса двухпроводного последовательного интерфейса, внешние прерывания по уровню INT0 или INT1 или внешнее прерывание для INT2 могут активировать МK. Этот спящий режим в основном блокирует все генерируемые синхронизирующие сигналы, разрешая работать только асинхронным модулям.

Обратите внимание на то, что если прерывание, срабатывающее по уровню, используется для пробуждения из режима микропотребления, то измененный уровень должен

удерживаться в течение некоторого времени для того, чтобы вызвать активацию МК.

При пробуждении из режима пониженной мощности имеет место задержка, пока

микроконтроллер перейдет в активный режим. Это позволяет перезапустить тактовый генератор и стабилизировать его работу после остановки. Период пробуждения определяется теми же конфигурационными битами CKSEL, которые определяют период сброса.



Режим микропотребления:

Этот режим аналогичен режиму хранения за одним исключением: если таймер/счетчик 2 тактируются асинхронно, т. е. устанавливается разряд AS2 в ASSR, то таймер/счетчик 2 будет продолжать работать во время «сна».

Прибор может пробудиться либо от события переполнения таймера или сравнения выхода от таймера/счетчика 2, если в TIMSK установлены соответствующие разряды разрешения прерывания, а в SREG установлен разряд разрешения глобального прерывания.

Если асинхронный таймер не тактируется асинхронно, то вместо режима хранения рекомендуется режим микропотребления, поскольку содержимое регистров в асинхронном таймере должно рассматриваться как неопределенное после активации в режиме хранения, если AS2 равно нулю.

Этот режим ожидания в основном приостанавливает все тактовые сигналы, за исключением clkASY, разрешая работу только асинхронных модулей, включая таймер/счетчик 2, если тактирование выполняется асинхронно.



Режим ожидания:

Этот режим аналогичен режиму хранения, за исключением того, что генератор продолжает работать. Устройство активируется из режима Standby в течение шести тактовых циклов.



Режим длительного ожидания:

Этот режим аналогичен режиму микропотребления, за исключением того, что генератор продолжает работать. Устройство активируется из режима длительного ожидания в течение шести тактовых циклов.





Режимы работы интегральной микросхемы 1887ВЕ1У и ток потребления:





Для прошивки микроконтроллера используется следующий HEX-файл:



:0200000014C02A

:02000400D0C06A

:020008009AC09C

:0400100058C0E0C034

:14002A00CFE5D2E0CDBFDEBFC451D0400AEA08830024E0E6A5

:14003E00F0E010E0ED36F10711F00192FBCF0083EAE2F0E056

:14005200A0E6B0E010E000E00BBFEA32F10721F0C8953196A1

:140066000D92F9CFC2D0FFCFE199FECF27B620FCFDCF1FBBD9

:14007A000EBB2DBBE29AE19AE199FECF0895E199FECF1FBBC5

:14008E000EBBE09A0DB3089522242EBC89EE8DBD80E28CBD22

:1400A20083E18BBD82E18ABD83E189BD82E188BD83E187BDFA

:1400B60082E186BD2FBC85E08EBD08952A923A924A925A9208

:1400CA008A939A93AA93BA932FB62A9289EE8DBD80E28CBD41

:1400DE0081E090E0A0E0B0E040906B0050906C00209069008D

:1400F20030906A00280E391E4A1E5B1E30926A00209269001B

:1401060050926C0040926B0085E08EBD29902FBEB991A99180

:14011A009991899159904990399029901895222425BC88E00D

:14012E0082BD8FE584BD8FE983BD87E085BD08952A923A9243

:140142004A925A928A939A93AA93BA932FB62A928FE584BDB7

:1401560081E090E0A0E0B0E040906700509068002090650020

:14016A0030906600280E391E4A1E5B1E3092660020926500AE

:14017E00509268004092670087E085BD82B58830E9F72990B9

:140192002FBEB991A9919991899159904990399029901895B3

:1401A6008A938FB78A93F89481E08093620089918FBF8991E1

:1401BA001895222423BE8BE882BF85E78CBF81E0809363001B

:1401CE0085E083BF08952A928A932FB62A928BE882BF222465

:1401E2002092630029902FBE89912990189522242ABA87E03D

:1401F60084BB87EF81BB88E082BBB0993FC029B301E010E06A

:14020A0031DF01E010E03BDF00936400083311F487E085BB07

:14021E0020906400222011F4222425BA80916400883011F41A

:1402320081E085BB80916400803111F482E085BB80916400D5

:14024600803211F484E085BB80916400883111F483E085BB73

:14025A0080916400803311F486E085BB80916400883211F489

:14026E0085E085BB22242ABA2BBA000087E08ABB25B22BBA60

:1402820086B38170813009F0A6C185E489BF80E080936900A0

:1402960080936A0080936B0080936C0080E0809365008093EF

:1402AA006600809367008093680001E010E0E7DE0093640058

:1402BE007894EADE32DF84C08CE090E0A0E0B0E040906B00DC

:1402D20050906C002090690030906A00281639064A065B065B

:1402E60009F04EC0979A22243324309261002092600009C031

:1402FA0080916000909161000196909361008093600080E00F

:14030E009DE720906000309061002816390674F322243324A5

:14032200309261002092600009C0809160009091610001963F

:14033600909361008093600080E09DE72090600030906100A7

:14034A002816390674F322243324309261002092600009C020

:14035E0080916000909161000196909361008093600080E0AA

:140372009DE720906000309061002816390674F388E082BB39

:1403860088E190E0A0E0B0E0409067005090680020906500E6

:14039A0030906600281639064A065B0609F4919A88E190E0FA

:1403AE00A0E0B0E04090670050906800209065003090660071

:1403C200281639064A065B0609F4909A89E190E0A0E0B0E0E8

:1403D6004090670050906800209065003090660028163906DC

:1403EA004A065B0608F46ACF22242092620080E385BF80E8B0

:1403FE008BBF7894E9C080916200813091F4222420926200E9

:14041200949AD3DE809163008130E1F3959ACDDE80916300B0

:140426008130E1F382B3877D82BB8AE891E2A0E0B0E0409002

:14043A006700509068002090650030906600281639064A06F7

:14044E005B0699F480916400883379F4949AAFDE80916300E0

:140462008130E1F3959AA9DE809163008130E1F382B3877D19

:1404760082BB84E193E4A0E0B0E0409067005090680020901A

:14048A00650030906600281639064A065B0699F480916400A3

:14049E00883079F4949A8BDE809163008130E1F3959A85DE03

:1404B200809163008130E1F382B3877D82BB88E296E8A0E05F

:1404C600B0E04090670050906800209065003090660028169A

:1404DA0039064A065B0699F480916400803179F4949A67DE8B

:1404EE00809163008130E1F3959A61DE809163008130E1F39A

:1405020082B3877D82BB80E59CE0A1E0B0E040906700509066

:1405160068002090650030906600281639064A065B0699F473

:14052A0080916400803279F4949A43DE809163008130E1F3E1

:14053E00959A3DDE809163008130E1F382B3877D82BB80EA86

:1405520098E1A2E0B0E04090670050906800209065003090B6

:140566006600281639064A065B0699F480916400883179F4C5

:14057A00949A1FDE809163008130E1F3959A19DE80916300AF

:14058E008130E1F382B3877D82BB84EB9BE5A2E0B0E040908D

:1405A2006700509068002090650030906600281639064A068E

:1405B6005B0649F4969AFFDD809163008130E1F382B3877D55

:1005CA0082BB789485B7806485BF889516CF0895D5

:00000001FF 










2.5. Отладка программы

Отладка программ заключается в проверке правильности работы программы и аппаратуры. Программа, не содержащая синтаксических ошибок тем не менее может содержать логические ошибки, не позволяющие программе выполнять заложенные в ней функции. Логические ошибки могут быть связаны с алгоритмом программы или с неправильным пониманием работы аппаратуры, подключённой к портам микроконтроллера.

Встроенный в состав интегрированной среды программирования отладчик позволяет отладить те участки кода программы, которые не зависят от работы аппаратуры, не входящей в состав микросхемы микроконтроллера. Обычно это относится к вычислению математических выражений или преобразованию форматов представления данных.

	Для отладки программ обычно применяют три способа:

Пошаговая отладка программ с заходом в подпрограммы;

Пошаговая отладка программ с выполнением подпрограммы как одного оператора;

Выполнение программы до точки останова.

	Пошаговая отладка программ заключается в том, что выполняется один оператор программы и, затем контролируются те переменные, на которые должен был воздействовать данный оператор.

Если в программе имеются уже отлаженные подпрограммы, то подпрограмму можно рассматривать, как один оператор программы и воспользоваться вторым способом отладки программ.

Если в программе существует достаточно большой участок программы, уже отлаженный ранее, то его можно выполнить, не контролируя переменные, на которые он воздействует. Использование точек останова позволяет пропускать уже отлаженную часть программы. Точка останова устанавливается в местах, где необходимо проверить содержимое переменных или просто проконтролировать, передаётся ли управление данному оператору.

Практически во всех отладчиках поддерживается это свойство (а также выполнение программы до курсора и выход из подпрограммы). Затем отладка программы продолжается в пошаговом режиме с контролем локальных и глобальных переменных, а также внутренних регистров микроконтроллера и напряжений на выводах этой микросхемы.




3. Тестовый пример

3.1. Контрольный пример



Проверка работоспособности блока управления временем срабатывания производится следующим образом:

После подачи питания на блок УВИ на PB0 подается сигнал и блок начинает работать в режиме 1. В этом режиме с блока формирования сигналов и приема квитанции на контроллер (порт A) поступает код 0x38. Этот код записывается в EEPROM, и после записи обратно на блок формирования сигналов и получения квитанции отправляется код 0x38 для отчета о выполненной записи кода. Далее с помощью блока выбора режима работы блок УВИ переключается в режим 2. В этом режиме из ЭСППЗУ считывается записанный ранее код и запускаются таймеры счетчики для расчета времени готовности и времени срабатывания. Блок управления анализирует код и следит  за значением счетчиков. Когда счетчики AMINUTE и MINUTE отсчитывают 24 (2 минуты) с порта D с 0 и 1-го PINа подается сигнал готовности, а когда счетчик AMINUTE достигает значения 17172 (1 сутки) с порта D с 4-го PINа подается сигнал срабатывания.

PINB = 0x01 // Выбор режима 1 – входные данные 

Режим 1:

PORTA = 0x38 – входные данные

PORTC = 0x07 // индикация кода – выходные данные

PORTA = 0x07 // квитанция – выходные данные 



PINB = 0x00 // Выбор режима 2 – входные данные

Режим 2:

PORTD = 0x03 // Через 2 минуты после запуска 2-го режима – выходные данные

PORTD = 0x10 //  Через 24 часа после запуска 2-го режима – выходные данные

3.2. Результаты тестирования

Тестирования производились с помощью макетной платы с набором переключателей на входе и набором светодиодов на выходе. Были проведены проверки срабатывания сигналов готовности (через 2 минуты) и сигнала срабатывания (1, 2, 3, 4, 5 и 9 суток), также проверена правильность записи и чтения кодов из EEPROM. В ходе проведения тестирования была проверена правильность работы блока управления временными интервалами. В результате 

Результаты проверки входящих кодов и времени срабатывания, приходящих на блок УВИ:



Все входящие коды, как видно из таблицы, были верными.  

Под фактическим временем имеется в виду промежуток времени между запуском блока УВИ в режиме 2 и выдачей боком сигнала срабатывания. Как видно из таблицы, все выходные сигналы срабатывания были получены вовремя, не превышая погрешность в 1%.   





 






Заключение

В процессе выполнения дипломного проекта было разработано программное обеспечение для устройства управления временными интервалами и само устройство. Программное обеспечение было написано на языке Си с помощью IDE Image Craft. Правильность работы программы была проверена совокупностью тестов. В качестве управляющего элемента использовался микроконтроллер МИ 1887ВЕ1У российского производства. Актуальностью данной темы являлось то, что в процессе проектирования ставилась задача спроектировать устройство, которое не имело бы аналогов и отличалось новизной, малыми габаритами, продолжительным временем работы. Рассмотренное в дипломном проекте устройство может использоваться не только в инженерных боеприпасах, но их в других системах, как подсистема, управляющая временем срабатывания устройства. А легкость перепрограммирования микроконтроллера и отладки его работы делает это разрабатываемый блок  универсальным.




Список литературы

Техническое описание КФДЛ.431295.025ТО

Справочник Image Craft C for Atmel AVR

Измерение, управление и регулирование с помощью AVR-микро-контроллеров. Трамперт В. 2006 год.

Микроконтроллеры AVR. Вводный курс. Мортон Д. 2006 год.

Основы цифровой схемотехники. Новиков Ю. В. 2001 год.

Разработка устройств на микроконтроллерах. Белов А. В. 2013 год.

Программирование на языке С для AVR и PIC микроконтроллеров. Шпак Ю.А. 2006 год.

Микроконтроллеры AVR. Практикум для начинающих. Хартов В. Я. 2007 год.

10 практических устройств на AVR-микроконтроллерах. Книга 1 и книга 2. Кравченко А. В. 2008 год.

Микроконтроллеры AVR семейств Tiny и Mega фирмы "Atmel". Евстифеев А.В. 2004 год.

Применение микроконтроллеров AVR: схемы, алгоритмы, программы. Баранов В.Н. 2004 год.

Практическое программирование микроконтроллеров Atmel AVR на языке ассемблера. Ревич Ю. В. 2008 год.

Микроконтроллеры AVR: от простого к сложному. М. С. Голубцов. 2003 год.

Искусство схемотехники. Хоровиц П., Хилл У. 1998 год.






Приложение

Приложение 1

// ICC-AVR application builder : 18.10.2012 8:11:20

// Target : M8535

// Crystal: 1.0000Mhz



#include <macros.h> 

#include <iccioavr.h>

#include <iom8535v.h>

#include <avrdef.h>

#include <eeprom.h>



unsigned long MINUTE, AMINUTE; // Размер: 4 байта; Диапазон: 0..4294967295 

unsigned char CODE; // Размер: 1 байт; Диапазон: 0..255 

char timer_off; // Размер: 1 байт; Диапазон: -128..127

unsigned char FlagInt1;

int i; // Размер: 2 байта; Диапазон: -32768..32767 



void EEPROM_write (unsigned int uiAddress, unsigned char ucData)



{

/* Ожидаем окончание предыдущей записи */

    while (EECR & (1 << EEWE))

    ;

    while (SPMCR & (1 << SPMEN))

    ;

/* Указание адреса и данных */

    EEAR = uiAddress;

    EEDR = ucData;

/* Запись лог. 1 в EEMWE */

    EECR |= (1 << EEMWE);

/* Запуск записи в ЭСППЗУ путем установки EEWE */

    EECR |= (1 << EEWE);

    while (EECR & (1 << EEWE))

    ;



}



unsigned char EEPROM_read (unsigned int uiAddress)



{

/* Ожидание завершения предыдущей записи*/

    while (EECR & (1 << EEWE))

    ;

/* Установка адресного регистра */

    EEAR = uiAddress;

/* Разрешение чтения из ЭППЗУ путем установки EERE */

    EECR |= (1 << EERE);

/* Возврат данных из регистра данных ЭСППЗУ*/

    return EEDR;



}



// TIMER1 initialize - prescale:1024

// WGM: 0) Normal, TOP=0xFFFF

// desired value: 5Sec

// actual value:  4,999Sec (0,0%)

void timer1_init (void)



{

    TCCR1B = 0x00; // stop

    TCNT1H = 0xE9; // setup

    TCNT1L = 0x20;

    OCR1AH = 0x13;

    OCR1AL = 0x12;

    OCR1BH = 0x13;

    OCR1BL = 0x12;

    ICR1H  = 0x13;

    ICR1L  = 0x12;

    TCCR1A = 0x00;

    TCCR1B = 0x05; // start Timer

}

/* #pragma interrupt_handler <func>: <vector>

Объявляет функции как обработчики прерываний, чтобы компилятор генерировал команды возврата из прерывания вместо команд обычного возврата и сохранял и восстанавливал все регистры, используемые функциями прерываний*/

#pragma interrupt_handler timer1_ovf_isr:iv_TIM1_OVF

void timer1_ovf_isr (void)



{

    // TIMER1 has overflowed

    TCNT1H = 0xE9; // reload counter high value

    TCNT1L = 0x20; // reload counter low value

    MINUTE = MINUTE + 1; // Увеличение счетчика на единицу

    TCCR1B = 0x05;

}



// TIMER2 initialize - prescale:1024

// WGM: Normal

// desired value: 5Sec

// actual value:  4,969Sec (0,6%)



void timer2_init(void)

{



    TCCR2 = 0x00; // stop

    ASSR  = 0x08; // set async mode

    TCNT2 = 0x5F; // setup

    OCR2  = 0x9F;

    TCCR2 = 0x07; // start



}



#pragma interrupt_handler timer2_ovf_isr:iv_TIM2_OVF

void timer2_ovf_isr (void)

{



    TCNT2 = 0x5F; // reload counter value

    AMINUTE = AMINUTE + 1;

    TCCR2 = 0x07;

    while (ASSR != 0b00001000);



}



#pragma interrupt_handler int0_isr:iv_INT1

void int0_isr (void)

{

/* Отключение прерываний */

     _CLI ();

     FlagInt1 = 1; // Возведение флага



}



// TIMER0 initialize - prescale:1024

// WGM: Normal

// desired value: 120mSec

// actual value: 119,808mSec (0,2%)



void timer0_init (void)

{

    TCCR0 = 0x00; // stop

    TCNT0 = 0x8B; // set count

    OCR0  = 0x75;  // set compare

    timer_off = 1;

    TCCR0 = 0x05; // start timer

}



#pragma interrupt_handler timer0_ovf_isr:iv_TIM0_OVF

void timer0_ovf_isr (void)



{

    TCNT0 = 0x8B;  // reload counter value

    timer_off = 0;

}



int main (void)

{

/* Начальная инициализация портов */

    DDRA = 0x00; // Все выводы порта A будут сконфигурированы как входы. 

    DDRC = 0x07; // (00000111) Часть выводов порта D будет сконфигурирована как выходы, а часть - как входы (0 – вход, 1 – выход).
    DDRD = 0xF7;

    PORTD = 0x08; // Если вывод сконфигурирован как выход, то единичка в соответствующем бите регистра PORTD формирует на выводе сигнал высокого уровня, а ноль - сигнал низкого уровня.


    if ((PINB & 0x01) == 0) // Если на PB0 не поступает сигнал

    {



        EEPROM_write (1 , PINA); // Записываем сигнал с порта A в EEPROM

        CODE = EEPROM_read (1); // Присваиваем значение, записанное в EEPROM, переменной CODE

/* Далее идет код, отвечающий за светодиодную индикацию информации записанной в EEPROM*/

        if (CODE == 0x38)

        {

            PORTC = 0x07;

        }

        if (CODE == 0x00)

        {

            PORTC = 0x00;

        }

        if (CODE == 0x08)

        {

            PORTC = 0x01;

        }

        if (CODE == 0x10)

        {

            PORTC = 0x02;

        }

        if (CODE == 0x20)

        {

            PORTC = 0x04;

        }

        if (CODE == 0x18)

        {

            PORTC = 0x03;

        }

        if (CODE == 0x30)

        {

            PORTC = 0x06;

        }

        if (CODE == 0x28)

        {

            PORTC = 0x05;

        }



        DDRA = 0x00;

        PORTA = 0x00;

        _NOP ();

/*Пересылка сигнала из EEPROM (отправка квитанции) для проверки*/

        DDRA = 0x07;

        PORTA = PORTC;

    }



    if ((PINB & 0x01) == 1) // Если на PB0 поступает сигнал

    {

        TIMSK = 0x45; // Регистр маски прерывания

/*Задаем начальные значения счетчиков*/

        MINUTE = 0;

        AMINUTE = 0;

        CODE = EEPROM_read (1);

        SEI (); // Разрешаем прерывания

/* Запуск таймера 1 и таймера 2 */

        timer1_init ();

        timer2_init ();



        while (AMINUTE < 25) // Пока не прошло 2 минуты 5 секунд

        {



            if (AMINUTE == 24) // если 2 минуты (Таймер 2)



            {

                PORTD |= 1 << PD1;

            }



            if (MINUTE == 24) // если 2 минуты (Таймер 1)



            {

                PORTD |= 1 << PD0;

            }



        }



        FlagInt1 = 0; // Задаем начальное значение флага

        MCUCR =  0b00110000;

        GICR = 0x80;

        SEI (); // Разрешаем прерывания



        while (1)

        {



            if (FlagInt1 == 1) // Прерывание по внешнему сигналу

            {



                FlagInt1 = 0; // Задаем начальное значение флага

                PORTD |= 0x10;

                timer0_init();

                while (timer_off == 1);

                PORTD &= 0xD7;



            }



            if ((AMINUTE == 17172) && (CODE == 0x38)) // если 1 сутки (Таймер 2)

            {



                PORTD |= 0x10;

                timer0_init ();

                while(timer_off == 1);

                PORTD &= 0xD7;



            }



            if ((AMINUTE == 34344) && (CODE == 0x08)) // если 2 суток (Таймер 2) 

            {



                PORTD |= 0x10;

                timer0_init ();

                while(timer_off == 1);

                PORTD &= 0xD7;



            }



            if ((AMINUTE == 51516) && (CODE == 0x10)) // если 3 суток (Таймер 2)

            {



                PORTD |= 0x10;

                timer0_init ();

                while(timer_off == 1);

                PORTD &= 0xD7;



            }



            if ((AMINUTE == 68688) && (CODE == 0x20)) // если 4 суток (Таймер 2)

            {



                PORTD |= 0x10;

                timer0_init ();

                while(timer_off == 1);

                PORTD &= 0xD7;



            }



            if ((AMINUTE == 85860) && (CODE == 0x18)) // если 5 суток (Таймер 2)

            {



                PORTD |= 0x10;

                timer0_init ();

                while(timer_off == 1);

                PORTD &= 0xD7;



            }



            if (AMINUTE == 154548) // Если 9 суток (Таймер 2) (Самоликвидация)

            {



                PORTD |= 0x40;

                timer0_init ();

                while(timer_off == 1);

                PORTD &= 0xD7;

            }

            _SEI();

            MCUCR |=  0b01000000;

            _SLEEP (); // Запуск энергосберегающего режима 



        }



    }



}




Приложение 2