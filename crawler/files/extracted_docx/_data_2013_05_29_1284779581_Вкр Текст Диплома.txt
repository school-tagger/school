Правительство Российской Федерации



Федеральное государственное автономное образовательное учреждение 

высшего профессионального образования



«Национальный исследовательский университет 
«Высшая школа экономики»



Факультет Бизнес-информатика

Отделение Программной инженерии

Кафедра Управление разработкой программного обеспечения





ВЫПУСКНАЯ КВАЛИФИКАЦИОННАЯ РАБОТА



На тему: Программа моделирования пользовательского плейлиста в многомерной среде для персонализации и рекомендации.











Москва, 2013













































































Аннотация.



Данная работа посвящена изучению существующих рекомендационных систем, исследованию применяемых алгоритмов, нахождению преимуществ и недостатков используемых подходов, а также разработке программы, анализирующей музыкальные предпочтения пользователя и рекомендующей музыкальные произведения для прослушивания. В  первой части работы будут освещены различные рекомендационные подходы : совместной фильтрации, текстовые рекомендации, подход, основанный на полученных данных. Также будут освещены сильные и слабые стороны всех алгоритмов и описаны варианты использования гибридных систем. 

Вторая часть работы описывает реализуемые алгоритмы, технические особенности реализации приложения и выводы, полученные в результате разработки и тестирования. Результатом этой части работы является  разработанное  приложение на c#, основанное  на нескольких рекомендационных алгоритмах (совместной фильтрации), объединенных в гибридную модель, для построения списка рекомендаций в виде песен, основываясь на полученном списке песен пользователя. В заключении будет проведен эксперимент для анализа эффективности работы алгоритмов.





















































Список ключевых слов и определений.



Гибридная модель, рекомендационная система, сингулярное разложение, алгоритм косинусов, исследовательская работа, анализ работы систем.



Алгоритм косинусов – рекомендационный подход, также известный как (“Slope One”/ “Алгоритм соседей”).



Гибридная модель  – рекомендационный алгоритм, совмещающий несколько рекомендационных подходов. 



Плейлист – список пользователя, состоящий из песен.



Рекомендационная система – программа или сервис; задачей является предугадывание предпочтений пользователя, основываясь на полученных данных: история пользователя, пользовательская активность, выбранный набор объектов.



Сингулярное разложение – рекомендационный подход, также известный как (“SVD”(singular value decomposition)).



Холодный старт – распространённая  проблема рекомендационных систем (“Cold-Start problem”), появляется, когда у системы возникает недостаток в анализируемых данных, связанный с тем, что системой пользуется недостаточное количество пользователей.



Контекстные рекомендации – также известные как текстовые рекомендации, основаны на анализе текстовых данных.































Введение.



 Актуальность.



С ростом популярности интернета (Рисунок. 2), увеличивался и объем данных, который можно было почерпнуть  из глобального источника. Появлялись новые форматы, новые типы данных, а  количество сайтов и информации постоянно росло (Рисунок. 1). Интернет стал напоминать громадную мультимедийную библиотеку в руках умелого пользователя, однако для большинства - составляет большую трудность найти желаемое, так как они не ограничены в выборе, но  находятся в условиях нехватки времени, отведенного на поиск. Логичным решением  данной проблемы является отображение только той информации, которая будет  предпочтительна  пользователям, исходя из анализируемых данных пользовательской  статистики. Вследствие чего в мире было разработано множество рекомендационных систем: Amazon, Netflix, TiVo, Youtube, Pandora Radio, Jinny, Internet Movie Database, Hitflip, Indiscover, Value Investing News, AllTheBest, AllFamo. Целью данных систем является предугадывание множества объектов, которые могут заинтересовать  пользователя.  Системы разрабатывались для различных целей и использовали разные алгоритмы рекомендации, постоянно совершенствуя их и усложняя. Так как  у любого алгоритма есть свои сильные и слабые стороны, со временем, многие сервисы начали использовать гибридные подходы для выдачи рекомендаций. 

         

 	                    Рисунок. 1				           Рисунок. 2

  Очень   большой сегмент пользователей ищет в интернете мультимедийный контент: видео, книги, музыку. В связи с этим, особой популярностью пользуются музыкальные рекомендационные системы, так как пользователи постоянно ищут песни для прослушивания (Рисунок. 3,Рисунок. 4), а количество запросов растет  начиная с 2008 года,согласно данным google.Так как существует множество рекомендационных подходов,все они реализоваты для разных целей,один более эффективны. Используя разные подходы,можно получить отличные друг от друга результаты, что в одном случае может привести к успешной рекомендации,а в другом – к негативной реакции пользователя. В таком случае как же себя поведут системы с разными подходами, но одинаковыми пользователями и произведениями? И улучшится ли результат при использовании гибридной модели?





Рисунок. 3









				Рисунок. 4



Цель и Задачи.



Целью моей работы является разработка программы моделирования пользовательского плейлиста в многомерной среде для персонализации и рекомендации. Другими словами, программа должна выдавать список возможных рекомендаций для пользователя, основываясь на его статистике, полученной из базы данных.  

Так как для любого рекомендационного алгоритма нужен обрабатываемый набор данных, то для данной программы необходимо:

1.Данные о песнях (Рисунок. 5).

2.Данные о пользователях (Рисунок. 6).

За основу для данной реализации была выбрана открытая музыкальная база данных million dataset, а в качестве данных для пользователей был взят список пользователей с количеством прослушиваний песен в избранном плейлисте. Поэтому одной из главных задач является реализация обработки этих данных, для создания рекомендаций.

Важной задачей является изучение существующих рекомендационных методов:
метода совместной фильтрации, методы по работе с текстовым содержимым объектов и методы, основанные на полученных данных. Также необходимо реализовать  несколько из них в алгоритме рекомендации песен для анализа эффективности и создания гибридного подхода. Для реализации рекомендационных алгоритмов следует изучить применяющиеся аналоги систем, чтобы проанализировать сильные и слабые стороны алгоритмов. После  завершения анализа существующих систем, необходимо  выбрать  алгоритмы, подходящие для поставленной цели, для последующего применения их в разработке. Когда реализация алгоритмов будет завершена, программу необходимо отладить на тренировочном множестве пользователей для понимания корректности работы алгоритмов. На завершающем этапе программе следует предоставить тестовое множество пользователей для проверки эффективности алгоритмов для  выявления наиболее эффективного алгоритма. Эффективность работы системы может быть оценена с помощью экспертной оценки.









					  Рисунок. 5







					Рисунок. 6

 



















1. Рекомендационные алгоритмы.



Описание существующих методов.



Все существующие системы делятся на несколько больших групп:

Группа Совместной фильтрации

Группа Обработки текстового содержимого 

Группа Обработки полученных данных





1.1.1. Методы Совместной фильтрации.



Первая группа основана на совместной фильтрации [1]. Совместная фильтрация - это метод, который  предоставляет пользователю отфильтрованный  результат  запроса, исходя из сферы интересов этого пользователя, основанный на информации собранной от других пользователей. Данные системы предполагают, что пользователь выделяет сферу своих интересов, проставлением оценок (либо добавлением в избранное), которые система получает, когда пользователь совершает покупки товаров ,просмотры видеозаписей , прослушивания песен. Фактически данные могут собираться явно и неявно[1], поэтому в первом случае системе нужно получать оценки от пользователя ,а во втором- запоминать  прослушанные песни . 

Основная идея этого метода, заключается в том, что пользователи, которые дали одинаковые оценки в прошлом одному и тому же объекту , могут давать схожие оценки одним и тем же другим объектам в будущем. Данный метод широко используется   на Amazon.com[2] , Imdb.com, Reddit,YouTube,  Last.fm. Получив оценки, система сравнивает предпочтения  пользователей и на основе этих данных выдает рекомендации.

У метода совместной фильтрации есть два основных подхода: 

основанный на истории пользователя [3]

основанный на модели.    [4]

Для начала опишем идею  самого популярного метода,  основанного на соседстве пользователей. Задача алгоритма – понять какую оценку поставит пользователь объекту. Для каждого пользователя  a, нужно выявить как сильно его интересы сходны с интересами пользователя b .После этого происходит выборка из множества пользователей и берутся только те ,которые наиболее схожи с b. Оценка дается на основе оценки соседей, которые были отобраны из множества.

Если представить, что множество пользователей и объектов помещены в матрицу R, каждому пользователю соответствует одна  строка а каждому объекту соответствует столбец, пересечение строки и столбца показывает оценку пользователя(Рисунок.  7,Рисунок.  8). Чтобы  вычислить близость векторов-строк пользователей, нужно воспользоваться  формулой косинуса(1)  или законом корреляции Пирсона (2) [5].





  		Рисунок.  7				              Рисунок.  8





                                  (1)



collab(a,b) – мера похожести пользователей a и b, принимает значения  [0,1].

r a,i – значение матрицы ,где  b строка, i столбец. 

Если пользователь не дал оценку для какого-то объекта, соответствующее значение матрицы равно 0.Далее следует сократить количество пользователей давших оценку одному и тому же объекту, установив порог близости, если у пользователя из множества порог превышает установленное значение, то данный пользователь проходит фильтрацию. Все пользователи прошедшие фильтрацию сортируются по убыванию данной величины.



Далее, по алгоритму, вычисляется (взвешенная сумма других оценок [5] ) предполагаемая оценка объекту i (3).





 (3)



- средняя оценка пользователя а.

К средней оценке  пользователя  а прибавляется среднее отклонение

оценки других пользователей из множества Z для объекта i от их средней

оценки. Чем выше оценка collab (a,b), тем ближе пользователь  b к пользователю a ,тем сильнее его коэффициент влияния  на предполагаемую оценки.



Если использовать коэффициент Пирсона, то формула будет следующей:



                                              (4)





I – объекты которые оценены обоими пользователями a и b

–средние оценки пользователей a и b.Чем сильнее похожи профили пользователей, тем ближе результаты к 1,если результат меньше 0 то пользователи не сопоставимы. 

Есть ряд систем, которые используют   данный алгоритм, такие системы  называются системами с моделью Slope one[6] .Известные системы использующие данную модель:hitflip, indiscover, Value Investing News, AllTheBest, AllFamo.К сильной стороне этого подхода можно отнести то, что системе достаточно получать только данные о рейтинге товаров ,но к слабой стороне можно отнести проблему холодного старта системы[7].



1.1.2. Подход основанный на модели.



Также может использоваться подход основанный на моделях, среди них могут быть следующие:
                             

Кластерная модель

Регрессионная модель

модель Байеса

модель Маркова

Семантическая модель





1.1.2.1. Кластерная модель.



Модели кластерного анализа работают с объектами, которые разделены на группы по схожести внутри одной группы, данные группы называются кластерами. Объекты, находящиеся в разных кластерах различаются между друг другом. Существует множество кластерных алгоритмов, которые очень сильно различаются между собой, это вызвано тем, что сам по себе ,термин- “модель кластерного анализа” имеет очень много трактовок и применяется в совершенно разных областях благодаря своей универсальности. Поэтому существует несколько основных групп этого вида моделей: иерархическая, декомпозиционные модели, модели, основанные на плотности выборок. Один из самых популярных методов, это метод k-средних, относящийся к декомпозиционной модели, который заслужил свою популярность благодаря относительно легкой возможности реализации и эффективности. Идея алгоритма заключается в том, чтобы  сумма квадратичного отклонения точек (объектов или пользователей) от центра кластера была уменьшена.[5]



(5)

c-количество кластеров,a K –это множество кластеров ,x – вектор ,u –центр кластера. Большим недостатком данного метода является то, что в системе заранее должно быть задано количество кластеров.



1.1.2.2. Модель Байеса.



	Помимо моделей кластерного анализа широко применяются модели Байеса, всего их существует несколько подвидов. Один из основных- это байесовская сеть, которая является направленным ациклическим графом, каждая вершина в графе представляет случайную переменную ,а дуги графа –это отношение между этими переменными. Чаще всего Байесовские сети используется для разбиения переменных на категории. Очень часто модель Байеса (простую) использует для того ,чтобы давать рекомендацию с помощью категорий, которые предполагают ,что в них может находится множество объектов.[5]



(6)



Xo-размер категории, arg max(classj) оценки  группы пользователей ,объекту j.Другие часто используемые варианты реализации модели  Байеса являются оптимизированным вариантом предыдущей, с помощью добавления ограничений.



1.1.2.3. Регрессионные модели.



Регрессионные модели используются чаще всего для рекомендаций, где задействованы рейтинги  объектов и чаще всего используются вместе с алгоритмами, основанными на нахождении меры близости с помощью косинуса либо коэффициента корреляции Пирсона. Данный подход использует приближенные значения, чтобы выдавать рекомендации, основанные на регрессионной модели:


(7)

X-это множество пользовательских оценок, N-погрешность в оценке пользователя, k-множество пользователей [5].



1.1.2.4. Модель Маркова.



Модель Маркова (Марковский процесс принятия решений)- это модель последовательного принятия решений, “служит математической основой для того, чтобы смоделировать принятие решения в ситуациях, где результаты частично случайны и частично под контролем лица, принимающего решения”. В данных моделях используется набор из следующих данных[8]:

S-это набор состояний

A-это набор действий

R-коэффициент влияния

Tr-переменная отвечающая за переход из состояния в состояние

В качестве рекомендации самая интересная переменная является tr,которая описывает возможность пользователя который выбрал один набор x ,выбрать другой набор y(8).

(8)

c-количество просмотров, покупок, прослушиваний  пользователем группы объектов.

В качестве улучшения для данной модели используют следующий подход: использование ограничений при подсчете количества просмотров приведет к уменьшению вероятности упущения данных(9).

 (9)

Также можно использовать кластеризацию двух групп(10):

(10)



где это символ Кронекера, а  –это  i-ый объект состояния ,а вычисление похожести будет вычисляться с помощью(11):



(11)

Где  –изначальная функция подсчета ,без ограничений либо с ограничениями, которая равна(12)[8]:



(12)





1.1.2.5. Латентно семантическая модель.



Также следует рассмотреть еще одну рекомендационную модель из группы совместных  рекомендаций – латентно семантическую модель ,которые основываются на статистических моделях для распознания групп пользователей по интересам.
Фактически, этот тип модели распознает интересы пользователя, благодаря пересечению или расхождениям интересов  между группами пользователей. Существует несколько видов моделей: аспектная и множественная[5]. По принципу работы данную модель можно сравнить с простым видом нейросети, которая состоит из трех слоев[9](13):

Термины

Множество объектов

Коэффициенты значимости





(13)



Где u и y –это множество пар (пользователь-объект),z –скрытые факторы, а  сумма вероятностей пользователей и объектов, которая равна (k-1)*n независимых параметров. Однако, если учесть тот факт ,что чаще всего приходится работать с рекомендациями пользователей, то модель принимает следующий вид(14):



(14)









1.1.3. Преимущества и недостатки совместного рекомендационного подхода.



Если рассматривать подходы с точки зрения сильных сторон и недостатков, то 
в группе совместной фильтрации можно выделить следующие факты(Таблица. 1):



                         				Таблица. 1





1.2.  Группа Контекстных рекомендаций.



Вторая группа основана на работе с содержимым объектов[10][11][12], текстом, чаще всего используется, когда не доступно необходимое количество оценок для рекомендации .Этот метод лучше всего подходит для рекомендации книг ,но также его можно использовать для выявления и других предпочтений. Каждый объект в данной системе имеет текстовую информацию. Так как в профиле человека хранится информация о купленных или просмотренных объектах  (книгах, статьях, новостях), то на основе этих данных можно выдать рекомендацию. Прежде всего следует найти важные  слова. 

Поскольку чаще всего текстовые данные находятся не в структурированной форме, рекомендационные системы используют алгоритмы морфологического поиска, для того , чтобы слова схожие смыслу ,которые они несут  (день, дневной, полдень) распознавались как одно значение. Они находятся с помощью  формулы TF-IDF[12](15), которая используется для оценки важности слова в контексте документа ,для облегчения алгоритма ,не принимаются в расчет падежи ,склонения слов ,предлоги, местоимения, артикли .



 (15)



TF-нормированная частота появления слова в тексте

frequency(a,X)-частота появления слова а в тексте X

Далее по формуле обратной частоты появления текста(16)[11]:



 (16)



N(x) – общее количество текстов в наборе

n(a,x) –количество документов в которых встречается слово a

Поэтому полное представление TF*IDF выглядит следующим образом(17)[10] :



W(t,d)=(17)



И по формуле коэффициента Дайса [12] (18) находится степень похожести.



 (18)



 tags(Ax)-множество ключевых слов объекта Аx

tags(Ay)-множество ключевых слов объекта Ay

Pandora Radio, Jinny, Internet Movie Database –данные системы работают ,используя  этот алгоритм. К сильной стороне данного подхода можно отнести то, что системе достаточно профиля пользователя ,для анализа рекомендации, однако в данной модели  есть также проблема холодного старта, а также то ,что модель работает в большинство с текстовыми данными(Таблица. 2).



						Таблица. 2





1.3. Группа основанная на полученных данных.



Третья группа основывается на полученных данных[12][13] от пользователя. После получения требований (предпочтений) пользователя, они предлагают выборку объектов, удовлетворяющих требованию. Данные системы делятся на группу использующую жесткие ограничения и на группу фильтрации близких объектов. Различие между этими двумя группами заключается в том , что группа с жесткими ограничениями ищет объекты полностью отвечающие требованием ,а группа фильтрации близких объектов ищет похожие. Основная проблема первой группы заключается в том ,чтобы понять как получить требования от пользователя .Чаще всего используются стандартные выборки данных , которые предлагаются пользователю, далее работают так называемые “if-case”,в зависимости от того ,что выбрал пользователь система подстраивается под выбранный результат. Данные алгоритмы используются в imhonet, isitfinland.com,trip.com (Таблица. 3).





Таблица. 3





1.4. Основные проблемы существующих подходов.



1.4.1.  Проблема нового пользователя.



Для того, чтобы система могла дать рекомендацию, необходимо ,чтобы пользователь оценил ряд объектов и проанализировать предпочтения. Исходя из этого, без каких –либо данных система не может давать точные рекомендации тем пользователям ,которые не проставляют оценки, не добавляют объекты в избранное .

1.4.2.  Проблема нового объекта.



Данная проблема схожа с проблемой нового пользователя. Если объект(песня, товар, фильм, книга) только добавлена, то у данного объекта нет оценок/просмотров/покупок.
Вследствие чего ,система не может порекомендовать этот объект пользователю.

1.4.3. Проблема неопределенных пользователей.



Существуют пользователи ,которые не могут быть классифицированы ,как какая либо другая группа пользователей по ряду причин. Чаще всего они ставят средние балы ,которые не могут характеризовать его отношение к объекту. Так как пользователей такого типа очень мало ,система не может дать им корректных рекомендаций.

1.4.4.  Проблема завышения и занижения оценок.



Также существуют пользователи, которые преднамеренно ставят высокие либо низкие балы объектам. Чаще всего рейтинги не являются действительными и правдивыми, поэтому система выдает некорректные рекомендации.

1.4.5.  Проблема узконаправленных  рекомендаций.



Часто система дает рекомендации только по тем объектам, которые совпадают с объектами пользователя ,а это означает то ,что в качестве рекомендаций ,он увидит только те объекты, которые схожи с его избранными объектами. Иными словами, рекомендации могут быть слишком прямолинейны и очевидны. Часто возникает проблема, что пользователь окружен такими же пользователями, поэтому вся группа попадает в тупик, когда ни один пользователь из этой группы не получит какой-либо неожиданной рекомендации. 





1.4.6. Проблема морфологического разбора. 



Данная проблема возникает в тех случаях, если объекты из разных категорий имеют схожие название, например  книга“ Война и мир ” и настольная игра “Война в мирах”. Получается, что если программа не может проанализировать разницу между этими двумя объектами, то все пользователи ,которые купили данную книгу, получат в рекомендацию настольную игру, что не будет корректным.







1.5. Гибридные системы.



Так как все алгоритмы имеют ряд своих недостатков и преимуществ, со временем стали появляться гибридные рекомендационные системы. Термин  “Гибридная рекомендационная система ” подразумевает ,что данная система совмещает множество рекомендационных подходов, чтобы выдать рекомендацию. Единого мнения о количестве классов гибридных систем нет, однако выделяют 7 основных классов[14]:

Взвешенный

Выборочная

Смешенная

Использующие приращения

Использующие комбинирование

Каскадные

Мета уровневая

Взвешенная модель подразумевает ,что числовые данные ,полученные со всех используемых данных используются при выводе рекомендации.

Выборочная модель, переключается между алгоритмами ,в зависимости ,от набора действий пользователя и данных .

Смешенная модель использует несколько алгоритмов сразу.

Модель использующая приращения берет данные из нескольких источников (напоминает взвешенный подход ) ,чтобы объединить в один.

Модель использует множество подходов ,где один алгоритм считает лишь часть данных и передает полученные результаты в другой алгоритм.

Каскадные –используют алгоритмы по приоритету.

Мета уровневая –один алгоритм создает некое подобие модели ,которая затем используется в другом алгоритме.

Однако, по моему мнению, такая классификация гибридных моделей избыточна. Фактически, количество классов можно сократить до следующих:



Конвейерный

Смешанный

Выборочный



Суть конвейерного[2][12] подхода заключается в том , что весь процесс разбивается на блоки ,а результат выполняемого блока передается следующему в цепочке. Таким образом подходы можно выстроить в таком порядке,чтобы максимизировать точность рекомендаций(Рисунок. 9).



			Рисунок. 9



Объединенный – это подход ,в котором данные поступают в каждый из модулей системы, а затем их результаты подвергаются агрегации и выдается общий результат(Рисунок. 10). Далее существует несколько вариантов ,система может либо смешать все рекомендации, либо  выдать лишь часть множества и отсортировать его  по максимальному результату .

                                       

 							Рисунок. 10



Выборочные системы работают на принципе действий пользователя, используя различные алгоритмы ,для разных наборов действий и информации(Рисунок. 11). Например, если пользователь выбрал какой-то товар,они могу проверить категорию товара, найти пользователей из такой же категории ,тем самым расширяя область рекомендации.



                             

						Рисунок. 11































































2. Описание реализации алгоритмов.



2.1. Диаграмма деятельности.



Для корректной работы алгоритма требуется выбрать  пользователя и задать размер выборки группы пользователей. По умолчанию эти значения заданы, однако пользователь может ввести свои значения. Далее, выводится список песен для   выбранного пользователя. После этого необходимо запустить построение матрицы со слушателей (Рисунок.  12).

                             

Рисунок.  12



Если рассматривать этапы выполнения более подробно,то “Вывод плейлиста пользвателя” происходит следующим образом (Рисунок.  13).Программа переходит в многопоточный режим,запуская второй поток,который отображает состояние выполнения алгоритма.В фоновом потоке,программа посылает запрос к базе данных пользователей,получая плейлист указанного пользователя,а затем посылает запрос к базе данных с песнями,получая названия песен.



			            Рисунок.  13



Построение матрицы со слушателей тоже трудоёмкий процесс(Рисунок.  14). В первом потоке алгоритм находит пользователей с похожими плейлистами,а затем фильтрует пользователей по совпадающим спискам песен,после чего происходит  построениеы матрица со слушателей.Второй поток анализирует стадии выполнения первого потока.
По завершению построения матрицы со слушателей,программа отключает много поточный режим.





			                   Рисунок.  14



Когда процесс построения матрицы закончен (Рисунок.  15), программа может работать либо с гибридной моделью, либо с одиночной, если гибридный алгоритм выключен , то приложение может работать либо в ручном режиме либо в автоматическом. Если программа работает в ручном режиме, то используются введенные пользователем значения, если  выбран автоматический режим, то программа использует оптимальный шаблон с предустановленными значениями. Далее выполняются выбранные алгоритмы, которые выдают список рекомендаций. 





						Рисунок.  15



В алгоритме “соседей”(Slope One) ,сначала вычисляется мера близости пользователей. Затем программа вычисляет оценку, для выбранного пользователя и генерирует список песен.(Рисунок.  16)



Рисунок.  16



В алгоритме  “SVD” в первом потоке программа выполняет сингулярное разложение матрицы со слушателей, далее, для указанного пользователя находятся оценки для песен и происходит построение списка песен для рекомендации (Рисунок.  17).



Рисунок.  17

В первом потоке гибридной модели происходит выполнение алгоритма “Slope One” на нескольких выборках, затем программа выполняет алгоритм “SVD”,после этого происходит смешивание результатов алгоритмов “Slope One” и “SVD”(Рисунок.  18) . 



               

     Рисунок.  18



Во время алгоритма построения списков ,в первом потоке программа обращается к базе данных песен, для того чтобы получить названия песен, затем происходит построение списка песен, далее алгоритм отсылает данные для построения графика.(Рисунок.  19)





            

                                                     Рисунок.  19





















2.2. Алгоритм Соседей.



Для реализации первого рекомендационного подхода была выбрана группа Совместной фильтрации, основанная на алгоритме соседей. Предположим, что есть пользователь “a” и пользователь “b”, у которых есть избранные объекты. Тогда основная идея данной рекомендации заключается в том ,что пользователь “a” и пользователь  “b” могут иметь один и тот же избранный объект, который понравился как пользователю “a” , так и пользователю “b”, поэтому пользователю “a” в будущем могут понравиться те объекты, которые есть у пользователя  “b”.Так как в качестве входных данных имеется  база данных с информацией о пользователях , объект(добавленный в плейлист ) и количество прослушиваний, то при использовании данного подхода, алгоритм сможет использовать все необходимые данные для рекомендации. Исходя из того, что программа должна делать рекомендацию по списку песен выбранного пользователя  и предоставлять песни в виде рекомендации, рекомендационный подход, который будет использоваться в данном алгоритме, основан на пользователях.

Однако, прежде чем использовать данный алгоритм, ему нужно передать данные в необходимом “формате”, а именно, должна быть построена матрица  AY,где пересечение строки и столбца (пользователя и песни) – это информация о том добавлена ли песня в список пользователя или нет, если  добавлена -1, если не добавлена - 0(Рисунок.  20).







Рисунок.  20



Но чтобы получить  данные в таком формате, их следует обработать. Первоначальная информация представляет из себя список пользователей, полученный в результате json запроса c сервиса echoid, который находится в файле формата “.xsl”. В каждой строке есть 3 значения, разделенных “;” : 

Закодированное имя пользователя.

Идентификационный номер песни.

Количество прослушиваний.

Для удобства работы данный файл был преобразован в формат “sqlite”, и каждому пользователю был добавлен столбец с цифровым именем для удобства чтения. Фактически, на следующем этапе, все подобные реализации строят матрицу, однако все доступные аналоги работали с выборкой в 12 тысяч человек, в наборе данных для данной программы использовалась выборка в 79 тысяч человек с общим количеством  уникальных песен в 140 тысяч(примерно 1.1 млн. записей в базе данных ).Если строить такую матрицу для всех пользователей и всех песни, то размера массива массивов( не хватит, если же строить массив который будет храниться в оперативной памяти компьютера, то построение займет много времени, а лимит оперативной памяти , выделяемой на массив будет превышен. Поэтому было принято следующее решение:  

Выбрать пользователя.

Получить список песен.

Сделать выборку пользователей.

Произвести построение матрицы.

После выбора пользователя “a”, следует обратиться к базе данных для получения списка пользователей, у которых есть хотя бы одна песня из списка пользователя “a”, так как  на одного пользователя может быть несколько записей, запрос будет отсортирован, по количеству совпадающих песен на пользователя, поэтому на первых позициях идут пользователи с максимальным сходством плейлиста. Далее, для того чтобы сократить размер  выборки, следует выбрать “Top N ” (n-ое количество первых пользователей), так как у пользователей с низкими позициями есть очень мало совпадающих песен в плейлисте, что будет негативно влиять на рекомендацию. После того, как запрос отфильтрован, матрица может быть построена.

	По завершению построения матрицы ,рекомендационный алгоритм может быть применен:

Найти меру близости.

Отфильтровать людей с мерой близости выше определенного значения.

Найти песни, которые могут понравиться пользователю “a”, на основе оценок  отфильтрованной группы пользователей.

Меру близости можно искать многими способами, в данном случае используется косинус между векторами. 



   (19)



В данной формуле, в числителе мы попарно перемножаем значения в ячейке пользователя 
а(  ) и пользователя b ( для i-той песни на множестве песен Y,получая  множество общих песен. В знаменателе находится произведение корней из количества песен пользователя a и пользователя b.Данная формула применятся для каждого пользователя b из  полученной выборки “Top N” для нахождения близости с пользователем a.В итоге будет получен список Z пользователей с мерой близости к пользователю “a” к диапазоне от [0;1].На данном шаге также желательно найти среднюю оценку для каждого пользователя ,для того чтобы использовать полученные данные на третьем этапе.

Далее, чтобы увидеть разницу в результатах при изменении коэффициента, можно отфильтровать схожесть по первым n пользователям (с максимальной величиной схожести),  либо установить значение фильтра от  0.1 до максимальной величины в выборке. 

Так как имеется множество Z близких пользователей, можно перейти к третьему шагу, для нахождения песен, которые могут понравиться пользователю. 

                          (20)



Фактически, чем выше схожесть пользователя b из множества Z ,к пользователю a ,тем большее влияние он будет оказывать на конечную оценку.  – это средняя оценка пользователя b из множества Z, collab(a,b) –мера схожести пользователя a b пользователя b из множества Z,обе этих величины , вычислены на первом шаге. В результате будет получено множество песен, из которых мы выбираем те, у которых есть оценка. Данные песни и будут списком  идентификационными номерами  треков для рекомендации. 



2.3. Сингулярное разложение.





Данный метод (Сингулярное разложение –SVD(Singular Values Decomposition)) –один из алгоритмов, используемый при работе с матрицами в рекомендательных системах, для того, чтобы выделить те объекты, которые могут понравиться пользователю. На вход подается матрица M, где столбец  j –песня, а строка  i – пользователь, пересечение столбца и строки показывает добавлена ли песня в избранный список песен пользователя (Рисунок. 21).



			



			                Рисунок.  21



Поэтому сингулярным разложением данной матрицы M будет :

                                          		    (21)

M-унитарная матрица (m x n),U- унитарная матрица (m x m), - диагональная матрица (m x n), V* -транспонированная унитарная матрица (n x n). 

Так как сложность данного алгоритма растет с размером матрицы ,а время затраченное на вычисление увеличивается, то для данного алгоритма используется ряд ограничений для снижения вычислительной сложности .Также как и в первом алгоритме, используется выборка из N пользователей, у которых максимально похож плейлист. На следующем этапе следует сократить размер диагональной матрицы. Так как на диагонали значения предоставлены в убывающем порядке, следует установить порог фильтрации, после которого все оставшиеся значения отбрасываются (Рисунок.  22)



			

					

                                                     Рисунок.  22







Обычно матрицу урезают до минимального значения, которое больше 0 (Рисунок.  23).



	     			 



				            Рисунок. 23



Однако данный подход не эффективен в случае с рекомендациями песен, так как минимальное количество песен, которое есть в плейлисте у любого пользователя не меньше 6,поэтому на 50 пользователей в среднем приходится около 500 песен. Исходя из этого, на диагонали выбирается N максимальных значений (Рисунок. 24).



					



					     Рисунок. 24



В матрице U сокращается количество столбцов, а в матрице  -количество строк, согласно ново размерности матрицы E.Данные ограничения помогают повысить эффективность работы алгоритма на больших выборках и уменьшить время работы.

В результате данных преобразований получается матрица ,в которой даны оценки тем песням ,которые пользователи еще не послушал. Так как строка соответствует пользователю i ,алгоритм выбирает нужную строку ,находя столбцы отличные от нуля, которые будут идентификационными номерами песен для рекомендации.

		

2.4. Гибридная модель.



	Гибридная модель используется для улучшения результатов рекомендационной системы, иными  словами, она применяется в тех случаях, когда необходимо нивелировать недостатки подходов, максимизируя их преимущества.

Прежде чем строить гибридную модель ,нужно понять преимущества и недостатки реализованных алгоритмов. Если рассмотреть алгоритм ,"основанный на косинусах", из-за ограничений у него появляется ряд недостатков (Таблица.  4):





Таблица.  4



Если же рассмотреть сингулярное разложение матрицы, то этот метод больше направлен , на поиск песен ,которых нет у пользователя и вывод максимального количества предположительных рекомендаций (Таблица.  5):



					            Таблица.  5



Для того ,чтобы минимизировать недостатки обоих подходов был использован следующий алгоритм(Рисунок.  25):

Использование разных выборок для алгоритма ("косинусов").

Объединение результатов.

Выборка лучших значений.



						Рисунок.  25



	В  ходе тестирования алгоритма (Slope One ("косинусов")) было выявлено, что не всегда получается найти оптимальное значение, для пропускного порога. Например, у одного пользователя могут быть "редкие " музыкальные предпочтения, поэтому при рассмотрении выборки из первых 20 пользователей, система может  занизить результаты.
Поэтому ,для гибридной модели выборка проходила на нескольких этапах:

Взять первых 10 пользователей.

Взять первых 15 пользователей.

Взять первых 20 пользователей.

Сравнить выборки.

Смешать выборки.

Создать новую выборку Y.

Данный диапазон был выбран, так как в этом диапазоне результаты максимально зависят от пропускного значения и имеют самые высокие показатели. В гибридной модели не использовался процентный порог, так как данную величину трудно подобрать для каждого пользователя. Для  того ,кто слушает популярную музыку ,это значение может подыматься до 40-50 %,а для человека с изощренными вкусами это значение может упасть до отметки в 10-15%. В случае ,когда используется выборка из первых n  людей, проблема с коэффициентами  не возникает.

После того как вычисления выполнены, алгоритм сравнивает значения полученных выборок, создавая новую, дополненную, используя следующие условия при парном сравнивании:

Если в выборке a отсутствует значение выборки b,то ключ(идентификационный номер песни)-значение(коэффициент) добавляются в выборку a.

Если ключи в обеих выборках совпадают, то сравниваются значения и сохраняется то значение, которое больше.

Таким образом ,мы получаем максимальные значения из трех выборок, уменьшая возможность пропустить объекты ,которые могут отсутствовать в более узких выборках. Конечный результат передается для "смешивания" с результатом полученным в ходе сингулярного разложения, используя аналогичный алгоритм для сравнивания объектов в выборках:

Получить выборку сингулярного разложения.

Сравнить выборкой Y.

Смешать выборки.

Создать новую выборку Z.

Из полученной выборки Z ,мы сможем вывести рекомендации.













































































3. Технологический раздел.

3.1. Инструментарий.



Для разработки данной программы использовался следующий инструментарий:

Microsoft Visual Studio 2010

Mathnet

SQLite

.Net 4.0

 Код программы написан на языке C#,с использованием Windows Forms(Рисунок.  26).Данный язык был выбран из-за того, что на нём отсутствуют реализации подобных рекомендательных алгоритмов. В ходе разработки программный код был написан  с использованием много поточности (Рисунок.  27) , из-за того что выполнение запросов приводило программу в нефункционирующий режим до тех пор, пока запрос не будет выполнен. Для того, чтобы программа могла отсылать запросы  базе данных, использовалась библиотека System.Data.SQLite.





					     Рисунок.  26

Для алгоритма преобразования матрицы сингулярным разложения была использована библиотека Mathnet.Графики были построены с помощью стандартной компоненты Chart Control(Рисунок.  28).





						Рисунок.  27

В программе была реализована ручная настройка, для изучения полученных результатов и последующей настройки гибридной модели.

Алгоритмы были реализованы в следующей последовательности:

1.Реализация модели Slope one,изучение ее недостатков, нахождение оптимальных значений для выборки.

2. Реализация модели SVD, изучение ее недостатков, нахождение оптимального порогового значения.

3. Реализация гибридной модели.



						Рисунок.  28



3.2. Структура.



В качестве входных данных имеются два файла:

Данные о композициях

Данные о пользователях

Данные о композициях ,представляют собой файл (~700 мегабайт) с записями примерно о миллионе песен с информацией об артисте, названии песни, названии альбома и другой информацией о песнях.

В данных о пользователях есть информация о идентификационном номере песни и количестве прослушиваний пользователем. Данные о  пользователях - это динамические данные, которые постоянно обновляются, они хранятся в отдельной базе данных от базы данных песен. Поэтому структура  программы  имела бы следующий вид (Рисунок.  29).



							Рисунок.  29



Программа использует идентификационные номера, и лишь потом, по окончанию выполнения алгоритма, посылает запрос  к базе данных с песнями, чтобы получить имя песни и автора по идентификационному номеру.

Однако, блок “Алгоритм ” следует рассмотреть более детально (Рисунок.  30):



						Рисунок.  30



Для того, чтобы получить исходный список песен пользователя , программа выполняет ряд методов:

Обратиться к базе данных пользователей.

Получить список идентификационных номеров песен указанного пользователя.

Обратиться к базе данных песен.

Получить список песен, согласно их идентификационным номерам.

Еще один раз программа обращается к базе данных песен, когда уже имеется список идентификационных номеров для рекомендации.





3.2.1.  Структура базы данных пользователей.



Представляет собой таблицу “Userplaylist”, где каждая запись содержит данные  о пользователе  с именем “name”,идентификационным номером пользователя “trackid”, количестве прослушиваний “count”  песни “trackid” пользователем “name”(Рисунок.  31).



   Рисунок.  31



name- числовое имя пользователя.

echoid-закодированное имя пользователя.

trackid-идентификационный номер трека.

count-количество прослушиваний трека.

3.2.2.  Структура базы данных песен.



Структура базы данных песен представляет собой таблицу “songs”,где каждая запись содержит данные о (Рисунок.  32 ) :

песне(trackid,title,duration,release,year,track_7digitalid)

исполнитель(artist_id, artist_name, artist_familiarity, artist_hotttnesss)



Рисунок.  32

trackid-идентификационный номер песни.

title-название песни.

release- название альбома.

artist_id –идентификационный номер артиста.

artist_mbid-второй идентификационный номер артиста.

duration-длительность песни.

artist_familiarity-узнаваемость артиста.

artist_hottnesss-популярность артиста.

year-год выпуска песни.

track_7digitalid-идентификационный номер сервиса 7digital.



3.3. Режимы работы.



Для успешной реализации гибридной модели и изучения работы отдельных алгоритмов программа была реализована в нескольких режимах работы(Рисунок.  33) :

Ручной режим.

Автоматический режим.



Рисунок.  33



В ходе разработки ручной режим помог найти оптимальные пороговые значения для фильтрации песен и пользователей, вследствие чего ,на полученных данных был разработан автоматический режим работы программы, который берет значения по умолчанию. В ручном режиме, пользователь может изучить алгоритмы более детально и понять как объем выборки и ограничения могут влиять на выбранный алгоритм с помощью ввода своих значений (Рисунок.  34) .





                 

Рисунок. 34



В автоматическом режиме оператору нет необходимости вводить значения, так как в алгоритме уже заданы оптимальные значения для выдачи рекомендаций (Рисунок.  35).





Рисунок. 35





3.4.  Диаграмма классов.



Основные переменные, которые используются в форме MainForm (Рисунок.  36) :

bgcheck- флаг,булевая переменная.

cleanslope-словарь(key,value) для результата алгоритма соседей.

cleanslope10-словарь (key,value) для различных выборок.

cleanslope15--словарь (key,value) для различных выборок.

cleanslope20-словарь (key,value) для различных выборок.

cleansvd- словарь (key,value)для результата алгоритма сингулярного разложения.

colist- матрица “со слушателей”(соседей).

metadata-данные для запроса в sqlite.

conn-данные для подсоединения к sqlite.

dc-словарь (key,value)для обработки значения алгоритма косинусов.

fillrecs-флаг,булевая переменная.

graph –форма для отображения графиков.

id_count-индексация общего количества песен.

matrix- матрица для объединения “со слушателей”.

name- строка с  названиями песен.

names –строка с   запросом  к базе данных идентификационных номеров.

playlist-исходный плейлист слушателя.

prediction-словарь (key,value) хранящий “пожесть” пользователей.

request-строка  с запросом к базе данных.

requestsongs-строка с запросом к базе данных,изначального пользовательского плейлиста.

showplay-флаг,булевая переменная.

sl-флаг,булевая переменная

songs-массив композий.

sv-флаг,булевая переменная

track2metasongs-строка с запросом перевода идентификаторов в названия песен.

                                               

 				               Рисунок.  36



Основные методы ,которые используются в форме MainForm (Рисунок.  37) :

GetUser - метод получения списка пользователей.

GetSong -метод получения списка песен.

svd -метод сингулярного разложения.

showrec -метод соседей.

combine -метод объединения выборок.

killbill -метод очистки второго потока.

vanish -метод очистки значений.

bgex -метод запуска второго потока.

drawrec -вывод в datagridview.

showsongrec- преобразование в список песен для метода drawrec.     

  

                                      

     				Рисунок.  37



Основные переменные, которые используются в форме TableForm (Рисунок.  38):

clean- словарь(key,value) ,хранящий рекомендации.

incl- угол наклона .

mp_dwn –точка на графике.

rotate-угол поворота.



Основные методы, которые используются во форме TableForm (Рисунок.  38):

chart1_MouseDown-движение мышью вниз.

chart1_MouseUp- движение мышью вверх.

chart1_MouseMove –движение мышью.

TableForm –метод инициализирующий форму и передающий значение с главной формы.



Рисунок.  38







3.5. Реализация много поточности.



В связи с тем , что большинство описанных алгоритмов весьма трудоёмкие, они не могут быть выполнены приложением в течении нескольких секунд. Если в приложении не реализована много поточность (multithreading),то оператору становится крайне сложно работать с данным приложением:

При большинстве трудоёмких алгоритмов программа будет  переходить в режим 

“ Не отвечает”.

Пока выполняется метод, элементы формы окна перестают работать.

Пользователь не знает, на каком этапе выполнения находится процесс.

Из-за вышеперечисленных недостатков была использована много поточность в следующих алгоритмах:

Запрос и получение исходного списка песен пользователя.

Построение ковариационной матрицы.

Алгоритм Slope One.

Алгоритм SVD.

Гибридная модель.

Запрос и получение списка песен для рекомендации



Вследствие чего приложение получило ряд преимуществ над одно поточным:

При выполнении трудоёмких алгоритмов ,программа работает без сбоев.

Приложение сообщает пользователю о прогрессе, в процессе выполнения алгоритма.

В процессе выполнения, пользователь может производить настройки формы.















































































4. Основные результаты и выводы.



Основной целью было создание гибридной модели и проверки ее эффективности. В данной секции будут описаны основные итоги  и выводы по определению размера выборки, нахождению порога фильтрации, использованию рекомендационных алгоритмов, а также по проверки эффективности работы гибридной модели.



4.1. Определение размера выборки.



Размер выборки меняется в пределах 50 -500 пользователей, однако в ходе текстов ,было выявлено, что необходимый и достаточный размер выборки равен 50 пользователям из-за того, что в ходе запроса к базе данных, пользователи  сортируются по количеству совпадающих песен, поэтому пользователи, у которых количество совпадающих песен выше ,чем у остальных пользоватлей, попадают на первые позиции возвращаемого списка, остальные пользователи( которые не вошли в выборку) имеют меньшее количество совпадающих песен и имеют “небольшой вес” в итоговой оценке.



4.2. Нахождение порога фильтрации.



Порог фильтрации необходим для уменьшения выборки людей и нахождения максимально похожих. Чаще всего данная величина находится после ряда тестовых экспериментов. Для того, чтобы найти подходящее множество значений, программа может работать  в двух режимах: автоматическом и ручном. Поэтому в ходе тестовых экспериментов необходимо было найти оптимальные значения для алгоритмов “Slope One” и “SVD”.

В ходе тестовых испытаний было выявлено несколько особенностей алгоритма “Slope One”. В ручном режиме ,программа предоставляет пользователю выбор порога фильтрации, либо в процентом эквиваленте меры похожести людей ,либо выбора первых “N” пользователей( Рисунок.  38) .



					       Рисунок.  38

Когда у человека был “специфичный плейлист” ( другими словами, он слушал не популярные композиции) или пользователь не имел ярко выраженных предпочтений, коэффициент “K” становился ниже. Это было вызвано рядом причин:

Как было сказано ранее пользователь может иметь малое количество песен в плейлисте, которое совпадает с песнями в плейлистах других пользователей.

В свою очередь, малое количество совпадающих песен, влияет на понижения величины похожести пользователей, которая и является фильтруемой величиной.

Программа автоматически понижает коэффициент “K”, исходя из максимального значения величины похожести пользователей (Рисунок.  39) .



					 Рисунок.  39

В связи с этим был сделан вывод, что для всех новых пользователей  и пользователей с “не похожими” списками песен, данная величина будет не эффективна:

Для пользователя с популярным плейлистом (список песен, в котором не менее 30%  песен выбранного пользователя  “a” совпадают  хотя бы с одним другим плейлистом) величина “K” колеблется в диапазоне от 35% до 58%.

Для пользователя с непопулярным плейлистом (список песен, в котором  менее 30%  песен выбранного пользователя  “a” совпадают  с любым другим плейлистом) величина “K” колеблется от 10% до 25%.

Однако, если фильтрация будет производиться с помощью “Top N Users” (первых “N” пользователей), программе становится не важно пороговое число для пользователя. Важно- количество пользователей ,которых следует пропустить через фильтр. Именно таким способом можно избежать проблемы с разными коэффициентами ,для разных пользователей, так как для алгоритма будет важным лишь количество максимально похожих пользователей, которые будут влиять на рекомендацию. Поэтому основой трудностью было найти количество пользователей, которых следовало “пропускать”(Рисунок.  40) . В ходе тестов было выявлено, что оптимальное количество людей для фильтрации находится  в множестве от 10 до 20 “первых N пользователей”, однако даже в этой выборке есть свои недостатки:

Для ряда пользователей с непопулярным плейлистом, фильтрация первых 10 пользователей урезает общее множество рекомендаций.

Для ряда пользователей с популярным  плейлистом,  фильтрация первых 20 пользователей может понизить коэффициенты песен с высоким рейтингом.



					Рисунок.  40

Исходя из этих данных, гибридная модель использовала выборки 10, 15, 20 людей и смешивала полученные результаты.

Используя модель сингулярного разложения, нужно было  также найти  оптимальное количество значений для диагональной матрицы, которое следует использовать для выборки. Данное значение следует найти по ряду причин:

Если не производить фильтрацию и отсеивать только нулевые значения с диагонали, фильтрация будет иметь повышенную сложность при вычислении (из-за большего размера матрицы), рекомендации будут иметь заниженные значения.

Если найти оптимальное “отсекаемое” количество значений, то можно значительно снизить нагрузку на систему и повысить точность рекомендаций.

В данном случае использовался также подход первых “N” значений. Эффективнее всего алгоритм работает на выборке от 3 до 20 (Рисунок.  41).



Рисунок.  41





4.3. Использование гибридной модели.



Гибридная модель должна минимизировать недостатки используемых подходов и использовать их преимущества. В ходе тестовых испытаний ,среди недостатков было выявлено ,что :

Модель “Slope One” ограничивает выборки.

Модель “SVD” имеет более низкую точность, по сравнению с “Slope One”.

Было принято решение использовать смешанную гибридную модель, для объединения результатов каждого из подходов и выборки максимальных значений. В результате , гибридный алгоритм приобрел следующие свойства(Рисунок.  42) :

Большее  количество рекомендаций.

Повышенная точность рекомендаций.

Обход  дилеммы с выборкой “N” пользователей.

Однако для того ,чтобы понять эффективна эта модель или нет, следует оценить эффективность данной модели. Для оценки эффективности модели использовался метод экспертной оценки, который будет рассмотрен далее.





				          Рисунок.  42



4.4. Эксперимент.



Эксперимент проходил следующим образом:

Была собрана группа экспертов ,которая оценивала рекомендации, которая были сделаны пользователям.

Каждый эксперт независимо оценивал рекомендации системы для каждого пользователя.

На основе независимых оценок экспертов, были подведены итоги.

После запуска программы были выбраны случайные пользователи (их список будет приведен ниже),для каждого пользователя выводился изначальный плейлист(Рисунок.  43).



						Рисунок.  43



Затем для каждого выбранного пользователя, строилась матрица со слушателей (Рисунок.  44)





Рисунок.  44



По завершению процесса построения матрицы, выводилось сообщение (Рисунок.  45).



						  Рисунок.  45

По завершению построения матрицы , следует запустить гибридный алгоритм ,который разбит на два этапа(Рисунок.  46, Рисунок.  47).По заврешению каждого этапа выдается сообщение.

                                                     

Рисунок.  46



        

Рисунок.  47

После завершения работы алгоритма ,следует отобразить список песен для рекомендации,нажав кнопку вывести рекомендации.

По окончанию построения списка рекомендаций ,программа выдаст уведомление(Рисунок.  48)  и построит плейлист (Рисунок.  49).



Рисунок.  48





Рисунок.  49





Эксперты оценили рекомендации для следующих  пользователей (Таблица.  6).



					            Таблица.  6

Пользователи выбирались случайным образом. В качестве результата бралось усредненное значение от  средней оценки всех экспертов для плейлиста одного пользователя, который состоял из первых n песен( в среднем от 3 до 5 песен), было получено около 300 оценок . В предоставленной таблице даны средние оценки экспертов (строка), за плейлист с рекомендациями  пользователей (столбец) (Таблица.  7) .

					

					         Таблица.  7

Для того чтобы, можно было вычислить среднее арифметическое , необходимо проверить нормальность распределения выборки (Таблица.  8) .





                                                                  Таблица.  8 



Средняя оценка экспертов на каждый список песен предоставлена ниже (Таблица.  9):

					

                                                                  Таблица.  9







					    Рисунок.  50

Исходя из полученных данных, можно сделать вывод, что на случайной выборке людей, программа выдает “точные” рекомендации, а все средние оценки (Рисунок.  50) выше 4 и колеблются в диапазоне от 4.2 до 4.6, согласно мнению экспертов.











































Библиография.



[1].  Goldberg , K.(2001).Eigentaste: A Constant Time Collaborative Filtering Algorithm  . Information Retrieval, 4(2), 133–151.

[2]. Greg Linden, Brent Smith,Jeremy York/Amazon.com

[3]. Bell, R. & Volinsky, C. & Koren, Y. (2009) Matrix Factorization Techniques for Recommender Systems. IEEE Computer,42(8), 42-49.

[4]. Hu, Y. & Koren, Y.& Volinsky, C. (2008).Collaborative Filtering for Implicit Feedback Datasets. IEEE International Conference on Data Mining ICDM , 263-272.

[5]. Xiaoyuan S. & Taghi M. (2009). A Survey of Collaborative Filtering Techniques. Advances in Artificial Intelligence ,2009(2009), 1-19.

[6]. Daniel Lemire, Anna Maclachlan, Slope One Predictors for Online Rating-Based Collaborative Filtering, In SIAM Data Mining (SDM'05), Newport Beach, California, April 21–23, 2005.

[7]. Andrew I. Schein, Alexandrin Popescul, Lyle H. Ungar, David M. Pennock (2002). "Methods and Metrics for Cold-Start Recommendations". Proceedings of the 25th Annual International ACM SIGIR Conference on Research and Development in Information Retrieval (SIGIR 2002). New York City, New York: ACM. pp. 253–260. ISBN 1-58113-561-0. Retrieved 2008-02-02.

[8]. Guy Shani, Ronen I. Brafman, David Heckerman .An MDP-based Recommender System,2012.

[9].  Thomas Hofmann: Latent semantic models for collaborative filtering. ACM Trans. Inf. Syst. 22(1): 89-115, (2004).

[10]. Giovanni Semeraro & the SWAP group.

[11]. Michael J. Pazzani,Daniel Billsus.The Adaptive Web.Lecture Notes in Computer Science Volume 4321, 2007, pp 325-341 .

[12]. Системы рекомендаций: обзор современных подходов А.Г. Гомзин, А.В. Коршунов

[13].  Daniel Mican,Nicolae Tomai.Current Trends in Web Engineering,Lecture Notes in Computer Scince Volume 6385,2010,pp85-90.

[14]. Robin Burke 	School of Computer Science, Telecommunications and Information Systems, DePaul University, Chicago, Illinois,2007.







