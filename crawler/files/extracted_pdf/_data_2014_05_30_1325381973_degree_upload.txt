ПРАВИТЕЛЬСТВО РОССИЙСКОЙ ФЕДЕРАЦИИ 

НАЦИОНАЛЬНЫЙ ИССЛЕДОВАТЕЛЬСКИЙ УНИВЕРСИТЕТ 

«ВЫСШАЯ ШКОЛА ЭКОНОМИКИ» 

Факультет Бизнес-информатики, отделение Программной инженерии 

Кафедра Управления разработкой программного обеспечения 

ВЫПУСКНАЯ КВАЛИФИКАЦИОННАЯ РАБОТА по 

направлению 231000.62 Программная инженерия 

подготовки бакалавра 

На тему Система распределенного кэширования данных  

сервера приложений с поддержкой приоритетов 

Студента группы № 472ПИ ______________________ Хохрякова И. С. 
«___» _________ 2014 г. !
!
Научный руководитель 
К. т. н., доцент кафедры УРПО ____________________ Брейман. А. Д. 
«___» _________ 2014 г. 

 

!!!
!
!!

Москва, 2014

 
54 страницы, 4 главы, 3 иллюстрации, 8 источников, 4 приложения. 

  

!

кэширование данных, распределенная система кэширования, алгоритм кэширования, клиент-
серверная архитектура, консистентное хэширование 

!

В данной работе рассматривается разработка распределенной системы кэширования данных 
с  реализацией  алгоритма  вытеснения,  учитывающего  приоритет  кэшированных  данных.  В 
работе  описаны  причины  использования  распределенных  систем  кэширования  данных  при 
разработке и эксплуатации веб-приложений и приведен обзор ряда существующих решений. 
Подобные  системы  являются  хорошо  известным  и  широко  распространенным  способом 
повышения  производительности  веб-приложений,  позволяющим  снизить  нагрузку  на 
источники данных приложения, такие как сервер баз данных, за счет кэширования данных в 
оперативной памяти сервера. Однако особенности реализации традиционных решений, такие 
как используемый алгоритм вытеснения данных из кэша, могут приводить к недостаточной 
эффективности  системы  в  ряде  случаев,  что  обуславливает  актуальность  разработки 
распределенной  системы  кэширования  с  алгоритмом  вытеснения  данных,  основанном  на 
приоритезации хранимых в кэше данных. 

!

Целью  работы  является  разработка  описанной  системы  и  проведение  сравнительного 
эксперимента  с  использованием  традиционных  решений.  В  работе  приведен  анализ 
основных сценариев, в которых разработанная система кэширования данных может привести 
к  повышению  производительности  приложений  по  сравнению  с  использованием 
традиционных  аналогов.  Кроме  того,  работа  содержит  описание  архитектуры  системы, 
построенной  по  схеме  клиент-сервер,  и  протокола  взаимодействия  клиентской  и  серверной 
частей  системы.  Также  описан  и  обоснован  выбор  технических  средств  и  инструментов  и 
описаны внутренние детали реализации. 

!

Результатом  работы  стало  реализованное  приложение,  а  также  проведенный  эксперимент, 
показавший  сравнимую  производительность  приложений,  использующих  традиционные 
решения  и  разработанное  решение  в  ряде  сценариев  применения  распределенной  системы 
кэширования данных для повышения производительности веб-приложений. 

Z2

!

!

  

Оглавление 

Введение 
1. Обзор предметной области и существующих решений 
1.1. Основные понятия 
1.2. Обзор существующих решений 
2. Сценарии использования 
2.1. Приложение с несколькими источниками данных 
2.2. Циклический шаблон доступа к данным 
2.3. Использование удаленного программного интерфейса 
3. Методы реализации 
3.1. Архитектура приложения 
3.2. Описание протокола клиент-серверного взаимодействия 
3.3. Выбор инструментов разработки 
3.3. Хранение кэшированных данных 
3.4. Распределение ключей по нескольких серверам 
4. Эксперимент 
4.1. Методика проведения эксперимента 
4.2. Выбор метрик 
4.3. Результаты эксперимента 
Заключение 
Список использованных источников 

..............................................................................................................................
..............................................
.......................................................................................................
..................................................................................
...............................................................................................
...................................................
...................................................................
...........................................
......................................................................................................
..........................................................................................
.....................................
.............................................................................
............................................................................
....................................................
..................................................................................................................
........................................................................
.............................................................................................................
..........................................................................................
........................................................................................................................
..............................................................................

4 
6 
6 
7 
8 
8 
8 
9 
10 
10 
11 
14 
15 
16 
18 
18 
18 
19 
21 
22

Z3

!

!

  

Введение 

К настоящему времени веб-приложения эволюционировали из статических HTML-страниц в 
сложные  динамические  приложения.  Функциональность  таких  приложений  распределена 
между  клиентской  и  серверной  частями,  при  этом,  как  правило,  на  серверную  часть 
возлагаются  такие  задачи,  как  обработка  и  хранение  данных  или  реализация  логики 
приложения.  Для  обеспечения  стабильной  работы  веб-приложения  и  формирования  у 
пользователя положительного опыта от взаимодействия с приложением от серверной части 
приложения  требуется  минимизация  времени  отклика  приложения  и  максимизация 
количества  обработанных  запросов  в  единицу  времени.  В  то  же  время  продолжающееся 
усложнение  логики  веб-приложений  и  рост  количества  пользователей  ведет  к  повышению 
нагрузки на сервера, обеспечивающие работу веб-приложений. Одним из самых очевидных 
способов повышения скорости работы серверной части веб-приложения является увеличение 
количества вычислительных ресурсов, выделенных для работы приложения, однако данный 
способ  имеет  несколько  недостатков.  Во-первых,  выделение  дополнительных 
вычислительных  ресурсов  не  может  продолжаться  бесконечно  в  силу  их  ограниченности  и 
отсутствия  коммерческой  целесообразности  данного  процесса.  Во-вторых,  приложения  не 
всегда  могут  быть  линейно  отмасштабированы,  что  негативно  влияет  на  эффективность 
использования  вычислительных  ресурсов.  Следовательно,  требуется  способ  повышения 
эффективности использования ресурсов, выделенных для работы веб-приложения. 

!

Одним  из  таких  способов,  хорошо  зарекомендовавшим  себя,  стало  кэширование  данных 
приложения  в  оперативной  памяти  сервера.  В  ситуации,  при  которой  сохранение  и 
извлечение данных из памяти требует меньшего количества вычислительных ресурсов, чем 
вычисление,  подобный  подход  позволяет  снизить  нагрузку  на  центральный  процессор  или 
дисковую  подсистему  сервера  за  счет  увеличения  потребления  памяти.  Системы 
распределенного  кэширования  позволяют  использовать  оперативную  память  множества 
серверов для формирования пула памяти для хранение кэшируемых данных. Типичным, но 
не  единственным, 
  способом  использования  подобных  систем  является  кэширование 
результатов  выполнения  запроса  к  серверу  баз  данных.  Другие  сферы  применения  систем 
кэширования  данных  могут  включать  кэширование  фрагментов  HTML-страниц, 

сгенерированных  с  помощью  шаблонизатора,  или  кэширование  результатов  обращения  к !

Z4

  

удаленному  программному  интерфейсу  (API).  Таким  образом,  область  применения  систем 
кэширования  данных  сервера  приложений  включает  замену  постоянного  обращения  к 
относительно медленному источнику данных на помещение и извлечение данных из кэша в 
оперативной памяти. 

!

В  то  время  как  системы  распределенного  кэширования  данных  получили  широкое 
распространение  в  разработке  веб-приложений,  системам,  позволяющие  разработчику 
приложения  контролировать  порядок  вытеснения  данных,  до  сих  пор  не  было  уделено 
заметного внимания. Аргументом в пользу разработки   и исследования последних является 
недостаточная гибкость существующих систем, большинство из которых в случае нехватки 
памяти для сохранения нового объекта отбрасывает кэшированный объект, который не был 
использован  дольше  всех.  В  то  же  время  система  с  поддержкой  приоритетов  кэшируемых 
данных  позволила  был  разработчику  приложения  управлять  вытеснением  данных  и 
обеспечивать  более  долгую  сохранность  в  кэше  данных,  вычисление  которых  требует 
большее  количество  вычислительных  ресурсов  по  сравнению  с  другими  кэшированными 
данными.  С  точки  зрения  практической  значимости  данная  функциональность  приносит 
пользу  пользователю  системы  кэширования  —  разработчику  приложения.  Разработчик 
приложения,  обладая,  во-первых,  знанием  о  трудоемкости  вычисления  различных  данных, 
используемых  его  приложением,  и,  во-вторых,  инструментом  контроля  вытеснения  данных 
из  системы  кэширования,  получает  возможность  дальнейшего  повышения 
производительности приложения. 

!

Следовательно,  актуальность  разработки  системы  распределенного  кэширования  данных, 
поддерживающая  приоритеты  хранимых  данных,  обусловлена  возможностью  более 
эффективного использования вычислительных ресурсов, предназначенных для эксплуатации 
приложений,  при  использовании  данной  системы.  Задачи  данной  работы  включают,  во-
первых,  проектирование  и  разработку  системы  распределенного  кэширования  данных  с 
использованием алгоритма кэширования, основанного на приоритетах хранимых данных, и, 
во-вторых,  проведение  экспериментального  сравнения  производительности  приложений, 
использующих  в  качестве  системы  кэширования  разработанную  систему  либо  более 
распространенные традиционные решения, описанные в главе 1.2. 

Z5

!

1. Обзор предметной области и существующих решений 

  

!

В  данной  главе  сформулирован  понятийный  аппарат,  используемый  в  работе,  а  также 
представлен обзор предметной области работы и наиболее распространенных существующих 
распределенных систем кэширования данных. 

!
!

1.1. Основные понятия 

Системы распределенного кэширования данных реализуют хранение пар «ключ-значение», в 
которых каждый элемент представляет собой произвольную последовательность байт. Ключ 
является уникальным идентификатором пары и используется для выполнения операций над 
кэшированными данными, такими как сохранение, извлечение или удаление. 

!

Алгоритм  кэширования  (алгоритм  вытеснения)  представляет  собой  метод  выбора 
кэшированного объекта, который должен быть вытеснен из кэша в ситуации нехватки памяти 
для  сохранения  новых  данных.  Поскольку  системы  кэширования  данных  работают  в 
условиях  ограниченности  объема  памяти,  доступной  для  кэширования  данных,  алгоритм 
кэширования   является одним из ключевых элементов системы кэширования данных: метод 
выбора  объекта,  подлежащего  вытеснению  из  кэша,  напрямую  влияет  на  вероятность 
«промаха» кэша, при котором запрашиваемый ранее сохраненный в кэше объект оказывается 
недоступным.  Примерами  алгоритмов  кэширования  являются  алгоритм  LRU  или  алгоритм 
вытеснения случайного блока данных. 

!

Алгоритм кэширования LRU (Least Recently Used) вытесняет из кэша объект, который не был 
затребован  дольше  всех.  Данный  алгоритм  основан  на  предположении,  что  сохраненный  в 
кэше объект, который не был востребован в течение длительного периода времени, с высокой 
вероятностью  не  будет  востребован  в  ближайшее  время  [5].  Алгоритм  кэширования  LRU 
хорошо  известен  и  имеет  ряд  модификаций,  тем  не  менее,  он  обладает  рядом  недостатков, 
которые рассмотрены в главе 1.3. 

!

Система  распределенного  кэширования  данных  с  поддержкой  приоритетов  основана  на 

использовании  алгоритма  вытеснения,  учитывающего  приоритет  каждого  кэшированного !

Z6

  

объекта.  Каждому  сохраняемому  в  кэше  объекту  должен  быть  присвоен  приоритет, 
используемый  при  освобождении  памяти  в  случае  ее  нехватки.  Данный  алгоритм 
гарантирует,  что  кэшированный  объект  с  более  высоким  приоритетом  никогда  не  будет 
вытеснен  с  целью  освобождения  памяти  под  объект  с  более  низким  приоритетом.  Для 
предотвращения  заполнения  всей  доступной  памяти  данными  с  наивысшим  приоритетом 
каждому  объекту  обязательно  должно  быть  присвоен  срок  жизни,  по  истечении  которого 
объект  рассматривается  как  устаревший  и  может  быть  удален  из  кэша  вне  зависимости  от 
приоритета. 

!
!

1.2. Обзор существующих решений 

memcached  [1]  является  одной  из  наиболее  распространенных  систем  распределенного 
кэширования  данных.  Данное  решение  поддерживает  хранение  данных  в  виде  байтовых 
строк, по сути являясь хранилищем пар «ключ-значение». В качестве алгоритма кэширования 
в  memcached  применен  алгоритм  LRU.  Стоит  отметить,  что  существует  несколько 
модификаций и ответвлений memcached, таких, например, как TwemCached [3], однако они 
вносят незначительные изменения в алгоритм LRU. 

!

Redis  [2]  представляет  собой  распределенное  сетевое  хранилище  пар  «ключ-значение»  и 
содержит  реализацию  большего  количества  функциональности  по  сравнению  с  memcache, 
однако  также  может  быть  использован  в  качестве  распределенной  системы  кэширования 
данных [6]. Так, в дополнение к возможности хранения данных в виде последовательности 
байт  Redis  поддерживает  хранение  таких  структур,  как  списки,  ассоциативные  массивы, 
множества и упорядоченные множества. Кроме алгоритма кэширования LRU, Redis включает 
реализацию  алгоритма  вытеснения  случайного  элемента  и  вариации  этих  алгоритмов, 
учитывающие срок жизни кэшированных объектов. 

!
!

Z7

!

!

2. Сценарии использования 

  

В  данной  главе  рассмотрены  сценарии,  в  которых  применение  алгоритма  кэширования, 
основанного  на  приоритетах  объектов,  может  привести  к  повышению  производительности 
работы приложения. 

2.1. Приложение с несколькими источниками данных 

!
!

!
!

Простейшим  сценарием  использования  разработанной  системы  кэширования  данных 
является  приложение,  использующее  несколько  источников  данных  с  различной 
трудоемкостью  получения  данных.  Примером  подобного  приложения  может  быть  веб-
приложение,  использующее  систему  кэширования  для  хранения  сгенерированных 
шаблонизатором фрагментов HTML-страниц и результатов запросов к серверу баз данных. 

!

Данный  сценарий  использования  системы  кэширования  был  рассмотрен  при  проведении 
эксперимента. 

2.2. Циклический шаблон доступа к данным 

Рассмотрим  приложение  со  следующим  сценарием  использования  системы  кэширования 
данных: 
• Количество  используемых  приложением  объектов,  таких  как  записи  в  базе  данных, 

составляет n. Будем считать, что каждый объект обладает порядковым номером. 

• Объем  доступной  системе  распределенного  кэширования  памяти  позволяет  хранить  k 

объектов, причем k < n. 

• Приложение  циклически  запрашивает  объекты  с  первого  до  последнего.  Если  система 
кэширования  данных  хранит  копию  объекта,  используются  кэшированные  данные,  в 
противном случае производится запрос к базе данных и сохранение копии объекта в кэше. 

!

Можно  показать,  что  в  данном  сценарии  использование  алгоритма  вытеснения  LRU, 
реализованного  во  всех  описанных  в  главе  1.2  решениях,  ведет  к  бесполезности  системы 

кэширования: после выполнения первых k запросов и сохранения в кэше первых k объектов !

Z8

  

все следующие запросы вызывают вытеснение из кэша объекта с порядковым номером i - k, 
где  i  —  номер  запрашиваемого  объекта.  Так  как  n  >  k,  любая  сохраненная  в  кэше  копия 
объекта будет вытеснена из кэша прежде, чем будет затребована хотя бы один раз (например, 
первый  кэшированный  объект  будет  вытеснен  при  сохранении  объекта  с  порядковым 
номером k + 1). 

!

!
!

При  использовании  системы  кэширования  данных,  использующей  алгоритм  вытеснения, 
основанный  на  приоритезации  данных,  вытеснения  данных  до  первого  получения  можно 
избежать,  присвоив  повышенный  приоритет  первым  m  объектам.  В  результате  первые  m 
объектов  не  будут  вытеснены  из  кэша  при  выполнении  следующих  запросов  и  будут 
получены иэ кэша при втором цикле запросов. 

!

Данный  сценарий  использования  системы  кэширования  был  рассмотрен  при  проведении 
эксперимента. 

2.3. Использование удаленного программного интерфейса 

Еще  одним  вариантом  применения  описанной  системы  является  кэширование  данных, 
являющихся  результатом  использования  удаленного  программного  интерфейса  (API). 
Владелец  программного  интерфейса  может  устанавливать  правила,  регламентирующие 
доступ  к  интерфейсу.  Например,  количество  запросов  к  интерфейсу  за  единицу  времени 
может  быть  ограничено  с  целью  снижения  нагрузки  на  сервера,  обеспечивающие  работу 
программного интерфейса. 

!

Хранение  результатов  выполнения  запроса  к  программному  интерфейсу  в  системе 
кэширования как объектов с повышенным приоритетом может позволить снизить количество 
вызовов  и  тем  самым  соблюсти  ограничения,  накладываемые  условиями  использования 
программного интерфейса. 

Z9

!

!

  

3. Методы реализации 

В  данной  главе  представлен  обзор  архитектуры  приложения,  обоснование  выбранных 
инструментов и описание деталей реализации. 

!
!

3.1. Архитектура приложения 

Приложение обладает клиент-серверной архитектурой, в которой реализация логики системы 
и хранения кэшированных данных вынесена в серверную часть, а клиент служит оберткой 
над  функциональностью,  предоставляемой  системой,  которая  может  быть  использована 
сторонним пользователем. 

!

Для  взаимодействия  между  клиентской  и  серверной  частями  приложения  был  разработан 
сетевой протокол передачи команд, работающий поверх протокола передачи данных TCP/IP. 
Данный протокол включает описание формата передачи команд, их аргументов и данных, а 
также описание формата ответа на команды. Данный протокол схож с протоколом передачи 
данных  memcached  [9],  однако  имеет  отличия,  обусловленные  необходимостью  передачи 
других  наборов  аргументов.  Так,  формат  команд  сохранения  данных  в  кэше  включает 
дополнительный аргумент — приоритет кэшируемого объекта. 

!

Клиентская часть системы представляет собой библиотеку, доступную для использования в 
приложениях,  которым  требуется  доступ  к  распределенной  системе  кэширования  — 
например,  в  веб-приложениях.  Данная  библиотека  предоставляет  публичные  методы, 
являющиеся  «обертками»  над  командами,  передаваемыми  серверной  части.  На  клиентскую 
часть возлагаются задачи по формированию и передаче команд серверной части приложения, 
а также по обработке полученных ответов. 

!

Серверная  часть  системы  представляет  собой  приложение,  запускаемое  отдельно  от 
клиентской части, и обеспечивает обработку команд, переданных клиентом, и формирование 
ответов  согласно  протоколу  передачи  данных,  а  также  реализацию  логики  системы 
кэширования  данных,  а  именно,  хранение  кэшированных  данных  и  реализацию  алгоритма 

кэширования. Серверная часть системы может быть представлена одним или более сервером, !

Z10

  

при этом использование нескольких серверов позволяет увеличить объем доступной системе 
кэширования  оперативной  памяти.  Следует  отметить,  что  для  случая  использования 
нескольких  серверов  для  кэширования  данных  клиент  должен  включать  реализацию 
алгоритма распределения ключей по серверам. Данный вопрос подробно рассмотрен в главе 

3.5. !

Использование  нескольких  серверов  для  эксплуатации  системы  подразумевает  запуск 
клиентской  и  серверной  частей  на  разных  компьютерах,  тем  не  менее,  клиентская  и 
серверная части могут быть запущены на одном и том же компьютере. 

3.2. Описание протокола клиент-серверного взаимодействия 

!
!

!
!

Взаимодействие  клиента  с  серверной  частью  системы  осуществляется  с  использованием 
соединения  по  протоколу  tcp.  Команды,  обрабатываемые  серверной  частью,  могут  быть 
разделены на три группы: команды сохранения, получения и удаления данных. 

!

Существует шесть команд сохранения данных: 
• Команда «set» сохраняет переданный объект в кэше. 
• Команда  «add»  сохраняет  переданный  объект  только  в  том  случае,  если  кэш  не  содежит 

объект с указанным ключом. 

• Команда  «replace»  сохраняет  переданный  объект  только  в  том  случае,  если  кэш  уже 

содержит объект с указанным ключом. 

• Команда  «append»  добавляет  переданное  значение  после  текущего  значения  объекта  в 

кэше. 

• Команда  «prepend»  добавляет  переданное  значение  кперед  текущим  значением  объекта  в 

кэше. 

• Команда «cas» сохраняет переданный объект только в том случае, если объект в кэше не 
был изменен с момента последнего получения его значения. Для ответа на вопрос, был ли 
изменен объект, используется уникальный идентификатор, задаваемый каждому хранимому 
в кэше объекту. 

Z11

!

Пять первых команд сохранения данных имеют следующий формат: 

  

!

Команда «cas» имеет следующий формат: 

!

После выполнения команды сохранения данных сервер возвращает один из следующих 
ответов: 
• «STORED\r\n» в случае успешного выполнения команды. 
• «NOT_STORED\r\n»  в  случае  наличия  объекта  с  указанным  ключом  при  выполнении 
команды  «add»  либо  его  отсутствия  при  выполнении  команд  «replace»,  «append»  и 
«prepend». 

• «EXISTS\r\n»  в  случае  несовпадения  переданного  идентификатора  объекта  при 
выполнении команды «cas» с текущим идентификатором, что означает изменение объекта с 
момента последнего получения его значения. 

• «NOT_FOUND\r\n»  в  случае  отсутствия  в  кэше  объекта  с  указанным  ключом  при 

выполнения команды «cas». 

Z12

!

command key priority flags exptime length \r\ndataгдеcommand — команда; key — ключ пары «ключ-значение», представленный в виде последовательности байтов; priority — приоритет объекта, 32-разрядное беззнаковое число; flags — набор флагов, 32-разрядное беззнаковое число, которое может использоваться приложением как поле для хранения дополнительной информации об объекте; exptime — срок хранения объекта в кэше, после которого он рассматривается как устаревший и может быть удален вне зависимости от приоритета; length — длина передаваемого значения в байтах; data — значение пары «ключ-значение», представленное в виде последовательности байтов длиной length.cas key flags exptime length casid \r\ndataгдеcasid — уникальный 32-разрядный беззнаковый идентификатор пары «ключ-значение».Команды получения значения «get» и «gets» имеют следующий формат:

  

!

После выполнения команды «get» сервер возвращает ответ следующего формата: 

!

После выполнения команды «get» сервер возвращает ответ следующего формата: 

!

При отсутствии в кэше объекта с указанным ключом после выполнения команды получения 
данных сервер возвращает пустой ответ. 

!

Команда удаления значения «delete» имеет следующий формат: 

!

После выполнения команды «delete» сервер возвращает один из следующих ответов: 
• «DELETED\r\n» в случае успешного выполнения команды. 
• «NOT_FOUND\r\n» в случае отсутствия в кэше объекта с указанным ключом. 

!

В случае получения неизвестной команды сервер возвращает ответ «ERROR\r\n». В случае 
получения команды с ошибочным набором аргументов сервер возвращает ответ формата  

Z13

!

command key \r\nгдеcommand — команда; key — ключ пары «ключ-значение».VALUE key flags length \r\ndata\r\nEND\r\nгдеkey — ключ пары «ключ-значение; flags — набор флагов, 32-разрядное беззнаковое число; data — значение пары «ключ-значение», представленное в виде последовательности байтов длиной length.VALUE key flags length casid \r\ndata\r\nEND\r\nгдеcasid — уникальный 32-разрядный беззнаковый идентификатор пары «ключ-значение».delete key \r\nгдеkey — ключ пары «ключ-значение».!
!

  

!
!

3.3. Выбор инструментов разработки 

Для  реализации  системы  кэширования  был  выбран  язык  программирования  Go  [4], 
разрабатываемый компанией Google. Данный выбор обусловлен несколькими причинами. 

!

Во-первых,  Go  представляет  собой  статически  типизованный  компилируемый  язык 
программирования,  что  позволяет  повысить  производительность  генерируемого 
исполняемого файла. Кроме того, применение статической типизации ведет к обнаружению 
части ошибок на стадии компиляции. 

!

Во-вторых,  Go  активно  разрабатывается  и  используется  для  разработки  собственных 
сервисов  компанией  Google,  вследствие  чего  данный  язык  обладает  проработанной 
стандартной библиотекой, достаточной для разработки прикладных приложений. 

!

В-третьих, Go обладает мощной встроенной поддержкой многозадачности . Так, Go обладает 
возможностью использования легковесных потоков выполнения кода, называемых goroutines. 
Один поток выполнения ОС используется для выполнения множества легковесных потоков, 
что  позволяет  снизить  затраты  на  создание  и  переключение  легковесных  потоков,  что 
критично  при  разработке  системы,  работающей  в  сетевом  окружении  и  использующей 
множество сетевых соединений. 

!

Разработка  и  тестирование  системы  проводилось  на  компьютерах  под  управлением 
операционных систем GNU/Linux и Mac OS X в связи с высокой степенью распространения 
GNU/Linux на серверах, используемых для эксплуатации веб-приложений. 

!

Z14

!

CLIENT_ERROR message\r\nгдеmessage — сообщение об ошибке с указанием аргумента, при чтении которого произошла ошибка.  
3.3. Хранение кэшированных данных 

!

Для  хранения  данных  на  серверной  стороне  системы  кэширования  требуется  структура 
данных, которая обладает следующими характеристиками: 

!

1. Возможность  быстрого  выполнения  операции  добавления  или  извлечения  пар  «ключ-
значение».  Считается,  что  операция  выполняется  достаточно  быстро,  если  ее 
вычислительная  сложность  является  логарифмической  или  константной.  Данное 
требование  обусловлено  необходимостью  наличия  структуры  данных,  используемой  в 
качестве хранилища кэшированных данных. 

2. Возможность упорядоченного хранения элементов и возможность быстрого выполнения 
операций  вставки  или  удаления  элементов.  Считается,  что  операция  добавления  или 
удаления  выполняется  достаточно  быстро,  если  ее  вычислительная  сложность  является 
константной,  для  операции  итерации  по  структуре  принимается  приемлемой  линейная 
вычислительная  сложность.  Даное  требование  продиктовано  необходимостью  хранения 
кэшированных объектов в упорядоченном списке с учетом приоритета. 

!

Для хранения кэшированных данных была выбрана комбинация двух структур данных: хэш-
таблицы и двусвязного списка.  

!

Хэш-таблица  (hash  table)  —  широко  известная  структура  данных,  часто  применяемая  для 
реализации  систем  кэширования.  Хэш-таблица  реализует  такие  операции,  как  добавление, 
извлечение  и  удаление  пары  «ключ-значение».  Элементы,  содержащиеся  в  хэш-таблице, 
объединены  в  «корзины»,  которые  могут  содержать  фиксированное  количество  элементов. 
Для получения индекса корзины, содержащей пару «ключ-значение», по известному ключу 
используется хэш-функция от ключа. 
С  точки  зрения  реализации  системы  кэширования  с  учетом  описанных  выше  требований 
хэш-таблица  интересна  тем,  что  базовые  операции  добавления,  извлечения  и  удаления  пар 
«ключ-значение» в среднем имеют единичную сложность [7]. 

!

Двусвязный  список  [8]  представляет  собой  структуру  данных,  в  которой  каждый  элемент 

хранит  указатели  на  соседние  элементы.  Вычислительная  сложность  операции  добавления !

Z15

элемента  к  двусвязному  списку  является  константной,  а  сложность  операции  итерации  по 
структуре данных — линейной. 

  

!

!
!

Выбранная структура представляет собой комбинацию хэш-таблицы и двусвязного списка, в 
которой элементы, хранящиеся в хэш-таблице, содержат указатели на элементы двусвязного 
списка вместо значений пар «ключ-значение». В свою очередь, элементы двусвязного списка, 
упорядоченные по значению приоритета элементов, содержат значения пар «ключ-значение». 
Подобная  реализация  позволяет  объединить  преимущества  двух  структур  данных, 
поддерживая  возможность  выполнения  операций  над  парами  «ключ-значение»  и  хранения 
элементов в упорядоченном списке. 

3.4. Распределение ключей по нескольких серверам 

Использование  более  одного  сервера  для  кэширования  данных  ставит  задачу  выбора 
алгоритма распределения ключей по серверам. Идеальный алгоритм распределения должен 
обеспечивать  равномерное  распределение  ключей  по  серверам,  а  также  минимизировать 
перераспределение ключей при добавлении или удалении серверов. 

!

Широко распространенной функцией выбора номера сервера по ключу является 

!

Однако  такой  подход  обладает  существенным  недостатком:  после  изменения  количества 
серверов,  например,  при  выходе  из  строя  одного  из  них,  данная  функция  возвращает 
отличные от старых значения для ключей таких, что h(key) % n ≠ h(key) % (n - 1), то есть для 
большинства  ключей,  вследствие  чего  происходит  перераспределение  этих  ключей  по 
серверам.  

!

Z16

!

f(key) = h(key) % nгдеh — хэш-функция, например CRC32; n — количество серверов; % — операция взятия остатка от деления.  

При использовании алгоритма выбора сервера, основанного на консистентном хэшировании, 
в  случае  изменения  количества  серверов  перераспределению  подвергается  значительно 
меньшее  количество  ключей.  Реализация  данного  алгоритма  выбора  сервера  состоит  из 
следующих шагов: 

!

1. Каждому серверу ставится в соответствие набор натуральных чисел на интервале [0; n]. 
Разумным  выбором  n  является  максимальное  значение,  которое  может  быть  записано  в 
беззнаковую 32-разрядную переменную. 

2. При  выборе  сервера  для  хранения  пары  «ключ-значение»  ее  ключ  используется  для 

вычисления хэш-функции, возвращающей значение на том же интервале [0; n]. 

3. Сервер,  число  из  набора  которого  является  ближайшим  к  результату  вычисления  хэш-
функции ключа и превосходит его, выбирается в качестве хранящего данную пару «ключ-
значение».  В  случае,  если  ни  одно  число  из  наборов  не  превосходит  результат 
вычисления  хэш-функции,  в  качестве  сервера  хранения  данной  пары  «ключ-значение» 
выбирается первый в списке.  

!

В  отличие  от  более  примитивного  алгоритма  выбора  сервера,  описанного  ранее,  при 
использовании  консистентного  хэширования  удаление  одного  из  серверов  приводит  к 
перераспределению  только  хранящихся  на  нем  пар  «ключ-значение». 
  При  добавлении 
нового  сервера  перераспределению  подвергается  также  значительно  меньшее  количество 
ключей. 

!
!

Z17

!

  

4. Эксперимент 

4.1. Методика проведения эксперимента 

!
!

!
!

Проведение эксперимента осуществлялось согласно трем тестовым сценариям: 
1. Приложение,  использующее  один  источник  данных,  при  этом  приоритеты  всех 
кэшированных  объектов  равны.  Данный  сценарий  использовался  в  качестве 
контрольного. 

2. Приложение,  использующее  два  источника  данных  с  различной  трудоемкостью  их 
получения,  при  этом  более  ресурсоемкие  данные  имеют  больший  приоритет  при 
хранении в системе кэширования. 

3. Приложение, в котором доступ к данным осуществляется согласно цикличному шаблону, 

описанному в главе 2.2. 

!

Для  запуска  серверной  части  системы  и  тестового  приложения  в  ходе  эксперимента 
использовались виртуализированные машины со следующими характеристиками: 
• Одноядерный процессор с частотой 2399 МГц 
• 2 Гб оперативной памяти 
• 64-разрядная ОС Ubuntu GNU/Linux с ядром версии 3.10.0. 
Два  компьютера  использовались  для  запуска  серверной  части  и  один  —  для  запуска 
тестового приложения. 

!

Для проведения эксперимента использовалась версия memcached 1.4.14, которая запускалась 
командой  memcached  -m  4  -u  memcached  -B  ascii  -l  0.0.0.0,  и  клиент  gomemcache, 
разработанный  создателем  memcached.  Тестовое  приложение  запускалось  пять  раз  для 
каждого сценария, в качестве итогового значение выбиралось худшее полученное значение. 

4.2. Выбор метрик 

Для сравнения эффективности систем кэширования данных была выбрана такая метрика, как 
количество  запросов  в  секунду,  обрабатываемых  тестовым  приложением.  Ее  выбор 

обусловлен тем, что количество запросов в секунду прямым образом влияет на количество !

Z18

пользователей,  которое  может  быть  обслужено  веб-приложением.  Лучшим  считается 
результат с большим значением метрики. 

  

4.3. Результаты эксперимента 

В  соответствии  с  рисунком  1,  в  контрольном  сценарии  разработанное  решение  показывает 
несколько  меньшее  по  сравнению  с  memcached  количество  запросов  в  секунду,  которые 
могут быть обработаны приложением, при этом разница результатов лежит в пределах 6%. 

!
!

!

 
в
 
в
о
с
о
р
п
а
з
 

х
ы
н
н
а
т
о
б
а
р
б
о

у
д
н
у
к
е
с

 

о
в
т
с
е
ч
и
л
о
К

360

270

180

90

0

10

memcached

разработанное решение

50

100

Длина ключей в байтах

!

Рисунок 1. Количество обработанных запросов в секунду в первом тестовом сценарии 

!

Как  видно  из  рисунков  2  и  3,  при  использовании  тестовым  приложением  двух  источников 
данных  с  различной  трудоемкостью,  а  также  при  цикличном  шаблоне  доступа  к  данным 
разработанная  система  и  традиционные  аналоги  показывают  сравнимое  количество 
обработанных за единицу времени запросов. Разработанное решение может демонстрировать 
результат, как превосходящий результат memcached (при этом разница лежит в пределах до 
8%), так и уступающий (с разницей до 10%), что позволяет говорить о наличии у проблемы 
потенциала для дальнейшего исследования. 

Z19

!

memcached

  

разработанное решение

 
в
 
в
о
с
о
р
п
а
з
 

х
ы
н
н
а
т
о
б
а
р
б
о

у
д
н
у
к
е
с

 

о
в
т
с
е
ч
и
л
о
К

570

427,5

285

142,5

0

10

50

100

Длина ключей в байтах

Рисунок 2. Количество обработанных запросов в секунду во втором тестовом сценарии 

 
в
 
в
о
с
о
р
п
а
з
 

х
ы
н
н
а
т
о
б
а
р
б
о

у
д
н
у
к
е
с

 

о
в
т
с
е
ч
и
л
о
К

320

240

160

80

0

memcached

10

разработанное решение

50

100

Длина ключей в байтах

Рисунок 3. Количество обработанных запросов в секунду в третьем тестовом сценарии 

!
!

!

Z20

!

!

  

Заключение 

В  результате  выполнения  работы  была  разработана  система  распределенного  кэширования 
данных  с  использованием  алгоритма  вытеснения  кэша,  основанном  на  приоритезации 
данных. В результате проведения сравнительного эксперимента было установлено, что в ряде 
случаев применение разработанной системы кэширования приводит как к большей, так и е 
меньшей производительности приложения по сравнению с традиционными решениями, что 
может  быть  объяснено  высокой  степенью  оптимизации  в  ходе  многолетней  разработки 
существующих  решений.  Направления  дальнейшего  использования  темы  могут  включать 
дальнейшую  разработку  и  оптимизацию  производительности  системы  либо  исследование 
влияния различных алгоритмов вытеснения кэша на эффективность распределенных систем 
кэширования и производительность веб-приложений. 

Z21

!

Список использованных источников 

  

1. Memcached, просмотрено 12.01.2014 <http://memcached.org>. 
2. Redis, просмотрено 12.01.2014 <http://redis.io>. 
3. TwemCache, просмотрено 12.01.2014 <https://github.com/twitter/twemcache>. 
4. The Go Programming Language, просмотрено 12.01.2014 <http://golang.org>. 
5. Willick,  DL,  Eager,  DL,  Bunt,  RB  1992,  Disk  Cache  Replacement  Policies  for  Network 

Fileservers, University of Saskatchewan. 

6. Sanfilippo, S 2010, Redis as LRU cache, viewed 12.01.2014 <http://oldblog.antirez.com/post/

redis-as-LRU-cache.html>. 

7. Cormen, TH, Leiserson, CE, Rivest, RL, Stein, C 2009, Introduction to Algorithms, 3rd edition, 

The MIT Press, pp. 256-62. 

8. Knuth,  D  1998,  Fundamental  Algorithms,  The  Art  of  Computer  Programming,  3rd  edition, 

Addison-Wesley Professional, pp. 280-285. 

9. Протокол клиент-серверного взаимодействия memcached, просмотрено 18.04.2014 <http://

github.com/memcached/memcached/blob/master/doc/protocol.txt>. 

Z22

!

