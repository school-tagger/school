Правительство Росийской Федерации

Федеральное государственное автономное образовательное учреждение

высшего профессионального образоваия

Национальный Исследовательский Университет - Высшая Школа Экономики

Факультет бизнес информатики

Отделение программной инженерии

Кафедра «Управление Разработкой Программного Обеспечения»

ВЫПУСКНАЯ КВАЛИФИКАЦИОННАЯ РАБОТА

На тему «Программа обнаружения лица на изображении

на основе характеристических признаков»

Студент группы №471ПИ

Тарасиков Александр Сергеевич

Руководитель ВКР:

профессор, доктор наук

Гостев Иван Михайлович

Москва

2013

Аннотация

В данной работе исследуется влияние ориентации лица человека в пространстве на работу

алгоритма обнаружения лиц ViolaJones.

Целью данной работы является разработка способа доработки алгоритма обнаруже-

ния лиц для того, чтобы он допускал больший диапазон углов поворота лица во входном

изображении.

Приводится обзор трех классификаторов обнаружения лиц (а именно, признаки Ха-

ара, используемые в алгоритме Виолы-Джонса, локальные двоичные последовательности

(LBP), собственные вектора). Предложена методика повышения устойчивости алгоритма

к изменению положения лица. Описан метод сравнительного анализа производительности

алгоритмов обнаружения лиц.

Результаты работы влкючают в себя теоретическую часть, представляющую собой ана-

лиз устойчивости алгоритма Viola-Jones к афинным преобразованиям; и практическую -

программную реализацию доработанного алгоритма Виолы-Джонса.

Содержание

1 Введение

1.1 Актуальность . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

1.2 Цель работы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

1.3 Этапы работы . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

1.4 Классификация алгоритмов обнаружения лиц . . . . . . . . . . . . . . . . . .

1.4.1 Каскады признаков-функций . . . . . . . . . . . . . . . . . . . . . . . .

1.5 Собственные вектора и значения . . . . . . . . . . . . . . . . . . . . . . . . .

2 Математические модели

2.1 Сбор статистики . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2.2 Алгоритм Viola-Jones . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2.2.1 Признаки Хаара . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2.2.2 Каскад признаков . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2.2.3 Интегральное изображение . . . . . . . . . . . . . . . . . . . . . . . . .

2.2.4 Обнаружение объекта . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2.2.5 Код алгоритма . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2.3 Модифицированный алгоритм Viola-Jones . . . . . . . . . . . . . . . . . . . .

2.3.1 Сегментация по цвету . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2.3.2 Выбор классификатора . . . . . . . . . . . . . . . . . . . . . . . . . . .

2.3.3 Компенсация вращений . . . . . . . . . . . . . . . . . . . . . . . . . . .

3 Анализ поведения алгоритмов

3.0.4 Поворот вокруг вертикальной оси . . . . . . . . . . . . . . . . . . . . .

3.0.5 Поворот вокруг оси Z . . . . . . . . . . . . . . . . . . . . . . . . . . . .

3.0.6 Сдвиг (Shear) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

3.0.7 Масштабирование . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

3.0.8 Параллельный перенос . . . . . . . . . . . . . . . . . . . . . . . . . . .

4 Заключение

4.1 Результаты . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

4.2 Дальнейшая работа . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

2

2

2

3

4

4

5

6

6

7

7

7

8

8

10

16

16

17

18

18

18

19

19

20

20

20

20

22

1

1 Введение

1.1 Актуальность

В связи с тем, что во всем мире участились случаи терроризма, для обеспечения безопасно-

сти на транспорте и в офисных помещениях, идентификация человека, особенно по лицу,

приобретает важное значение.Решение задачираспознавания лица включает в себя этапы

получения изображения,предварительной обработки, обнаружение лиц и идентификацияс

учетом выявленных особенностей.

В данной работе будет рассмотрена задача обнаружения лиц, в которую не входит

сопоставление лица с известным изображением из базы данных.

Решение задачи обнаружения лиц особенно важно при использовании систем видеона-

блюдения (таких, как CCTV) и в охранных комплексах. В связи с ростом вычислительной

мощности персональных компьютеров и мобильных устройств, обнаружение лиц набирает

популярность как способ организации человеко-машинного взаимодействия. Социальные

сети, такие, как Facebook, обнаруживают лица в загруженных пользователем фотографи-

ях и предлагают ассоциировать их с аккаунтом пользователя в сети. Также, существуют

приложения с использованием «дополненной реальности», такие, как видеоигры, где иг-

рок может взаимодействовать с объектами виртуального мира посредством движений и

жестов, фиксируемых камерой.

На сегодняшний день область применения алгоритмов обнаружения лиц динамически

развивается. Данные алгоритмы находят применение в различных встраиваемых (embedded)

системах, а условия применения данных систем обуславливают существенные различия в

качестве изображений. Требования обработки в режиме реального времени делают невоз-

можным пост-обработку изображений или привлечение оператора для, поэтому важно

разрабатывать устойчивые к дефектам изображений алгоритмы, обладающие вычисли-

тельной эффективностью. Таким образом, задача обнаружения лиц представляет собой

одно из приоритетных направлений развития алгоритмов машинного обучения и компью-

терного зрения.

1.2 Цель работы

Одним из факторов, оказывающим существенное влияние на корректное обнаружение ли-

ца, является ориентация головы в пространстве. Будем называть алгоритм устойчивым

к поворотам при определенном угле поворота в том случае, если он корректно обнару-

2

живает лицо при условии, что голова повернута вокруг вертикальной оси на такой угол.

Порог устойчивости для большинства наиболее часто используемых на данный момент

алгоритмов находится в пределах 10 градусов, чего недостаточно для обнаружеия лиц

без предварительного позиционирования их перед камерой. Это делает такие алгоритмы

неприменимыми для задачи поиска лиц в системах CCTV или в потоке видео с камеры

мобильного телефона.

Целью данной работы является разработка и реализация алгоритма с улучшенной

устойчивостью к поворотам. Необходимым условием для определения направления ис-

следований является анализ существующего алгоритма с целью получения точных чис-

ленных значений диапазонов угла поворота, а также производительности (под произво-

дительностью будем понимать время, необходимое для обнаружения лиц на тестовых

изображениях. поскольку абсолютная производительность зависит от многих факторов,

таких, как конфигурация аппаратного и программного обеспечения, нас будет интере-

совать относительная производительность - то есть, значения, полученные при запуске

различных алгоритмов на одной и той же машине в идентичной среде исполнения).

В данной работе предложен способ увеличения устойчивости алгоритма к поворотам,

который заключается в предварительной обработке входного изображения для того, что-

бы компенсировать поворот голов. Реализованы и проанализированы различные подходы

к оценке таких обратных преобразований. В качестве базового алгоритма обнаружения ис-

пользуется алгоритм Виолы-Джонса [1]. Данный алгоритм выбран по причине того, что

является наиболее часто используемым на сегодняшний день алгоритмом. Кроме того, он

относительно прост в реализации, и может служить базисом для дальнейшей реализации

многоступенчатых методов обнаружения лиц.

1.3 Этапы работы

Для реализации описанных выше задач, были выполнены следующие этапы.

– Поиск публично доступных баз изображений лиц, сделаных при различных углах

поворота. Была выбрана база изображений института INRIA [5]

– Написание приложения для автоматической подготовки изображений к использова-

нию на этапе сбора статистики. Подготовка включает в себя следующие этапы:

– Получение архивов изображеий с соответствующих веб-сайтов

– Приведение данных из различных баз к единому формату каталогов.

3

– Конвертация изображений из различных форматов в требуемый. Данная зада-

ча была решена средствами библиотеки Qt, которая также используется для

вывода изображения на экран.

– Реализация программы для сбора статистики по алгоритмам обнаружения лиц. Про-

грамма в автоматическом режиме исполняе алгоритмы, используя тестовые изобра-

жения в качестве входных данных, и генерировать отчет.

Реализация алгоритма Виолы-Джонса.

Заключительный этап - реализация устойчивых к поворотам головы алгоритмов об-

наружения лиц. Он состоит из реализации двух описанных ранее подходов к увеличению

устойчивости. Первой стадией реализуется алгоритм, который обрабатывает изображение

с камерой для того, чтобы компенсировать изменение положения головы. Таким образом,

большинство алгоритмов обнаружения лиц могут работать в большем диапазоне допусти-

мых углов без внесения изменения в исходный алгоритм. Вторая стадия - разработка и

реализация алгоритма, использующего набор инвариантных к поворотам признаков для

поиска лиц.

1.4 Классификация алгоритмов обнаружения лиц

На данный момент существует множество алгоритмов обнаружения лиц. Некоторые из них

доступны в виде статей с описанием математических моделей, другие - исключительно в

виде программной реализации (напр., библиотека OpenCV, библиотека распознавания лиц

ОС Android и др.)

В данной секции приведена классификация алгоритмов обнаружения лиц, а также

описаны преимущества и недостатки каждой группы алгоритмов.

1.4.1 Каскады признаков-функций

Данная группа состоит из алгоритмов, которые используют в качестве признаков лиц

критические значения некоторой функции от яркости двумерного изображения. Наиболее

известными и часто используемыми являются следующие два алгоритма:

– Алгоритм П.Виолы и М.Джонса [1], использующий признаки Хаара - сумма яркостей

пикселей.

– Алгоритм LBP (Local Binary Patterns) для каждого проверяемого пикселя изобра-

жения в 8-связной области сравнивает яркость пикселя из области с проверяемым

4

пикселем. В случае, если первое значение больше - пикселю области присваивается

значение «1», в противном - «0». 8-битное число, получаемое обходом пикселей по

часовой стрелке, называется Binary Pattern, и используется для сравнения со значе-

ниями в классификаторе.

Преимущества данной группы алгоритмов:

– Универсальность метода. Подход можно использовать для обнаружения произволь-

ных объектов, не только лиц.

Недостатки данной группы алгоритмов:

– Большое время обучения классификатора. В процессе обучения применяется алго-

ритм AdaBoost, который требует перебора всех 𝑁 классификаторов для каждого

изображения в тестовой выборке. число 𝑁 может достигать нескольких тысяч.

– Отсутствие структурной модели лица. Поскольку данные алгоритмы оперируют ис-

ключительно яркостью изображения, возможны ложные срабатывания на объектах,

схожих по уровню яркости с лицами из тестовой выборки.

1.5 Собственные вектора и значения

Алгоритмы данной группы рассматривают входное изображение как матрицу в многомер-

ном пространстве. Изображения из тестовой выборки представляются в матричном виде

(обычно в виде вектора размерности 1𝑥𝑁 ), нормируются путем вычитания из них усред-

ненного изображения. После этого в матрицах, представляющих изображения, ищутся

собственные вектора, описывающие отличие изображения от среднего. Процесс обнару-

жения лица заключается в сравнении расстояния вектора-изображения с критическим

значением, хранимым в базе. Среди всех тестовых изображений, расстояние до которых

меньше критического значения, ищется изображение с минимальным расстоянием. Таким

образом, данная групппа алгоритмов позволяет решить задачу идентификации человека.

Основное различие между алгоритмами данной группы заключается в методике вычис-

ления собственных векторов.

Основные алгоритмы данной группы:

– EigenFaces описан в [2]. Использует яркость пикселей как значение компонент век-

торов. Неустойчив к изменению освещения.

5

– FisherFaces - модификация алгоритма EigenFaces. Использует нормированную яр-

кость пикселей. Более устойчив к изменению освещения.

Преимущества данной группы алгоритмов:

– Меньшее время обучения классификатора по сравнению с каскадами признаков. Раз-

ница может достигать нескольких порядков.

– Возможность идентификации человека по лицу

Недостатки данной группы алгоритмов:

– Низкий процент распознавания на лицах не из тестовой выборки. Поскольку соб-

ственные вектора вычисляются по тестовой выборке, расстояние для изображений

не из выборки будет больше критического значения.

2 Математические модели

В данной главе дается описание используемых в данной работе методов. Описывается про-

цедура анализа поведения алгоритмов обнаружения лиц при афинных преобразованиях

входного изображения. Описывается алгоритм Viola-Jones, особенности его программной

реализации, а также способ доработки для повышения устойчивости к поворотам лица

вокруг вертикальной оси.

2.1 Сбор статистики

Теоретическую часть данной работы составляет сбор статистики и сравнение существую-

щих алгоритмов на тестовом наборе данных.

Тестовый набор данных представляет собой фотографии лиц людей при разных углах

поворота головы. В тестовом наборе есть фотографии нескольких людей. Для одного че-
ловека доступны фотографии с шагом поворота в 5∘ в диапазоне (−90∘; +90∘)

Для каждого алгоритма производится выполнение с использованием каждой фото-

графии в качестве входных данных. Результаты сгруппированы по углам поворота для

каждого алгоритма. Внутри одной группы (то есть, результатов для одного алгоритма

6

при фиксированном угле на изображениях различых людей), считается процент распо-

знанных изображений.

Таким образом, в результате формируется набор записей вида
<Название Алгоритма, № лица, угол поворота, распознано/нет, (cid:77) 𝑇 >
Время работы алгоритма (cid:77) 𝑇 рассчитывается как разница между временем окончания

и временем начала обработки (в миллисекундах) 𝑇𝑒𝑛𝑑 − 𝑇𝑠𝑡𝑎𝑟𝑡.

2.2 Алгоритм Viola-Jones

Алгоритм обнаружения лиц с применением признаков Хаара был впервые описан П.Виолой

и М.Джонсом [1].

2.2.1 Признаки Хаара

Признаки Хаара (Haar-Like features) [1] представляют собой двоичную аппроксимацию

вейвлета Хаара. Каждый признак представляет собой двоичную маску, т.е., черно-белое

изображение, как можно видеть на Рис. 1.

Рис. 1: Признаки Хаара

2.2.2 Каскад признаков

В данной реализации алгоритма признаки представлены набором прямоугольников. Для

каждого прямоугольника задан вес, который вычисляется как сумма значений яркости

пикселей, закрываемых данным прямоугольником. Такое представление обусловено тем,

что возможно быстро вычислять сумму яркостей для прямоугольных областей, но не для

фигур произвольной ориентации.

7

Признаки группируются в этапы (Stages). Для каждого этапа в каскаде хранится по-

роговое значение (threshold). Для каждого признака хранятся два критических значения

left и right. Далее описан алгоритм обнаружения лиц, использующий такую структуру

каскада признаков.

2.2.3 Интегральное изображение

Для того, чтобы за константное время (4 обращения к памяти) получить сумму пиксе-

лей внутри прямоугольного региона изображения, используется оптимизация, называемая

интегральное преобразование изображения. Интегральным оно называется по аналогии с

математической операцией интегрирования, вычисляющей сумму значений функции на

отрезке. В данном случае функцией является яркость пикселя 𝐼𝑥,𝑦

Интегральное изображение в точке с координатами 𝐼𝑥,𝑦 представляет собой сумму зна-

чений яркости в точках, вертикальная и горизонтальная координаты которых меньше x

и y. Пример интегрального изображения приведен на Рис. 2

Для вычисления значения в конкретной точке используется следующая формула:

𝐼𝑥,𝑦 = 𝐼𝑥,𝑦−1 + 𝐼𝑥−1,𝑦 − 𝐼𝑥−1,𝑦−1

Рис. 2: Интегральное представление изображения

Сумма значений яркости пикселей внутри прямоугольника ABCD можно вычислить

по формуле

𝐶 − 𝐵 − 𝐷 + 𝐴

8

2.2.4 Обнаружение объекта

Алгоритм использует базу признаков (features) для обнаружения объектов. Базу возмож-

но сгенерировать из всех возможных комбинаций Haar-Like features путем отсеивания

«слабых» классификаторов, которые дают ошибку второго рода, то есть ошибочно не

находят объект на изображении. Один из способов получения базы с применением алго-

ритма AdaBoost описан в [1] и [?]. В данной работе этап генерации базы не применяется, и

реализуется только этап обнаружения объекта с применением готового набора признаков.

В качесте базы используется каскад haarcascade_frontalface_alt.xml из проектаOpenCV [6]

Каскад признаков состоит из нескольких стадий (stages). Каждая стадия включает в

себя набор признаков (features). В представлении, использующемся в каскаде из проекта

OpenCV, признаки разбиваются на одноцветные прямоугольники (rects), каждому из ко-

торых назначен положительный или отрицательный вес.

Во время выполнения алгоритма, "окно"размером 𝑊ℎ * 𝑊𝑤 пикселей движется вдоль
изображения по горизонтали и вертикали. Начальный размер окна выбирается равным

размеру окна, записанному в каскаде-классификаторе. На каждом шаге размер окна уве-

личивается. Возможны два способа увеличения размера окна. Первый заключается в вы-

числении масштабирующего коэффициента и корректировке координат прямоугольников

внутри признаков. Второй заключается в масштабировании самого исходного изображе-

ния. В данной работе использован первый способ, поскольку он вычислительно проще при

программной реализации масштабирования изображений. При этом, размер размер окна

на каждой итерации умножается на масштабирующий коэффициент ITER_SCALE. Окно

сдвигается по горизонтали на w_step_x пикселей, и на w_step_y пикселей по горизонтали.

Данные переменные вычисляются следующим образом:

𝑤_𝑠𝑡𝑒𝑝_𝑦 = 𝑚𝑎𝑥(1, 𝑚𝑖𝑛(4, 𝑊ℎ/10))

𝑤_𝑠𝑡𝑒𝑝_𝑥 = 𝑚𝑎𝑥(1, 𝑚𝑖𝑛(4, 𝑊𝑤/10))

Для окна высчитывается нормировочный коэффициент

𝑤𝑖𝑛_𝑛𝑜𝑟𝑚 =

1.0

𝑊ℎ * 𝑊𝑤

. Внутри окна считается сумма яркостей пикселей w_sum и сумма квадратов яркостей

w_ssq пикселей с использованием интегрального представления изображений. Считается

9

математическое ожидание яркости пикселя mean, дисперсия var и стандартное отклонение

𝑚𝑒𝑎𝑛 = 𝑤_𝑠𝑢𝑚 * 𝑤𝑖𝑛_𝑛𝑜𝑟𝑚

⎧⎨⎩ 𝑠𝑞𝑟𝑡(𝑣𝑎𝑟)

𝑠𝑡𝑑𝑑𝑒𝑣 =

𝑣𝑎𝑟 = (𝑤_𝑠𝑠𝑞 * 𝑤𝑖𝑛_𝑛𝑜𝑟𝑚) − 𝑚𝑒𝑎𝑛2

если 𝑣𝑎𝑟 >= 0

1.0 иначе

Для оптимизации введена пороговая константа STDDEV_MIN, и если стандартное откло-

нение stddev меньше этого значения, данное "окно"пропускается. Это сделано для того,

чтобы исключить области с низкой яркостью, где отсутствует гарантинахожденияя объ-

екта.

Для каждой стадии из каскада считается накопленный коэффициент sum_stage, и

сравнивается с критическим значением, записанным в каскаде. В том случае, если зна-

чение меньше критического, стадия считается невыполненной, и для текущего окна об-

работка прерывается. В случае, если все стадии отработали корректно, считается, что в

текущем окне обнаружен объект (лицо). При этом, введена проверка, что стандартное

отклонение больше STDDEV_FACE, что позволяет регулировать порог срабатывания.

Для каждого признака из каскада считается отнормированное значение 𝑠𝑢𝑚_𝑓 𝑒𝑎𝑡𝑢𝑟𝑒*
𝑤𝑖𝑛_𝑛𝑜𝑟𝑚 и сравнивается с отнормированным критическим значением, записанным в
каскаде 𝑓 𝑒𝑎𝑡𝑢𝑟𝑒− > 𝑡ℎ𝑟𝑒𝑠ℎ𝑜𝑙𝑑 * 𝑠𝑡𝑑𝑑𝑒𝑣. В случае, если значение меньше критического, к
значению стадии прибавляется значение из левого поддерева признака, в противном- из

правого. Значение sum_feature считается как сумма яркостей пикселей, которые попада-

ют в прямоугольную область внутри признака, умноженная на вес области. Координаты

области умножаются на win_scale.

В таблице приведены значения констант, используемых в данной реализации алгорит-

ма.

ITER_SCALE

1.2

STDDEV_MIN 10.0

STDDEV_FACE 25.0

2.2.5 Код алгоритма

1 void V J F a c e D e t e c t o r :: i n t e g r a l _ i m a g e ( const uchar * ptr ,

2

3

4

V J F a c e D e t e c t o r :: i nt e g r a l _ t * out ,

V J F a c e D e t e c t o r :: i nt e g r a l _ t * sum_sq ,

unsigned _w ,

10

5

6 {

unsigned _h )

7 # define IN (i , j ) ptr [(4 * ( i ) * _w ) + (( j ) * 4) ]

8 # define OUT (i , j ) out [(( i ) * _w ) + ( j ) ]

9 # define SQR (i , j ) sum_sq [(( i ) * _w ) + ( j ) ]

for ( unsigned i = 0; i < _h ; i ++) {

for ( unsigned j = 0; j < _w ; j ++) {

OUT (i , j ) = IN (i , j ) ;

SQR (i , j ) = IN (i , j ) * IN (i , j ) ;

if ( i > 0 && j > 0) {

OUT (i , j ) -= OUT (( i - 1) , ( j - 1) ) ;

SQR (i , j ) -= SQR (( i - 1) , ( j - 1) ) ;

}

if ( i > 0) {

OUT (i , j ) += OUT (( i - 1) , j ) ;

SQR (i , j ) += SQR (( i - 1) , j ) ;

}

if ( j > 0) {

OUT (i , j ) += OUT (i , ( j - 1) ) ;

SQR (i , j ) += SQR (i , ( j - 1) ) ;

}

}

}

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30 }

31

32 inline V J F a c e D e t e c t o r :: in t e g r a l _ t V J F a c e D e t e c t o r :: sum (

33

34

35

36

37

38

39

40 {

V J F a c e D e t e c t o r :: i nt e g r a l _ t * arr ,

unsigned x ,

unsigned y ,

unsigned w ,

unsigned h ,

unsigned _w ,

unsigned _h )

11

if ( x + w >= _w || y + h >= _h ) {

return 0;

}

size_t i1 = _w * y + x ;

size_t i2 = _w * ( y + h ) + x ;

i n t e g r a l_ t s1 = arr [ i1 ];

i n t e g r a l_ t s2 = arr [ i2 ];

i n t e g r a l_ t s3 = arr [ i1 + w ];

i n t e g r a l_ t s4 = arr [ i2 + w ];

return s4 + s1 - s2 - s3 ;

41

42

43

44

45

46

47

48

49

50

51

52

53 }

12

1 bool V J F a c e D e t e c t o r :: detect ( const uchar * ptr , unsigned w , unsigned h ,

2

F a c e D e t e c t o r :: R e c t V e ct o r & out )

3 {

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

unsigned _w = w ;

unsigned _h = h ;

// buffer for the integral image

i n t e g r a l_ t * integral = new i n t e gr a l _ t [ _w * _h ];

i n t e g r a l_ t * int_sqr = new i n t e g r a l _ t [ _w * _h ];

std :: fill ( integral , integral + _w * _h , 0) ;

std :: fill ( int_sqr , int_sqr + _w * _h , 0) ;

unsigned win_h = _cascade - > height ;

unsigned win_w = _cascade - > width ;

double win_scale = 1.0;

// build integral image

i n t e g r a l _ i m a g e ( ptr , integral , int_sqr , _w , _h ) ;

// scale image for each

while ( qMin ( win_h , win_w ) < qMin ( _w , _h ) ) {

double win_norm = 1.0 / ( win_w * win_h ) ;

unsigned w_step_y = qMax (1 u , qMin (4 u , win_h / 10 u ) ) ;

unsigned w_step_x = qMax (1 u , qMin (4 u , win_w / 10 u ) ) ;

// slide the c l a s s i f i e r window across the image

for ( unsigned wy = 0; wy < _h - win_h ; wy += w_step_y ) {

for ( unsigned wx = 0; wx < _w - win_w ; wx += w_step_x ) {

i n t e g r al _ t w_sum = sum ( integral , wx , wy , win_w , win_h ,

_w , _h ) ;

i n t e g r al _ t w_ssq = sum ( int_sqr , wx , wy , win_w , win_h ,

_w , _h ) ;

13

34

35

36

37

38

39

40

41

42

43

44

45

46

47

48

49

50

51

52

53

54

55

56

57

58

59

60

61

62

63

64

65

66

double stddev = 1.0;

double mean = w_sum * win_norm ;

double var = ( w_ssq * win_norm ) - ( mean * mean ) ;

if ( var >= 0) {

stddev = sqrt ( var ) ;

}

if ( stddev < ST D D E V _ M I N ) {

continue ;

}

bool failed = false ;

foreach ( Stage *s , _cascade - > stages ) {

double sum_stage = 0.0;

foreach ( Feature *f , s - > features ) {

double s u m _ f e a t u r e = 0.0;

foreach ( Rect *r , f - > rects ) {

unsigned rx = r - > x * win_scale ;

unsigned ry = r - > y * win_scale ;

unsigned rw = r - > w * win_scale ;

unsigned rh = r - > h * win_scale ;

s u m _ f e a t u r e += sum ( integral , wx + rx , wy +

ry ,

} // Rects

rw , rh , _w , _h ) *

r - > weight ;

if ( s u m _ f e a t u r e * win_norm < f - > threshold *

stddev ) {

sum_stage += f - > left ;

}

else {

sum_stage += f - > right ;

}

} // Features

if ( sum_stage < s - > threshold ) {

14

67

68

69

70

71

72

73

74

75

76

77

78

79

80

81

82

83

84

85

86

87

88

89

90

91

92

93

94

95 }

failed = true ;

break ;

}

} // Stages

if (! failed ) {

if ( stddev > S T D D E V _ F A C E ) {

F a c e D e t e c t o r :: Rect r ;

r . x = wx ;

r . y = wy ;

r . w = win_w ;

r . h = win_h ;

out . append ( r ) ;

qDebug () << " VJ : ␣ Object ␣ at ␣ " << wx << " ," <<

wy ;

}

}

}

} // scale window

win_h *= I T E R _ S C A L E ;

win_w *= I T E R _ S C A L E ;

win_scale *= I T ER _ S C A L E ;

}

delete integral ;

delete int_sqr ;

return out . count () > 0;

15

2.3 Модифицированный алгоритм Viola-Jones

В данной главе предлагается доработка алгоритма Viola-Jones для повышения устойчи-

вости к поворотам лица вокруг вертикальной оси. Модифицированный алгоритм состоит

из трех этапов.

2.3.1 Сегментация по цвету

Для выделения участков изображения, в которых содержится кожа, используется следу-
ющие условия, где R, G, B - цвета в диапазоне [0; 255]: {𝑡𝑜
𝐺 <= 8 * 𝐵
𝐺 >= 0.9 * 𝐵
𝑅 <= 2.8 * 𝐺(1)Данные коэффициенты были выбраны на основе анализа результатов,
представленных в работе, посвященной обнаружению участков кожи в условиях различ-

𝑅 >= 1.2 * 𝐺

ной освещенности [3]. Пример работы алгоритма сегментации можно видеть на Рис. 3

После выделения областей, смежные пиксели, классифицированные как «кожа», объ-

единяются в кластеры. Каждый кластер ограничивается прямоугольной областью. Внут-

ри каждой прямоугольной области производится поиск лица (вторая и третья стадии ал-

горитма). После этого фильтруются области, занимающие менее 5 процентов высоты/ши-

рины изображения (путем сравнения площади изображения и площади области). Рис. 4

показывает окончательный результат.

Рис. 3: Выделение регионов, принадлежащих коже

Изображение было взято из набора, предложенного для тестирования алгоритмов рас-

познавания лиц на сайте University of Dundee [4]. Как можно видеть, алгоритм успешно

выделяет области, в которых находятся лица. В то же время, есть и ложные срабатывания

16

Рис. 4: Выделение областей, потенциально содержащих лица

на объектах, не являющихся лицами (руки, рекламный плакат), однако для нас важно то,

чтобы не были пропущены области, где лицо есть. Кроме того, данная формула пред-

назначена для обнаружения людей европеоидной расы на изображениях, сделанных при

дневном свете. Поскольку каскады признаков, используемых для тестирования, были обу-

чены по аналогичной выборке, данный этап не должен привести к ложной классификации

области, содержащей лицо.

2.3.2 Выбор классификатора

В каждой из областей, потенциально содержащих лицо, которые были обнаружены на

предыдущем шаге алгоритма, производится поиск частей лица с использованием каскадов

признаков, обученных на поиск данной части.

– Выполняется поиск глаз. Используются каскады для обнаружения левого и право-

го глаза. Если обнаружен один глаз, то выполняется поиск лица с использованием

каскада для профиля лица (вида сбоку).

– При обнаружении двух глаз выполняется поиск рта на изображении. В случае, если

обнаружен рот, вычисляются точки-центры прямоугольных областей, ограничива-

ющих глаза и рот. Вычисляются расстояния 𝐷𝑟𝑖𝑔ℎ𝑡 и 𝐷𝑙𝑒𝑓 𝑡 от центра правого и ле-

вого глаза до центра рта. Вычисляется реальное расстояние между глазами 𝐷𝑒𝑦𝑒𝑠,

и «ожидаемое» расстояние 𝐷𝑒𝑥𝑝𝑒𝑐𝑡𝑒𝑑. «Ожидаемое» расстояние - это такое расстоя-

ние, которое должно быть между центрами глаз на изображении лица, смотрящего

прямо в камеру. Предполагается, что изображение было повернуто только вокруг

17

вертикальной оси, и горизонтальные расстояния между частями лица не был нару-
шены. В таком случае, 𝐷𝑒𝑥𝑝𝑒𝑐𝑡𝑒𝑑 = 𝐷𝑙𝑒𝑓 𝑡 * 𝐷𝑟𝑖𝑔ℎ𝑡/1.254/2. Данный коэффициент был
подобран как среднее значение анализом 10 изображений из базы. Производится
горизонтальное масштабирование изображения с коэффициентом 𝐷𝑒𝑥𝑝𝑒𝑐𝑡𝑒𝑑
𝐷𝑒𝑦𝑒𝑠

.

– Если не было обнаружено лицо при помощи каскада «профиль», или было получено

отмасштабированное изображение после классификаторов «глаза», происходит по-

строение виртуального изображения лица, содержащего аппроксимацию исходного

изображения до поворота (третья стадия алгоритма).

2.3.3 Компенсация вращений

На данном этапе строится «виртуальное изображение», представляющее собой аппрокси-

мацию изображения лица до поворота вокруг горизонтальной оси. Для этого берется изоб-

ражение лица, представляющее собой двухмерную проекцию лица на плоскость камеры.

Рассматриваем данное изображение как плоскость в трехмерном пространстве, назначая

координату 𝑍 = 0. Будем вращать данную плоскость вокруг вертикальной оси с шагом в
5 градусов в диапазоне от −30 до +30 градусов включительно.

Предполагается, что комбинация вращения и масштабирования на предыдущем этапе

сделают изображение более похожим на такое, которое мы могли бы получить в случае,

когда лицо направлено в камеру, и алгоритм обнаружения лиц должен допускать больший

диапазон углов поворота лица.

3 Анализ поведения алгоритмов

В данной главе описывается влияние афинных преобразований на обнаружение лиц лго-

ритмом Viola-Jones и модифицированным алгоритмом. В качестве тестовой базы исполь-

зуется база ICPR института INRIA [5].

3.0.4 Поворот вокруг вертикальной оси

Использовались изображения из базы ICPR. Из нее выбраны изображения 15 людей. По-
ворот головы вокруг вертикальной оси в диапазоне [−90; +90] градусов с шагом в 15 гра-
дусов.

Результаты Viola Jones:

18

Угол, градусы Число распознанных

-90

-75

-60

-45

-30

-15

0

+15

+30

+45

+60

+75

+90

1

2

8

12

14

14

14

15

15

14

10

3

2

Можно видеть, что при 60 градусах распознается более половины изображений, при 75 -

меньше 20%. Таким образом, алгоритм стабильно работает при угле, меньшем 60%. При

использовании модифицированного алгоритма, распозналось дополнительно одно изоб-

ражение при угле 75% и два - при угле в 60%, при этом при меньшем угле поворота

изменений нет. Это улучшение незначительно, но говорит о том, что начальное предполо-

жение о возможности аппроксимации верно. Дальнейшее направление - разработка более

точного метода оценки поворота изображения.

3.0.5 Поворот вокруг оси Z

Тест состоит в повороте исходного изображения на 360 градусов инкрементами по 15 гра-
дусов. Результат: при поворотах вплоть до +/ − 30 градусов лицо обнаруживается. Пове-
дение оригинального и измененного алгоритмов аналогично, так как модифицированный

алгоритм компенсирует только повороты вокруг вертикальной оси.

3.0.6 Сдвиг (Shear)

Преобразование Shear вдоль осей X и Y задается следующими матрицами:

⎞⎠ =

⎛⎝𝑥′

𝑦′

⎛⎝1 𝜆

⎞⎠⎛⎝𝑥

⎞⎠

0 1

𝑦

19

⎞⎠ =

⎛⎝𝑥′

𝑦′

⎛⎝1 0

𝜆 1

⎞⎠⎛⎝𝑥

⎞⎠

𝑦

Тест Shear. Исходное изображение подвергнуто преобразованию Shear с 𝜆 от 0.0 до 1.0

с шагом 0.1. Результат - более 90% изображений перестают распознаваться при 𝜆 >= 0.8.

3.0.7 Масштабирование

Тест масштабирования. Исходное изображение последовательно увеличивается в 1.2 раза

до тех пор, пока каждое из его измерений меньше 768 пикселей. На каждом масштабиро-

ванном изображении запускается алгоритм.

Результаты тестирования для алгоритмов Viola-Jones и модифицированного алгоритма

не отличаются от исходных. Объяснение - алгоритм Viola-Jones инвариантен к изменению

размеров входного изображения, так как во время выполнения алгоритма окно классифи-

катора последовательно масштабируется. Данный тест является частью методики анализа

поведения алгоритма обнаружения лиц при афинных преобразованиях, и, несмотря на то,

что алгоритм Viola-Jones показывает одинаковые результаты, запуск теста для этого ал-

горитма было необходимо для проверки корректности реализации алгоритма генерации

тестов.

3.0.8 Параллельный перенос

Тест переноса. Исходное изображение последовательно увеличивается в 1.2 раза до тех

пор, пока его длина и высота меньше 768 пикселей. На каждом масштабированном изоб-

ражении запускается алгоритм.

Результаты тестирования для алгоритмов Viola-Jones и модифицированного алгоритма

не отличаются от исходных. Алгоритм Viola-Jones инвариантен к сдвигу, так как во время

выполнения алгоритма окно классификатора свдигаетс в горизонтальном и вертикальном

направлениях.

4 Заключение

4.1 Результаты

В ходе выполнения данной работы были достигнуты все ожидаемые результаты:

– Описана методика тестирования алгоритмов обнаружения лица на предмет устой-

чивости к афинным преобразованиям

20

– Разработана программная реализация данной методики для автоматизированного

тестирования

– Проведен анализ поведения алгоритма обнаружения лиц ViolaJones.

– Проведен анализ поведения доработанного алгоритма обнаружения лиц.

Несмотря на то, что доработанный алгоритм лишь незначительно увеличил процент

распознавания изображений на границах интервала допустимых углов поворота для алго-

ритма Viola-Jones, введение сегментации изображения по признаку цвета кожи уменьшило

количество ложных срабатываний алгоритма и сократило время выполнения алгоритма

за счет того, что обрабатывается лишь часть изображения. Например, на приведенной

ниже иллюстрации (Рис. 5), сравниваются результаты работы алгоритмов Viola-Jones и

модифицированного алгоритма. Слева - результат работы алгоритма без предваритель-

ной обработки. Можно заметить большой квадрат, захватывающий несколько лиц. Это -

ошибка распознавания - ложно срабатывание, чего не наблюдается на правой картинке,

где области с лицами были размечены сегментацией по цвету до начала обнаружения. На

основании данных результатов можно сделать вывод, что алгоритм Viola-Jones эффек-

тивно комбинировать с предварительной обработкой, и использование дополнительных

классификаторов может повысить качество обнаружения лиц.

Рис. 5: Результат использования сегментации по цвету

21

4.2 Дальнейшая работа

По результатам анализа поведения алгоритмов, а также из наблюдений, сделанных в про-

цессе работы, были определены следующие направления дальнейших исследований

– Анализ существующих исследований и разработка метода обнаружения кожи, учи-

тывающий такие особенности, как раса, окружающее освещение.

– Построение линейной регрессионной модели яркости лица в зависимости от угла

поворота

– Исследование поведения алгоритма EigenFaces

22

Список литературы

[1] Jones, M., Viola, P. (2001) Robust Real-Time Face Detection. URL: International Journal

of Computer Vision, 57(2), 137-154, 2004. Available from: http://www.vision.caltech.

edu/html-files/EE148-2005-Spring/pprs/viola04ijcv.pdf (ссылка проверена 28

мая 2013)

[2] Turk, M., Pentland, A. (1991) Face Recognition Using Eigenfaces URL: http://www.cs.

ucsb.edu/~mturk/Papers/mturk-CVPR91.pdf (ссылка проверена 28 мая 2013)

[3] A novel approach for human face detection from color

images under complex

background http://visgraph.cs.ust.hk/biometrics/Papers/Face/pr2001-10-1.pdf

(ссылка проверена 28 мая 2013)

[4] Face Detection using AdaBoost and the OpenCV library URL: http://www.computing.

dundee.ac.uk/courses/ac52021/project2.html (28 мая 2013)

[5] ICPR Face Database URL: http://www-prima.inrialpes.fr/Pointing04/data-face.

html (28 мая 2012)

[6] OpenCV Open Source Computer Vision URL: http://opencv.org (дата доступа 28 мая

2013)

23

