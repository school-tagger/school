Министерство экономического

развития и торговли РФ

Государственный университет

Высшая школа экономики

Факультет прикладной математики и кибернетики

Кафедра прикладной математики

ВЫПУСКНАЯ КВАЛИФИКАЦИОННАЯ РАБОТА

На тему модернизация конструктора математических задач и сер-
верного модуля компьютерной обучающей системы.

Студент группы № M-94
Крылов Дмитрий Вячеславович
(Ф.И.О.)

Научный руководитель
Данилов Владимир Григорьевич
(должность, звание, Ф.И.О.)

Консультант
Петров Пётр Петрович
(должность, звание, Ф.И.О.)

Москва 2013

Содержание

1 Введение

2 Описание обучающей системы

3 Пример работы с системой через веб-интерфейс

4 Грамматики

4.1 Структура грамматики . . . . . . . . . . . . . . . . . .
4.2 Принцип генерация задач . . . . . . . . . . . . . . . . .

2

2

6

8
8
9

5 Конструктор грамматик

11
5.1 Описание
. . . . . . . . . . . . . . . . . . . . . . . . . . 11
5.2 Реализованные возможности конструктора . . . . . . . 11
5.2.1 Функция проверки грамматики . . . . . . . . . . 11
5.2.2 Функция визуализации математических выра-

жений . . . . . . . . . . . . . . . . . . . . . . . . 12

5.2.3 Функция конвертирования формул в формате

LATEX в формат Mathematica . . . . . . . . . . . 14
5.3 Интерфейс конструктора . . . . . . . . . . . . . . . . . 19

6 Интерфейс пользователя для операционной системы

Android

7 Приложение

30

36

1

1 Введение

Данная дипломная работа посвящена модернизации компьютер-
ной обучающей системы. Эта система способна генерировать различ-
ные математические задачи основываясь на формальных описаниях
классов задач.

Система даёт пользователям возможность обучаться решению за-
дач на конкретных практических примерах и дистанционно. Для это-
го система генерирует различные задачи для пользователей и в том
случае если они решают их неправильно показывает им правильное
решение этих задач.

Пользователи данной системы обучаются различным математи-
ческим приёмам путём решения задач и исследуя их правильные
решения.

2 Описание обучающей системы

На верхнем уровне обучающая система состоит из двух основ-
ных подсистем: ядро системы и внешний математический модуль.
Для взаимодействия с системой применяется веб-интерфейс. Также
в рамках данной дипломной работы был разработан интерфейс си-
стемы на базе операционной системы Android, который поддержива-
ет все функции системы для обучения пользователей, реализованные
в данный момент времени. Android интерфейс использует javascript
библиотеку MathJax для отображения формул на экране.

Для формальных описаний задач в системе используется специ-
альный язык, который называется SimpleTask. Для описания ма-
тематических выражений на этом языке применяется специальный
формат, который понятен используемому математическому модулю.
Каждое описание класса задач представляет собой файл написанный
на языке SimpleTask и называется грамматикой.

Существует два способа добавления нового класса задач в систе-
му. Первый способ заключается в ручном написании грамматики и
её установки на сервер. Для этого пользователь должен знать язык

2

SimpleTask и язык используемого математического модуля. Установ-
ка грамматики проводиться с помощью отдельного сервлета, кото-
рый отделён от ядра, но установлен на том же сервере. Второй способ
заключается в использовании конструктора грамматик. Конструк-
тор грамматик автоматизирует большую часть процесса написания
и установки грамматик и позволяет пользователю сосредоточиться
на их составлении.

В рамках данной дипломной работы в конструкторе были реа-
лизованы дополнительные функции, упрощающие процесс создания
грамматик и делающие его более удобным. В работе над конструк-
тором использовались такие библиотеки как jlatexmath для визуа-
лизации формул, ini4j для работы с файлами свойств, jRegistryKey
для работы с реестром операционной системы windows, SnuggleTeX
для преобразования описаний математических формул в формате
MathML в формат LATEX и обратно, и другие.

В обязанности ядра системы входит принятие и обработка html
запросов на генерацию математических задач. Получив подобный за-
прос, ядро ищет на сервере соответствующий требуемому типу задач
файл грамматики. Затем проводит синтаксический анализ найденно-
го файла, преобразуя грамматику в древовидную структуру данных,
основываясь на этой структуре генерирует задачу и отправляет её в
формате XML как html отклик.

В процессе синтаксического разбора грамматики ядро системы
активно использует математический модуль для различных вычис-
лений. Большинство файлов грамматик требуют таких вычислений
для возможности успешной генерации задач.

В настоящее время математическим модулем является система

компьютерной алгебры Mathematica версии 5.2.

Ядро обучающей системы полностью написано на языке Java
и реализовано как набор сервлетов работающих под руководством
TomCat. Каждой функции ядра соответствует свой сервлет, реали-
зующий данную функцию, используя общие для системы библиоте-
ки.

Для связи ядра системы и математического модуля Mathematica
применяется библиотека JLink. Эта библиотека была специально со-

3

здана разработчиками Mathematica для связи этой системы с внеш-
ними программами написанными на языке Java. С помощью этой
библиотеки ядро системы образует вместе с системой Mathematica
клиент-серверную архитектуру. Ядро отправляет математическому
модулю запросы на вычисления математических выражений в фор-
ме специальных пакетов и получает от Mathematica результат в
виде отклика. Для коммуникации между ядром системы и систе-
мой Mathematica используется специальный протокол, установлен-
ный библиотекой JLink.

Для приёма запросов от пользователя и передачи ему инфор-
мации используется веб-интерфейс. Пользователи используют веб-
интерфейс для того, чтобы запросить у системы задачу для реше-
ния и для того, чтобы проверить ответ. Для решения этих задач
веб-интерфейс обращается к соответствующим функциям ядра.

Для пользователя типичный сеанс работы с обучающей системой

выглядит следующим образом.

Рис. 1: Схема сеанса работы с системой

Пользователь выбирает интересующий его тип задачи из списка,

4

система находит соответствующую этому типу задач грамматику и
генерирует некоторую конкретную задачу. Затем система отобража-
ет условие и предлагает пользователю ввести ответ. После того, как
пользователь введёт ответ система сравнивает его с правильным. В
том случае если была допущена ошибка система отображает пра-
вильное решение. Далее пользователь может попробовать решить
аналогичную задачу.

База данных

с
п
и
с
к
а

з
а
д
а
ч

О
б
н
о
в
л
е
н
и
е

Веб-интерфейс

Установщик грамматик

Загрузка

грамматики

е
и
н
е
н
а
р
х
о
С

и
к
и
т
а
м
м
а
р
г

Хранилище грамматик

П

о

и

с

к

г

р

а

м

ф

а

й

м

а

т

и

л

а

к

и

Запрос на генераци ю
П ос ы лка задачи

г
р
а
м
м
а
т
и
к
и

З
а
г
р
у
з
к
а

Ядро системы

Генерац и я
задач и

П

грам

роверка
матики

Математический модуль

Конструктор грамматик

Рис. 2: Связи между модулями системы

5

3 Пример работы с системой через веб-

интерфейс

Рассмотрим работу системы через веб-интерфейс на примере.
Пусть пользователь после входа в систему послал запрос на генера-
цию задачи вычисления производной от произведения двух функций
и числового множителя.

В результате система сгенерировала следующую задачу:

Рис. 3: Пример сгенерированной задачи

В этом примере пользователю предлагается вычислить производ-

ную от 4 · arctan(𝑥) · log(𝑥).

Страница с формулировкой задачи содержит форму, включаю-
щую в себя поле для ввода ответа и кнопку для отправки. Так
как система использует программу Mathematica для работы с мате-
матическими выражениями ответ должен быть записан в формате
Mathematica.

В том случае, если пользователь вводит неправильный ответ си-

стема отправляет пользователя на веб страницу с решением.

6

Рис. 4: Решение задачи

При повторной генерации задачи этого типа пользователю нужно

будет решать уже другую задачу:

Рис. 5: Повторная генерация задачи

7

4 Грамматики

4.1 Структура грамматики

Описание задачи на языке SimpleTask представляет собой после-
довательность правил вида ⟨имя правила⟩ ⟨{определение}⟩. Опреде-
ление может содержать в себе текст и ссылки на другие правила.
Для того, чтобы поместить в определение одного правила ссылку
на другое требуется поместить в определение первого правила имя
второго правила предваряя его символом #. Например:

rule1 { x+123 }
rule2 { y + #rule1 }

В этом примере при вычислении правила rule2 будет вычисле-
но правило rule1 и его результат подставлен вместо ссылки на пер-
вое правило. То есть результатом вычисления правила rule2 будет
y+x+123.

Правила могут быть вычислимыми (формулами) и невычисли-
мыми (текстом). Формулы отличаются от обычных правил тем, что
их определение, прежде чем оно будет использовано в других прави-
лах обрабатывается математическим модулем. В настоящей версии
этим модулем является Mathematica 5.2. Как следствие определе-
ние правила типа «формула» должно быть корректным выражением
языка Mathematica.

Для того, чтобы указать, что некоторое правило является вычис-
лимым следует предварить открывающую фигурную скобку опре-
деления правила символом тильда. Так, в следующем примере при
вычислении правила rule2 определение первого правила сначала бу-
дет передано математическому модулю для вычисления, а затем уже
результат вычисления будет подставлен во второе правило.

rule1 ~{ 2+2 }
rule2 { y + #rule1 }

Таким образом, значение rule2 после вычисления будет y+4.

8

Каждая грамматика должна содержать в себе как минимум три
правила отвечающие за формулирофку задачи, решение и ответ. Эти
три правила являются корневыми и все прочие правила будут ис-
пользованны и вычисленны только в том случае если какое-нибудь
главное правило прямо или косвенно ссылается на него.

Эти правила имеют зарезервированные имена. Правило для
формулировки задачи называется «problem». Правило для реше-
ния: «solution». Правило для ответа: «answer». После имён правил
«problem» и «solution» должно идти ключевое слово «output».

В качестве иллюстрации приведём пример простейшей грамма-

тики:

number { 42 }
problem output { Введите число #number }
answer { #number }
solution output {

Вы правильно решите эту задачу,
если введёте число #number

}

Из этой грамматики может быть сгенерирована только одна зада-
ча. Когда студент выбирает эту задачу, обучающая система выводит
предложение «Введите число 42» и в том случае если студент вве-
дёт в поле ответа что-то другое выводит «Вы правильно решите эту
задачу, если введёте число 42».

4.2 Принцип генерация задач

Возможность генерации большого количества задач на основе од-
ного файла грамматики обеспечивается за счёт так называемых пра-
вил случайных значений. Эти правила являются специальными фор-
мулами, которые характеризуются тем, что их значения не определе-
ны заранее, а случайным образом выбираются из заданного списка
значений при каждом обращении к грамматике.

9

Это достигается за счёт применения возможностей математиче-
ского модуля генерации случайных чисел. Таким образом, если за-
менить в примере простой грамматики из придедущего подраздела
первую строку на number ~{ Random[ Integer, { 1, 42000 } ] },
то на основе такой грамматики может быть сгенерированно 42000
различных задач, для решения которых нужно будет ввести предло-
женное целое число в диапозоне от 1 до 42000.

В качестве более сложного примера рассмотрим генерацию пра-
вила со значением, представляющем собой произведение функции и
числового множителя.

t ~{ Random[ Integer, {

1, 12 } ] }

a ~{ Random[ Integer, { -10, 10 } ] }

t1 ~{ Switch[#t11, 1, Sin[x], 2, Cos[x],
3, Tan[x], 4, Cot[x],
5, ArcSin[ x ], 6, ArcCos[ x ],
7, ArcTan[ x ], 8, ArcCot[ x ],
9, Exp[ x ], 10, x^( #z ),
11, Log[ x ], 12, Sqrt[ x ],
13, x]}

f {#a*#t1}

В этом примере правило случайных значений t используется для
выбора случайной функции из списка. Правило a используется для
вычисления множителя.

Результат правила f оказывается зависимым от обоих правил

случайных значений.

10

5 Конструктор грамматик

5.1 Описание

Конструктор грамматик это приложение упрощающее создание
файлов грамматик и их загрузку в систему. Конструктор предостав-
ляет удобный интерфейс для ввода элементов грамматики, таких как
условие задачи, ответ и решение.

Конструктор даёт пользователям возможность создавать грам-

матики не изучая язык SimpleTask, использующийся в системе.

Начиная работу с конструктором пользователь может выбрать с
каким элементом он желает работать. Он может как начать вводить
один из трёх главных элементов так и ввести некий вспомогательный
элемент.

5.2 Реализованные возможности конструктора

5.2.1 Функция проверки грамматики

Конструктор предоставляет возможность отправить созданную
грамматику на проверку ядру обучающей системы. Получив запрос
от конструктора на проверку грамматики ядро проверяет синтак-
сическую корректность и отсылает конструктору отчёт о проверке,
содержащий в себе либо сообщение о том, что всё правильно, ли-
бо сообщение ошибки. Пользователь конструктора может запросить
проверку грамматики в любой момент времени.

Проверка грамматики внутри ядра происходит следующим об-
разом. Ядро загружает грамматику в систему и пытается сгенери-
ровать задачу на её основе. Если генерация задачи была произве-
дена успешно, то конструктору возвращается сообщение, говорящее
о корректности грамматики. В случае возникновения ошибки в коде
ядра генерируется исключение с текстом, описывающим имеющуюся
проблему. Конструктору возвращается сообщение, содержащее этот
текст. Грамматика, переданная ядру на проверку, хранится внутри
системы во временном файле.

11

Для реализации этой задачи внутри ядра был создан специаль-
ный сервлет, обрабатывающий запросы конструктора на проверку
грамматики. В конструкторе была организована функция, осуществ-
ляющая обращение к сервлету посредством html запроса типа POST.
Текст грамматики передаётся сервлету в качестве параметра.

5.2.2 Функция визуализации математических выражений

При работе с конструктором и заполнением различных состав-
ляющих описания задачи пользователям часто бывает необходимо
получить наглядное представление о том, как различные матема-
тические выражения, участвующие в описании будут выглядеть в
окне браузера. Пользователь конструктора работает с формулами,
описанными в формате, который понятен математическому моду-
лю обучающей системы, то есть в формате Mathematica. Однако,
для эффективной работы пользователю требуется иметь изображе-
ние формул и окружающего их текста в традиционной, привычной
форме.

Для решения этой задачи в конструкторе была организована
функция визуализации математических выражений. Визуализация
построена по следующему принципу. Описание какого-либо элемен-
та грамматики состоит из текста, который должен отображаться как
есть и из математических формул, которые сначала должны быть
преобразованы в соответствующие изображения. Когда пользова-
тель отправляет команду конструктору визуализировать тот элемент
грамматики с которым он в данный момент работает, конструктор
анализирует введённый пользователем текст и путём синтаксическо-
го разбора находит участки текста, в которых описываются мате-
матические выражения. Далее конструктор преобразует найденные
формулы в изображения, вставляет их на соответствующие места в
тексте и выводит результат на экран.

Для преобразования описания формулы в изображение применя-
ется сторонняя библиотека. При решении вопроса об используемой
библиотеке было рассмотрено два варианта.

Первый вариант: библиотека JEuclid, поддерживающую функ-

12

цию визуализации формул в формате MathML. В этой библиоте-
ке имелись реализации расширений компонентов SWING, способные
отображать формулы. Эта библиотека удовлетворяла требованиям
по функционалу, но полученные с её помощью результаты были недо-
статочно хорошего качества, поэтому было принято решение найти
альтернативные варианты.

Второй рассмотренный вариант: библиотека jlatexmath. Эта биб-
лиотека позволяет отрисовывать формулы таким образом, как эта
делает система компьютерной вёрстки TEX и следовательно каче-
ство работы этой библиотеки очень высоко. В то же время она не
требует доступа к системе TEX и способна работать автономно.

Библиотека jlatexmath работает с математическими выражени-
ями в формате LATEX. Таким образом, прежде, чем применять её
требовалось решить проблему преобразования формул, написанных
в формате Mathematica в этот формат.

Эта задача была решена средствами самой системы Mathematica.
Когда пользователю требуется визуализировать формулу, конструк-
тор обращается к системе Mathematica с запросом конвертировать
требуемое математическое выражение из своего формата в формат
LATEX. После этого конструктор передаёт полученное описание фор-
мулы библиотеке jlatexmath и получает изображение.

Конструктор имеет две возможности получить доступ к мате-
матическому модулю. В начале конструктор пытается найти си-
стему Mathematica на локальном компьютере. Для этого он сна-
чала анализирует файл настроек программы. В этом файле мо-
жет быть указан путь к исполняемому ядру математики. Если путь
действительно указан и он корректен конструктор соединяется с
Mathematica по указанному пути и использует её для преобразования
форматов. В противном случае конструктор пытается найти систе-
му Mathematica, используя реестр операционной системы Windows.
Это возможно, так как Mathematica при установке, записывает ад-
рес своей рабочей папки в известный раздел реестра и конструктор
может проанализировать его. Для работы с реестром в конструк-
торе используется нативная библиотека jRegistryKey. В том случае
если систему Mathematica удалось найти через реестр операционной

13

системы, конструктор записывает путь к ядру Mathematica в файл
настроек, для того, чтобы в следующий раз иметь возможность вос-
пользоваться первым способом нахождения математического моду-
ля.

Конструктор использует систему Mathematica с помощью той же

библиотеки и тем же методом, что и ядро системы.

В том случае если конструктор не может обнаружить математи-
ческий модуль на локальном компьютере, он делает попытку свя-
заться с ядром обучающей системы и передать требуемую задачу
ему. Для реализации этой возможности в ядре был добавлен ещё
один сервлет обрабатывающий запросы на преобразования матема-
тических выражений из одного формата в другой. Для осуществле-
ния своих функций этот сервлет использует возможности системы
Mathematica. Он способен преобразовывать формулы записанные в
формате Mathematica в форматы MathML и LATEX.

Таким образом для работы функции визуализации формул
требуется либо установленная на локальном компьютере система
Mathematica, либо соединение с интернетом. В первом случае кон-
структор сможет провести преобразование используя локальный ма-
тематический модуль, а во втором требуемые преобразования реали-
зуются посредством ядра обучающей системы.

5.2.3 Функция конвертирования формул в формате LATEX

в формат Mathematica

В конструкторе реализована возможность преобразования ма-
тематических выражений описанных в формате LATEX в формат
Mathematica. Посредством этой функции пользователь при состав-
лении шаблона задачи может записывать формулы в формате LATEX,
после чего конструктор будет преобразовывать их.

В конструкторе имеется встроенный конвертор формул, который
осуществляет преобразование в несколько этапов. Данный конвертор
представляет собой композицию нескольких сторонних конверторов,
преобразующих данные, в несколько промежуточных форматов.

Сначала исходная формула, написанная в формате LATEX пре-

14

образуется в презентационный MathML, затем в содержательный
MathML.

Основное различие между презентационным и содержательным
MathML заключается в следующем. Презентационный MathML
описывает, как математическое выражение должно отображаться
на экране устройства или на бумаге. По сути, презентационный
MathML представляет собой набор инструкций, руководствуясь ко-
торыми програма визуализирует формулу. Этим презентационный
MathML похож на LATEX и поэтому преобразовать выражение из од-
ного формата в другой достаточно простая задача. Содержательный
MathML описывает математическую формулу с точки зрения её се-
мантики. Другими словами, информация присутствующая в описа-
нии математического выражения на языке содержательного MathML
содержит в себе данные о логических связях между математически-
ми объектами участвующими в формуле, таких как: «𝑥 умножается
на 𝑦», «применение функции 𝑓 к аргументу 𝑥» или «𝑥 принадлежит
множеству 𝑋».

Это означает, что описание формулы на языке презентационно-
го MathML или LATEX содержит в себе информацию, касающую-
ся правил отображения, которая не содержится в содержательном
MathML. Приведём, в качестве иллюстрации следующий простой
пример:

<math xmlns="http://www.w3.org/1998/Math/MathML">

<mrow>

<mi>x</mi>
<mo>*</mo>
<mi>[</mi>
<mi>y</mi>
<mo>+</mo>
<mn>1</mn>
<mi>]</mi>

</mrow>

</math>
Это описание формулы 𝑥*[𝑦+1] на языке презентационного MathML.

15

Оно является просто последовательностью символов, которые долж-
ны быть изображены друг за другом. В этом описании смысловая со-
ставляющая формулы не указана, однако, определены внешний вид
скобок и знака умножения. Следующий пример содержит описание
той же формулы на языке содержательного MathML.

<math xmlns=’http://www.w3.org/1998/Math/MathML’>

<apply>

<times/>
<ci>x</ci>
<apply>

<plus/>
<ci>y</ci>
<cn type=’integer’>1</cn>

</apply>

</apply>

Здесь наоборот определена семантика формулы, а информация об
отображении опущена. Эта формула может быть отображена как
𝑥 × (𝑦 + 1), 𝑥 · [𝑦 + 1], 𝑥 {𝑦 + 1} и другими способами не влияющими
на семантику.

Вообще говоря, существует множество языков описывающих ма-
тематические формулы и всех их можно разделить на две группы.
Первая группа состоит из языков, описывающих способы отобра-
жения формулы. К этой группе относятся такие языки как LATEX и
презентационный MathML. Вторая группа состоит из языков, описы-
вающих семантику формулы. К этой группе относятся такие языки
как содержательный MathML, OpenMath и почти все языки, исполь-
зующиеся в системах компьютерной алгебры, в том числе и в системе
Mathematica.

Преобразование, проводимые между языками одной группы не
является сложной задачей, так как описания формул на этих языках
содержат одну и ту же информацию.

Отсутствие информации об отображении в языках второй груп-
пы, также, не является серьёзной проблемой в том случае если эта
информация не является критически важной, так как всегда можно

16

использовать некоторый стандартный вариант визуализации форму-
лы.

Однако, при написании конвертора, требовалось осуществить
преобразование описания формулы на языке первой группы (LATEX
или презентационный MathML) в описание на языке второй группы
(формат Mathematica).

Это преобразование гораздо сложнее. Проблема заключается в
том, что одному и тому же изображению формулы может соответ-
ствовать несколько конкретных формул с разной семантикой и ника-
кой стандартной семантики определить нельзя. Поясним сказанное
примером: выражение 𝐿(𝑥 + 𝑦) может интерпретироваться как «𝐿
умноженное на сумму 𝑥 и 𝑦» или «функция 𝐿 применённая к сумме
𝑥 и 𝑦». Что в действительности означает данная формула, можно
определить только из контекста, в котором это выражение приме-
няется. В отрыве от контекста, когда данный пример рассматривает
человек, он обычно принимает решение на основании первого симво-
ла. Например, в выражении 𝑓 (𝑥 + 𝑦) символ 𝑓 скорее всего означает
функцию, так как этот символ часто используется для этой цели, с
другой стороны в формуле 𝑎(𝑥 + 𝑦) символ 𝑎 скорее всего является
множителем. Однако, на самом деле это лишь предположение.

Данный пример показывает, что сконструировать абсолютно кор-
ректный конвертор презентационного MathML в содержательный
невозможно принципиально. Возможно, используя различные при-
ёмы из области искуственного интелекта, построить конвертор, ко-
торый будет работать правильно почти всегда.

В интернете существует довольно мало доступных программ-
ных продуктов поддерживающую данную функциональность. В кон-
структоре для этой используется библиотека SnuggleTeX. Данная
библиотека позволяет проводить преобразование формул в формате
LATEX в презентационный MathML, а затем осуществлять операцию
семантического пополнения Up-Conversion, преобразуя презентаци-
онный MathML в содержательный.

После получения содержательного MathML требовалось преоб-
разовать его в формат Mathematica. Так как прямого конвертора
не удалось найти, было решено использовать формат OpenMath в

17

качестве промежуточного.

OpenMath это язык описания формул основанный на XML, кото-
рый был специально создан для обмена математическими выражени-
ями между различными приложениям, использующими математику.
В том числе между различными системами компьютерной алгебры
и компьютерных вычислений, такими как Mathematica, Maple, Sage
и другими. Как следствие, в настоящее время существует множество
конверторов, преобразующих описания формул на языке OpenMath
в формат различных математических систем. Такие конверторы име-
ют названия PhraseBooks. Для преобразования OpenMath в кон-
структоре используется такой конвертор.

Содержательный MathML преобразуется в OpenMath путём
использования документа XSLT (eXtensible Stylesheet Language
Transformations). Это язык преобразований XML документов име-
ющий прямую поддержку в стандартных библиотеках языка Java.

Таким образом, конвертор проводит преобразования, осуществ-

ляя следующие шаги:

1. Конвертор получает исходный текст описания математиче-
ского выражения в формате LATEX и с помощью библиоте-
ки SnuggleTeX преобразует его в формат презентационного
MathML.

2. С помощью постпроцессора библиотеки SnuggleTeX преобразу-
ет полученный результат из презентационного MathML в со-
держательный.

3. Используя документ XSLT и встроенный в Java преобразова-
тель XML документов осуществляет конвертирование из содер-
жательного MathML в формат OpenMath.

4. С помощью кодека Mathematica PhraseBook преобразует полу-

ченное выражение в формат Mathematica.

При работе с XML документами конвертор использует DOM мо-
дель документа и работающие с ней DOM парсеры из стандартной
библиотеки Java.

18

Не смотря на то, что полученный конвертор корректно работает
с большим подмножеством языка Mathematica существуют несколь-
ко важных элементов нуждающихся в дополнительной обработке.
Такими элементами являются интегралы, различные формы пред-
ставления производных, нижние индексы переменных и прочее. Все
подобные элементы имеют поддержку в языке Mathematica, одна-
ко используемые в конверторе библиотеки не корректно работают
с ними. Для обработки этих особых случаев был сконструирован
ещё один конвертер, который использует первый как основной, но
находит и самостоятельно конвертирует отдельные части исходного
выражения, которые не поддаются его обработке. Этот конвертер
расширяем и может быть использован для модификации действий
основного конвертора. При проведении преобразования конструктор
обращается к внешнему конвертеру, а тот по мере необходимости
использует функционал основного.

5.3 Интерфейс конструктора

Рис. 6: Главное окно конструктора.

В этом разделе будет описан интерфейс конструктора и рассмот-

рен пример создания файла грамматики с его помощью.

19

Рассмотрим главное окно конструктора, изображённое на рисун-

ке в начале раздела.

В верхней части окна расположенны две кнопки. Кнопка «add
formulation» используется для добавления в грамматику новых эле-
ментов. Эти элементы могут быть как главними, то есть формули-
ровкой задачи, решением задачи или ответом, так и вспомогательны-
ми. Кнопка «check grammar» служит для отправки запроса грамма-
тики на сервер для проверки. При её нажатии конструктор основы-
ваясь на введённых элементах создаёт текст грамматики, генерирует
запрос ядру обучающий системы с требованием провести проверку
и отправляет созданный текст в качестве аргумента.

Ниже расположен список введённых пользователем правил из ко-
торых текст грамматики будет генерироваться. При первом запуске
конструктора этот список пуст.

Дополнительные функции, касающиеся файлов грамматики в це-

лом, доступны в меню file.

Рис. 7: Меню file.

20

Конструктор поддерживает возможности сохранения файла
грамматики на локальном компьютере, а так же загрузку ранее со-
хранённых или написанных вручную грамматик.

Функция отправки готовой грамматики на сервер реализованна
следующим образом. Конструктор извлекает из вайла свойств иден-
титификатор преподавателя и конструирует запрос к специальному
модулю работающему с ядром системы на сервере. Модуль обнов-
ляет базу данных задач и добавляет новую задачу в список задач
данного преподователя. С этого момента новая задача становиться
доступной.

Меню help содержит один пункт: Malual. При его выборе кон-
структор обращается к установленной веб странице содержащей опи-
сание программы и открывает её в броузере.

Теперь обратимся к функциям добавления новых правил в грам-
матику. Рассмотрим окно добавления нового элемента, которое по-
является при нажатии на кнопку «add formulation».

Рис. 8: Добавление нового правила.

21

В этом окне пользователь может выбрать какой именно элемент
он хочет добавить. Пользователь может выбрать один из четырёх
вариантов для того, чтобы ввести соответственно формулировку за-
дачи, правильный ответ, решение задачи или любое другое вспомо-
гательное правило. В последнем случае пользователю нужно ввести
имя дополнитеьного правила в текстовом поле справа от элемента
списка. При нажатии на кнопку «Save» правило будет добавлено в
грамматику и можно будет приступить к его редактированию.

После добавления в грамматику правила, отвечающего за фор-
мулировку задачи главное окно приложения будет выглядеть следу-
ющим образом:

Рис. 9: Добавление формулировки задачи.

Теперь список добавленных элементов содержит одно правило.
Все правила добавляются в список элементов в виде кнопок. При
нажатии на кнопку соответствующую некоторому правилу можно
приступить к его редактированию. Все правила, которые были толь-
ко что добавлены изначально пусты.

22

Рассмотрим окно для редактирования правил.

Рис. 10: Окно редактирование правил.

В верхней части окна расположены большое количество кнопок
облегчающих ввод различных математических выражений. Ариф-
метические операторы, разные математические символы, элементар-
ные функции, интеграллы и производные. Все подобные кнопки ра-
ботают по одному принципу При нажатии на какую-нибудь из них
в текстовое поле внизу слева вставляется соответствующий кнопке
шаблон языка Mathematica. В том случае если ввод шаблона требу-
ет дополнительных параметров, например, в случае интегралов тре-
буется ввести переменную после дифференциала, справа от кнопки
«правила гнерации» появляются текстовые поля в которых можно
будет ввести требуемые значения и вставка шаблона в этом случае
производится после нажатия кнопки применить.

Для того чтобы сделать описание интерфейса более наглядным
рассмотрим пример создания грамматики для простой задачи. В ка-

23

𝛽𝑥

честве примера рассмотрим задачу нахождение предела выражения
при 𝑥 → 0. Составим грамматику, генерирующую задачи
вида sin(𝛼𝑥)
с изменяемыми параметрами 𝛼 и 𝛽. Пусть параметр 𝛼 будет принад-
лежать диапазону от 3 до 17 а параметр 𝛽 принадлежать диапазону
от 5 до 42.

Начнём с создания правил случайных значений для параметров
𝑎 и 𝑏. Для этого создадим и добавим в грамматику два правила
случайных значений с именами a и b.

Рис. 11: Добавление параметров «a» и «b».

Рис. 12: Список элементов после добавления.

24

Теперь приступим к их редактированию. В окне редактирования
правил есть кнопка «правила генерации». Она специально предна-
значена для ввода правил случайных значений. При нажатии на неё
открывается следующее окно.

Рис. 13: Окно для генерации случайных значений.

В этом окне можно выбрать желаемый тип случайного значения,
целочисленный или действительный, а также диапазон значений в
пределах которого должен находиться настраеваемый параметр.

Рис. 14: Настройка параметров a и b.

Нижняя часть окна редактирования разделена на две области.
Левая область является текстовым полем для ввода правила. Сюда

25

нужно вводить весь текст и ссылки на другие элементы, которые
будут использлваться. В правой области расположена панель отоб-
ражения формул. При нажатии на кнопку «посмотреть в виде фор-
мулы» конструктор считывает текст из поля ввода и преобразует его
в графическое изображение.

Для параметра «a» окно редактирования правил будет выглядеть

следующим образом:

Рис. 15: Окно редактирования для правила случайных значений.

В поле ввода текста правила, появилось выражение язака
Mathematica Random[ Integer, { 3, 17 } ]. Это выражение, бу-
дучи выполненым ядром Mathematica, даст в результате случайное
целое число от 3 до 17.

Далее добавляем в грамматику формулировку задачи и запол-
няем её. Панель параметров, расположенные прямо над полем вво-
да содержит кнопки для вставки самых ссылок на другие правила.
В выпадающем списке слева содержатся именна всех созданных в

26

грамматике правил.

Рис. 16: Список правил.

Поле ввода текста правила будет выглядеть следующим образом.

Рис. 17: Формулировка задачи.

Приступим к вводу решения. Добавим в грамматику соответству-
ющее правило и отредактируем его. Для того, что бы продемонстри-
ровать функцию визуализации формул, дополнительно щёлкнем по
кнопке «посмотреть в виде формулы». В результате получим следу-
ющее:

27

Рис. 18: Решение задачи.

Теперь остаётся только ввести правльный ответ на задачу. Обу-
чающая система будет сравнивать его с ответом, введённым поль-
зователем. Для этого добавляем элемент «answer» и пишем в нём
#a/#b.

После добавления всех правил главное окно приложения будет

выглядеть следующим образом:

28

Рис. 19: Главное окно с готовой грамматикой.

Теперь можно сохранить результат в файле или отправить грам-
матику на сервер. В результате своей работы конструктор сгенери-
рует следующий текст:

a ~{ Random[ Integer, { 3, 17 } ] }
b ~{ Random[ Integer, { 5, 42 } ] }
problem output
{
Найдите предел выражения Sin[ #a*x ]/(#b*x)

при x стремящемся к 0.

}

solution output
{
Для решения задачи произведём замену переменной.
Пусть t = #a * x.
Тогда исходное выражение принимает вид
Limit[ Sin[ t ] /(
Теперь, выносим множитель при знаменателе

(#b / #a) * t ), t->0 ].

29

за знак предела и учитывая, что
Limit[Sin[t]/t,t->0] = 1 получаем ответ #a / #b.
}

answer ~{ #a / #b }

6 Интерфейс пользователя для операци-

онной системы Android

Интерфейс пользователя для операционной системы Android
это специальное приложение, позволяющие пользователям исполь-
зовать обучающую систему с помощью мобильных устройств на базе
Android. Это приложение позволяет пользователям подключаться к
обучающей системе, посылать ей запросы на генерацию задач и по-
лучать сгенерированные задачи. Далее пользователь может послать
системе ответ на задачу для того чтобы ядро его проверила. Если
ответ на задачу не правильный Andriod приложение отображает ре-
шение сгенерированной задачи.

Таким образом описываемый интерфейс пользователя поддержи-

вает весь обучающий процесс для пользователя системы.

Изначально окно приложения содержит элементы управления,
позволяющие пользователю войти в систему. При вводе логина
Android интерфейс проверяет, зарегистрирован ли в системе поль-
зователь с таким логином. Эта проверка осуществляется с помощью
html запроса соответствующей php странице веб-интерфейса. Запрос
имеет тип Get. Проверяемый логин пользователя посылается веб-
интерфейсу в качестве параметра.

В том случае если пользователь с таким логином зарегистриро-
ван Android интерфейс посылает веб-интерфейсу запрос с требова-
нием вернуть список типов задач, доступных этому пользователю.
Веб-интерфейс хранит информацию о пользователе в файлах cookie.
При обращении к веб-интерфейсу интерфейс Android устанавлива-
ет в своём html запросе требуемые cookie и благодаря этому веб-
интерфейс возвращает отклик содержащий нужный список класслв

30

Рис. 20: Вход в систему

задач. Отклик веб-интерфейса возвращается в виде html, поэтому
для получения нужного списка Android интерфейс проводит синтак-
сический анализ отклика и извлекает нужные элементы.

Приложение отображает полученный список задач в виде спис-
ка элементов управления каждый из которых относиться к одному
из доступных классов задач. При клике на один из таких элементов
управления приложение конструирует соответствующий html запрос
к ядру системы. В этом запросе указан тип задачи, который нужно
будет использовать для генерации. После принятия запроса ядро ге-
нерирует задачу и возвращает отклик в формате XML содержащий
в себе формулировку задачи, правильный ответ и решение задачи.

31

Рис. 21: Список доступных классов задач

После получение сгенерированной задачи Android интерфейсу
требуется отобразить на экране условие задачи. Формулировка за-
дачи в XML отклике представляет собой тело html страницы содер-
жащее простой текст и описание математических формул в формате
MathML. Отображение формулировки задачи реализованно с помо-
щью встроенного элемента Android WebView, служащего для отоб-
ражения на экране содержания html страниц. Для того чтобы это
стало возможным Android приложение генерирует html страницу, со-
держащую формулировку задачи и передаёт её элементу WebView.
Самая большая проблема при разработке Android интерфейса
заключалась в том, что элемент WebView не поддерживает описа-

32

ние математических выражений в формате MathML. Следовательно
формулы не отображаются в нём как требуется. Для решения этой
проблемы была применена javascript библиотека MathJax. Для того,
чтобы подключить требуемую библиотеку достаточно было подклю-
чить к генерируемой html странице ссылку на скрипт MathJax. В на-
стоящей версии Android интерфейса соответствующая ссылка встав-
ляется в заголовок html страницы формулировки задачи, а также
страницы отображающей решение.

Рис. 22: Пример отображения условия задачи

Находясь в состоянии отображения условия задачи Android ин-
терфейс предоставляет пользователю поле для ввода ответа и кнопку
для отправки этого ответа ядру. При нажатии на кнопку приложение

33

конструирует html запрос к ядру системы, содержащий ответ введён-
ный пользователем и првильный ответ. Android приложение не мо-
жет самостоятельно сравнить ответы по той причине, что правиль-
ный ответ может быть введён пользователем в различных формах.
Для того, чтобы корректно сравнивать правильный и пользователь-
ский ответ приложению требовалось бы устанавливать математиче-
скую эквивалентность между ответами, что в общем слуучае явля-
ется слишком сложной задачей для Android приложения. К томуже
эту задачу нельзя упростить в силу того, что в системе в перспек-
тиве возможно существование типов задач произвольной сложности.
По этим причинам математическую эквивалентность проверяет яд-
ро системы используя для этого свой математический модуль. Ре-
зультат сравнения ответов передаётся обратно Android интерфейсу
в html отклике. Если приложение получает негативный результат, то
есть результат, говорящий о том, что пользователь ошибся. Система
отображает правильное решение задачи.

Рис. 23: Пример отображения решения задачи

34

При отображении решения применяется тотже механизм, что и
при отображении формулировки задачи. В данном примере решение
задачи не умещается на экране эмулятора целиком. Поэтому отоб-
ражаемая html страница прокручена в самый низ, к отображаемому
ответу.

Библиотека MathJax обрабатывает html страницу, находя в ней
описание математических формул в формате MathML и заменяя их
изображениями. Эта обработка проводится автоматически при каж-
дом отображении страницы.

После правильного или неправильного решения задачи пользо-
ватель может вернуться обратно к списку доступных классов задач
кликнув по кнопке «Вернуться».

35

7 Приложение

Данное приложение содержит исходные тексты программ, отве-
чающие за функционал, реализованный в рамках настоящей диплом-
ной работы.

Исходные тексты реализованных фунций кон-
структора

Converter.java

package v3 ;
/**
*
* @author Dmitriy Krylov
*/
public abstract c l a s s C o n v e r t e r
{

public

abstract S t r i n g c o n v e r t ( S t r i n g i n p u t
throws I n c o r r e c t S y n t a x E x c e p t i o n ;

)

}

WolfMathToLaTeXConverter.java

package v3 ;

import j a v a . i o . IOException ;
import j a v a . u t i l . L i n k e d L i s t ;
import v3 . MathConnection . MathConnectionException ;
/**
*
* @author Dmitriy Krylov
*/
public
c l a s s
extends C o n v e r t e r
{

WolfMathToLaTeXConverter

@Override
public S t r i n g c o n v e r t ( S t r i n g i n p u t
{

)

i n p u t == n u l l

)

throw new N u l l P o i n t e r E x c e p t i o n ( " i n p u t

i s n u l l " ) ;

i n p u t . e q u a l s ( " " )

)

i f (
{

}

i f (
{

36

return " " ;

i n t remainingAttempts = 2
remainingAttempts > 0
remainingAttempts−−

;
;

}

f o r (

) {

try
{

Log . msg ( " c o n v e r t "+i n p u t+" with l o c a l math module " ) ;

MathConnection mc = MathConnection . g e t I n s t a n c e ( ) ;

S t r i n g r e q u e s t = "TeXForm [ HoldForm [ "+i n p u t+" ] ] " ;
S t r i n g r e s u l t

= mc . s en dR eq ue s t (

r e q u e s t

) ;

r e s u l t

!= n u l l

)

Log . msg ( " s u c c e s s " ) ;
return r e s u l t ;

i f (
{

}

}
catch ( MathConnectionException ex )
{

Log . msg ( " f a i l : "+ex . g e t L o c a l i z e d M e s s a g e ( )
Log . msg ( " t r y a g a i n " ) ;

) ;

}

}

try
{

Log . msg ( " c o n v e r t "+i n p u t+" with remote math module " ) ;

j a v a . u t i l . L i s t <S t r i n g [] > params = new L i n k e d L i s t < >();

params . add (new S t r i n g [ ] { " inputFormat " , "WolfMath" } ) ;
params . add (new S t r i n g [ ] { " outputFormat " , "LaTeX"
} ) ;
} ) ;
params . add (new S t r i n g [ ] { " t e x t "

i n p u t

,

CSendTemplateToPost p o s t R e q u e s t = new CSendTemplateToPost ( ) ;

// посылка запроса
S t r i n g u r l = " h t t p : / / i n t . pm . miem . edu . ru / "

+ " taskpower3_war_exploded / c o n v e r t e r S e r v l e t . do " ;

S t r i n g r e s u l t = p o s t R e q u e s t . s e n d P o s t R e q u e s t ( u r l , params

) ;

S t r i n g p r e f i x = " r e s p o n s e page s o u r c e : " ;
i n t s t a r t = r e s u l t . indexOf ( p r e f i x ) ;
i f (
{

!= −1 )

s t a r t

s t a r t += p r e f i x . l e n g t h ( ) + 2 ;
r e s u l t = r e s u l t . s u b s t r i n g (
i f (
{

r e s u l t . s t a r t s W i t h ( " e r r o r : " ) == f a l s e )

s t a r t

) ;

return r e s u l t ;

}

IOException ex )

}

}
catch (
{

37

Log . msg ( " f a i l : "+ex . g e t L o c a l i z e d M e s s a g e ( )

) ;

}

return n u l l ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

S t r i n g getErrorMsg ( )
{

return " " ;

}

}

LaTeXToWolfMathConverter.java

package v3 ;

import j a v a . i o . CharArrayWriter ;
import j a v a . i o . IOException ;
import j a v a . i o . InputStream ;
import j a v a . u t i l . L i s t ;
import j a v a . u t i l . L o c a l e ;
import j a v a x . xml . t r a n s f o r m . T r a n s f o r m e r ;
import j a v a x . xml . t r a n s f o r m . T r a n s f o r m e r C o n f i g u r a t i o n E x c e p t i o n ;
import j a v a x . xml . t r a n s f o r m . T r a n s f o r m e r E x c e p t i o n ;
import j a v a x . xml . t r a n s f o r m . T r a n s f o r m e r F a c t o r y ;
import j a v a x . xml . t r a n s f o r m . dom . DOMSource ;
import j a v a x . xml . t r a n s f o r m . stream . S t r e a m R e s u l t ;
import j a v a x . xml . t r a n s f o r m . stream . StreamSource ;
import n l . t u e . win . r i a c a . mathematica . c o d e c . MathematicaCodec ;
import n l . t u e . win . r i a c a . openmath . c o d e c . CodecEncodeException ;
import o r g . w3c . dom . Document ;
import o r g . w3c . dom . Element ;
import o r g . w3c . dom . Node ;
import o r g . w3c . dom . NodeLi st ;
import uk . ac . ed . ph . s n u g g l e t e x . I n p u t E r r o r ;
import uk . ac . ed . ph . s n u g g l e t e x . S n u g g l e E n g i n e ;
import uk . ac . ed . ph . s n u g g l e t e x . S n u g g l e I n p u t ;
import uk . ac . ed . ph . s n u g g l e t e x . S n u g g l e S e s s i o n ;
import uk . ac . ed . ph . s n u g g l e t e x . i n t e r n a l . u t i l . X M L U t i l i t i e s ;
import uk . ac . ed . ph . s n u g g l e t e x . u p c o n v e r s i o n . MathMLUpConverter ;
import uk . ac . ed . ph . s n u g g l e t e x . u p c o n v e r s i o n . U p C o n v e r s i o n F a i l u r e ;
import uk . ac . ed . ph . s n u g g l e t e x . u p c o n v e r s i o n . U p C o n v e r s i o n O p t i o n D e f i n i t i o n s ;
import uk . ac . ed . ph . s n u g g l e t e x . u p c o n v e r s i o n . UpConversionOptions ;
import uk . ac . ed . ph . s n u g g l e t e x . u p c o n v e r s i o n . U p C o n v e r s i o n U t i l i t i e s ;
import uk . ac . ed . ph . s n u g g l e t e x . u p c o n v e r s i o n . i n t e r n a l . U p C o n v e r s i o n P a c k a g e D e f i n i t i o n s ;
import uk . ac . ed . ph . s n u g g l e t e x . u t i l i t i e s . M a t h M L U t i l i t i e s ;
import uk . ac . ed . ph . s n u g g l e t e x . u t i l i t i e s . MessageFormatter ;
/**
*
* @author Dmitriy Krylov
*/
public
c l a s s
extends C o n v e r t e r
{

LaTeXToWolfMathConverter

private f i n a l L o c a l e l o c a l e ;

38

private f i n a l S n u g g l e E n g i n e e n g i n e ;
private f i n a l UpConversionOptions upOpts ;
private f i n a l MathMLUpConverter upConverter ;
private f i n a l T r a n s f o r m e r cMathMLToOpenMath ;

private S t r i n g B u i l d e r
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

e r r o r s B u f f e r = n u l l ;

private s t a t i c LaTeXToWolfMathConverter
public
{

s t a t i c LaTeXToWolfMathConverter g e t I n s t a n c e ( )

i n s t a n c e = n u l l ;

i n s t a n c e != n u l l

)

Log . msg ( " e x i s t

i n s t a n c e " ) ;

Log . msg ( "new i n s t a n c e " ) ;
i n s t a n c e = new LaTeXToWolfMathConverter ( ) ;

i f (
{

}
e l s e
{

}

return i n s t a n c e ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private LaTeXToWolfMathConverter ( )
{

L o c a l e . s e t D e f a u l t ( L o c a l e . ENGLISH ) ;
S t r i n g doMaxima = U p C o n v e r s i o n O p t i o n D e f i n i t i o n s .DO_MAXIMA_NAME;
l o c a l e = L o c a l e . g e t D e f a u l t ( ) ;

try
{

e n g i n e=new S n u g g l e E n g i n e ( ) ;
e n g i n e . addPackage ( U p C o n v e r s i o n P a c k a g e D e f i n i t i o n s . g e t P a c k a g e ( )

) ;

upConverter = new MathMLUpConverter ( ) ;

upOpts=new UpConversionOptions ( ) ;
upOpts . s e t S p e c i f i e d O p t i o n ( doMaxima , " f a l s e " ) ;

T r a n s f o r m e r F a c t o r y f a c t o r y = T r a n s f o r m e r F a c t o r y . n e w I n s t a n c e ( ) ;

InputStream x s l S t r e a m ;
StreamSource x s l S o u r c e ;

x s l S t r e a m = g e t C l a s s ( ) . getResourceAsStream ( "cmmltoom . x s l " ) ;
x s l S o u r c e = new StreamSource ( x s l S t r e a m ) ;

cMathMLToOpenMath = f a c t o r y . newTransformer ( x s l S o u r c e

) ;

}
catch ( T r a n s f o r m e r C o n f i g u r a t i o n E x c e p t i o n ex )
{

throw new RuntimeException ( ex ) ;

}
f i n a l l y
{

L o c a l e . s e t D e f a u l t (

l o c a l e

) ;

39

}

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

@Override
public S t r i n g c o n v e r t ( S t r i n g l a t e x ) throws I n c o r r e c t S y n t a x E x c e p t i o n
{

a s s e r t

l a t e x != n u l l ;

S t r i n g r e s u l t = n u l l ;

c o n v e r s i o n : try
{

L o c a l e . s e t D e f a u l t ( L o c a l e . ENGLISH ) ;
e r r o r s B u f f e r = new S t r i n g B u i l d e r ( ) ;
// −−−−

Document mathDoc = X M L U t i l i t i e s

. createNSAwareDocumentBuilder ( )
. newDocument ( ) ;

r o o t = mathDoc . c r e a t e E l e m e n t ( " r o o t " ) ;

Element
mathDoc . appendChild (
// −−−−

r o o t

) ;

S n u g g l e S e s s i o n s e s s i o n = e n g i n e . c r e a t e S e s s i o n ( ) ;
s e s s i o n . p a r s e I n p u t ( new S n u g g l e I n p u t ( l a t e x )
s e s s i o n . buildDOMSubtree (
// −−−−

r o o t

) ;

) ;

L i s t <I n p u t E r r o r > e r r o r s = s e s s i o n . g e t E r r o r s ( ) ;

i f ( e r r o r s . isEmpty ( ) == f a l s e )
{

I n p u t E r r o r e r r o r

:

e r r o r s

)

S t r i n g e r r o r M s g = MessageFormatter

.

f o r m a t E r r o r A s S t r i n g ( e r r o r

) ;

e r r o r s B u f f e r . append ( ’ \n ’ ) . append ( e r r o r M s g ) ;

f o r (
{

}

throw new I n c o r r e c t S y n t a x E x c e p t i o n ( e r r o r s B u f f e r . t o S t r i n g ( )

) ;

}
// −−−−

Element pMathML = n u l l ;
NodeL ist

nodes = r o o t . g e t C h i l d N o d e s ( ) ;

i n t i = 0 ;

i < nodes . g e t L e n g t h ( ) ; ++i

)

f o r (
{

Node node = nodes . item (
i f ( M a t h M L U t i l i t i e s . isMathMLElement ( node )
{

) ;

i

)

i f ( pMathML == n u l l
{

)

40

pMathML = ( Element ) node ;

S t r i n g msg = "More than one math e l e m e n t . " ;
throw new RuntimeException ( msg ) ;

}
e l s e
{

}

}

}

i f ( pMathML == n u l l
{

)

throw new RuntimeException ( "No math i n p u t . " ) ;

}
// −−−−

mathDoc . removeChild (
mathDoc . appendChild ( pMathML ) ;

r o o t

) ;

mathDoc = upConverter

. upConvertSnuggleTeXMathML ( mathDoc , upOpts

) ;

// −−−−

L i s t <U p C o n v e r s i o n F a i l u r e > f a i l s =
U p C o n v e r s i o n U t i l i t i e s . e x t r a c t U p C o n v e r s i o n F a i l u r e s ( mathDoc ) ;

f a i l s . isEmpty ( ) == f a l s e )

i f (
{

f o r ( U p C o n v e r s i o n F a i l u r e
{

f a i l

:

f a i l s

)

S t r i n g e r r o r M s g = U p C o n v e r s i o n U t i l i t i e s
f a i l

. g e t E r r o r M e s s a g e (

) ;

e r r o r s B u f f e r . append ( ’ \n ’ ) . append ( e r r o r M s g ) ;

}

throw new I n c o r r e c t S y n t a x E x c e p t i o n ( e r r o r s B u f f e r . t o S t r i n g ( )

) ;

}
// −−−−

mathDoc = M a t h M L U t i l i t i e s . isolateAnnotationXML (

mathDoc . getDocumentElement ( ) ,
MathMLUpConverter .CONTENT_MATHML_ANNOTATION_NAME) ;

Element cMathML = mathDoc . getDocumentElement ( ) ;
// −−−−

CharArrayWriter caw = new CharArrayWriter ( ) ;

cMathMLToOpenMath . t r a n s f o r m ( new DOMSource (cMathML)

, new S t r e a m R e s u l t ( caw ) ) ;

S t r i n g openMath = caw . t o S t r i n g ( ) ;
// −−−−

MathematicaCodec c o d e c = new MathematicaCodec ( ) ;

41

S t r i n g wolfMath = c o d e c . encode ( openMath ) ;

r e s u l t = wolfMath ;

}
catch ( CodecEncodeException ex )
{

throw new I n c o r r e c t S y n t a x E x c e p t i o n ( ex . g e t M e s s a g e ( )

) ;

}
catch ( T r a n s f o r m e r E x c e p t i o n |
{

IOException ex )

Log . msg ( ex . g e t L o c a l i z e d M e s s a g e ( )
throw new RuntimeException ( ex ) ;

) ;

}
f i n a l l y
{

L o c a l e . s e t D e f a u l t (

l o c a l e

) ;

}

return r e s u l t ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public s t a t i c void main ( S t r i n g [ ] a r g s
{

new LaTeXToWolfMathConverter ( ) . c o n v e r t ( " $x* ( y+1)$ " ) ;

) throws T r a n s f o r m e r E x c e p t i o n ,

I n c o r r e c t S y n t a x E x c e p t i o n

}

public void p r i n t ( O b j e c t o b j
{

)

System . out . p r i n t l n ( o b j

) ;

}

}

SpecialCaseConverter.java

package v3 ;

import j a v a . u t i l . Arrays ;
import j a v a . u t i l . L i s t ;
/**
*
* @author Dmitriy Krylov
*/
public
c l a s s
extends C o n v e r t e r
{

S p e c i a l C a s e C o n v e r t e r

private f i n a l C o n v e r t e r c o n v e r t e r ;

private f i n a l s t a t i c

L i s t <C l a s s <? extends S p e c i a l C a s e > > c a s e s = Arrays . a s L i s t (

D e r i v a t i v e S p e c i a l C a s e . c l a s s ,
I n t e g r a l S p e c i a l C a s e . c l a s s ,
SumSpecialCase . c l a s s ,
S u b S c r i p t S p e c i a l C a s e . c l a s s ) ;

//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

42

public S p e c i a l C a s e C o n v e r t e r ( C o n v e r t e r c o n v e r t e r
{

)

t h i s . c o n v e r t e r = c o n v e r t e r ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

@Override
public S t r i n g c o n v e r t ( S t r i n g i n p u t
{

) throws I n c o r r e c t S y n t a x E x c e p t i o n

S p e c i a l C a s e R e p o r t
i f (
{

r e p o r t == n u l l

r e p o r t = a p p l y S p e c i a l C a s e s (

i n p u t

) ;

)

return c o n v e r t e r . c o n v e r t (

i n p u t

) ;

}
a s s e r t
// −−−−

r e p o r t . i s V a l i d (

i n p u t

)

: " i n v a l i d s p e c i a l c a s e r e p o r t " ;

char

sCh

= S p e c i a l C a s e . s p e c i a l C h a r ;

l e f t
r i g h t
specConv = r e p o r t . g e t C o n v e r s i o n R e s u l t ( ) ;

= r e p o r t . g e t L e f t ( ) ;
= r e p o r t . g e t R i g h t ( ) ;

i n t
i n t
S t r i n g
// −−−−

i n t numSpecialChars = 0 ;
f o r (
{

i n t pos = 0 ; pos < l e f t ; ++pos

)

char ch = i n p u t . charAt ( pos
i f ( ch == sCh )
{

) ;

numSpecialChars++;

}

}
// −−−−

i n p u t = new S t r i n g B u i l d e r (

i n p u t

)

r e p l a c e (
t o S t r i n g ( ) ;

l e f t ,

r i g h t , S t r i n g . v a l u e O f ( sCh )

)

.
.
// −−−−

S t r i n g r e s u l t = t h i s . c o n v e r t (
i f (
{

r e s u l t == n u l l

)

i n p u t

) ;

return n u l l ;

}
// −−−−

i n t pos = 0 ; pos < r e s u l t . l e n g t h ( ) ; ++pos

)

f o r (
{

char ch = r e s u l t . charAt ( pos
i f ( ch == sCh )
{

) ;

i f ( numSpecialChars > 0 )
{

43

−−numSpecialChars ;

}
e l s e
{

r e s u l t = new S t r i n g B u i l d e r (

r e s u l t

)

.
.

r e p l a c e ( pos , pos +1 , specConv )
t o S t r i n g ( ) ;

break ;

}

}

}
// −−−−

return r e s u l t ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private S p e c i a l C a s e R e p o r t a p p l y S p e c i a l C a s e s ( S t r i n g i n p u t

)

throws I n c o r r e c t S y n t a x E x c e p t i o n

{

S p e c i a l C a s e R e p o r t

r e s u l t = n u l l ;

f o r ( C l a s s c :
{

c a s e s

)

try
{

S p e c i a l C a s e s c = ( S p e c i a l C a s e ) c . n e w I n s t a n c e ( ) ;

r e s u l t = s c . a p p l y (

i n p u t

) ;

i f (
{

}

}
catch (
{

r e s u l t

!= n u l l

)

break ;

I n s t a n t i a t i o n E x c e p t i o n |

I l l e g a l A c c e s s E x c e p t i o n ex )

throw new RuntimeException ( ex ) ;

}

}

return r e s u l t ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public s t a t i c void main ( S t r i n g [ ] a r g s
{

)

try {
LaTeXToWolfMathConverter b a s e C o n v e r t e r = LaTeXToWolfMathConverter

. g e t I n s t a n c e ( ) ;

S p e c i a l C a s e C o n v e r t e r conv = new S p e c i a l C a s e C o n v e r t e r ( b a s e C o n v e r t e r

) ;

S t r i n g i n p u t = " $ \\ i n t \\ f r a c {x }{2} dx$ " ;
S t r i n g c o n v e r t = conv . c o n v e r t (
System . out . p r i n t l n ( c o n v e r t
) ;
} catch ( Throwable e ) { }

i n p u t

) ;

}

44

}

SpecialCase.java

package v3 ;
/**
*
* @author Dmitriy Krylov
*/
public abstract c l a s s S p e c i a l C a s e
{

public s t a t i c f i n a l char s p e c i a l C h a r = ’@ ’ ;

public abstract S p e c i a l C a s e R e p o r t a p p l y ( S t r i n g i n p u t

)

throws I n c o r r e c t S y n t a x E x c e p t i o n ;

}

SpecialCaseReport.java

package v3 ;
/**
*
* @author Dmitriy Krylov
*/
public c l a s s S p e c i a l C a s e R e p o r t
{

i n t l e f t ;
i n t r i g h t ;

private f i n a l
private f i n a l
private f i n a l S t r i n g c o n v e r s i o n R e s u l t ;
// −−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public S p e c i a l C a s e R e p o r t (
{

i n t l e f t ,

i n t r i g h t , S t r i n g c o n v e r s i o n R e s u l t

)

t h i s . l e f t = l e f t ;
t h i s . r i g h t = r i g h t ;
t h i s . c o n v e r s i o n R e s u l t = c o n v e r s i o n R e s u l t ;

Log . msg ( " ( "+ l e f t +" , "+r i g h t+" ) "+c o n v e r s i o n R e s u l t

) ;

}

public i n t g e t L e f t ( )
{

return l e f t ;

}

public i n t g e t R i g h t ( )
{

return r i g h t ;

}

public S t r i n g g e t C o n v e r s i o n R e s u l t ( )
{

return c o n v e r s i o n R e s u l t ;

}

45

public boolean i s V a l i d ( S t r i n g i n p u t
{

)

return (

l e f t > 0
&& r i g h t > 0
&& l e f t < r i g h t
&& r i g h t <= i n p u t . l e n g t h ( )

) ;

}

}

DerivativeSpecialCase.java

package v3 ;

import j a v a . u t i l . A r r a y L i s t ;
import j a v a . u t i l . r e g e x . Matcher ;
import j a v a . u t i l . r e g e x . P a t t e r n ;
/**
*
* @author Dmitriy Krylov
*/
public
c l a s s
extends
{

D e r i v a t i v e S p e c i a l C a s e
S p e c i a l C a s e

private s t a t i c f i n a l S t r i n g fracCmd = " \\ f r a c " ;

private LaTeXParser p a r s e r = n u l l ;

private S t r i n g d i f f T y p e = n u l l ;
private S t r i n g d i f f F u n c = n u l l ;
private S t r i n g d i f f O r d e r = n u l l ;

private A r r a y L i s t <S t r i n g > d i f f V a r s = n u l l ;
private A r r a y L i s t <S t r i n g > d i f f O r d e r s = n u l l ;

private boolean d e r i v a t i v e R e j e c t = f a l s e ;
private boolean f i r s t O r d e r = true ;

private C o n v e r t e r c o n v e r t e r = new S p e c i a l C a s e C o n v e r t e r (

LaTeXToWolfMathConverter . g e t I n s t a n c e ( )

) ;

//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

@Override
public

S p e c i a l C a s e R e p o r t a p p l y ( S t r i n g i n p u t
throws I n c o r r e c t S y n t a x E x c e p t i o n

)

{

a s s e r t

i n p u t != n u l l ;

S p e c i a l C a s e R e p o r t

r e p o r t = n u l l ;

a p p l y :
{

i n t e n t r y I n d e x = i n p u t . indexOf ( fracCmd ) ;
i f ( e n t r y I n d e x == −1 )
{

break a p p l y ;

46

}

p a r s e r = new LaTeXParser (
p a r s e r . readLaTeXCommand ( ) ;

input , e n t r y I n d e x ) ;

parseNumerator ( ) ;
i f ( d e r i v a t i v e R e j e c t
{

break a p p l y ;

}

parseDenominator ( ) ;
i f ( d e r i v a t i v e R e j e c t
{

break a p p l y ;

}

)

)

S t r i n g c o n v e r t e d = c o n v e r t D e r i v a t i v e ( ) ;

i n t s t a r t = e n t r y I n d e x ;
i n t end

= p a r s e r . g e t C u r r e n t P o s ( ) ;

r e p o r t = new S p e c i a l C a s e R e p o r t (

s t a r t , end , c o n v e r t e d ) ;

}

return r e p o r t ;

}

private void parseNumerator ( ) throws I n c o r r e c t S y n t a x E x c e p t i o n
{

boolean s u c c e s s = f a l s e ;
S t r i n g numerator = e x t r a c t B l o c k ( ) ;
i f ( numerator == n u l l
{

| | numerator . isEmpty ( )

)

return ;

}

try
{

LaTeXParser
S t r i n g p r e f i x = l p . r e a d B l o c k ( ) ;

l p = new LaTeXParser ( numerator

) ;

boolean c o r r e c t P r e f i x = p r e f i x . e q u a l s ( "d" )

| | p r e f i x . e q u a l s ( " \\ p a r t i a l " ) ;

i f ( c o r r e c t P r e f i x )
{

S t r i n g f u n c ;
S t r i n g o r d e r ;

S t r i n g n ex t = l p . r e a d B l o c k ( ) ;
i f (
{

! ne x t . e q u a l s ( "^" )

)

f i r s t O r d e r = true ;
o r d e r = " 1 " ;
f u n c = n e xt ;

}
e l s e
{

f i r s t O r d e r = f a l s e ;
o r d e r = l p . r e a d B l o c k ( ) ;
f u n c = l p . r e a d B l o c k ( ) ;

47

}

i f (
{

}

l p . endOfInput ( )

)

d i f f F u n c = f u n c ;
d i f f T y p e = p r e f i x ;
d i f f O r d e r = o r d e r ;
s u c c e s s = true ;

}

}
catch (
{

I n c o r r e c t S y n t a x E x c e p t i o n ex )

// This

i s not d e r i v a t i v e . J u s t r e t u r n .

}

d e r i v a t i v e R e j e c t = ! s u c c e s s ;

}

private void parseDenominator ( ) throws I n c o r r e c t S y n t a x E x c e p t i o n
{

p a r s e : {

d e r i v a t i v e R e j e c t = true ;

S t r i n g denominator = e x t r a c t B l o c k ( ) ;
i f ( denominator == n u l l
{

| | denominator . isEmpty ( )

)

break p a r s e ;

}

LaTeXParser

l p = new LaTeXParser ( denominator

) ;

S t r i n g f i r s t B l o c k = l p . r e a d B l o c k ( ) ;
i f (
)
{

f i r s t B l o c k . e q u a l s ( d i f f T y p e )

!

break p a r s e ;

f i r s t O r d e r

)

}

i f (
{

S t r i n g var = l p . r e a d B l o c k ( ) ;
i f (
{

l p . endOfInput ( )

!

)

break p a r s e ;

}

d i f f V a r s = new A r r a y L i s t < >(1);
d i f f O r d e r s = new A r r a y L i s t < >(1);
d i f f V a r s . add ( var
d i f f O r d e r s . add ( " 1 " ) ;

) ;

}
e l s e
{

f i n a l
f i n a l
f i n a l
f i n a l
f i n a l

i n t readVar = 1 ;
i n t readOrder = 2 ;
i n t s t a r t R e a d = 3 ;
i n t determOrder = 4 ;
i n t compliteRead = 5 ;

S t r i n g var = n u l l ;

48

S t r i n g o r d e r = n u l l ;

A r r a y L i s t <S t r i n g > v a r s = new A r r a y L i s t < >();
A r r a y L i s t <S t r i n g > o r d e r s = new A r r a y L i s t < >();

boolean c o r r e c t R e a d i n g = true ;

l p . s e t C u r r e n t P o s ( 0 ) ;
i n t n e x t A c t i o n = s t a r t R e a d ;

r e a d i n g :
while ( true )
{

l p . endOfInput ( )

i f (
&& n e x t A c t i o n != compliteRead
&& n e x t A c t i o n != determOrder
) {

c o r r e c t R e a d i n g = f a l s e ;
break r e a d i n g ;

}

switch ( n e x t A c t i o n )
{

case compliteRead :

v a r s . add ( var
o r d e r s . add ( o r d e r

) ;

) ;

l p . endOfInput ( )

)

c o r r e c t R e a d i n g = true ;
break r e a d i n g ;

i f (
{

}

n e x t A c t i o n = s t a r t R e a d ;
break ;

case s t a r t R e a d :

S t r i n g d i f f = l p . r e a d B l o c k ( ) ;
i f (
{

! d i f f . e q u a l s ( d i f f T y p e )

)

break p a r s e ;

}
n e x t A c t i o n = readVar ;
break ;

case readVar :

var = l p . r e a d B l o c k ( ) ;
n e x t A c t i o n = determOrder ;
break ;

case determOrder :

l p . endOfInput ( )

)

o r d e r = " 1 " ;
n e x t A c t i o n = compliteRead ;
break ;

i f (
{

}

i n t c u r r P o s = l p . g e t C u r r e n t P o s ( ) ;
i f (
{

l p . r e a d B l o c k ( ) . e q u a l s ( "^" )

)

49

n e x t A c t i o n = readOrder ;

}
e l s e
{

l p . s e t C u r r e n t P o s ( c u r r P o s
o r d e r = " 1 " ;
n e x t A c t i o n = compliteRead ;

) ;

}

break ;

case readOrder :

o r d e r = l p . r e a d B l o c k ( ) ;
n e x t A c t i o n = compliteRead ;
break ;

}

} // r e a d i n g :

! c o r r e c t R e a d i n g | | v a r s . isEmpty ( )

)

break p a r s e ;

i f (
{

}

t h i s . d i f f V a r s = v a r s ;
t h i s . d i f f O r d e r s = o r d e r s ;

}

d e r i v a t i v e R e j e c t = f a l s e ;
} // p a r s e :

}

private S t r i n g c o n v e r t D e r i v a t i v e ( ) throws I n c o r r e c t S y n t a x E x c e p t i o n
{

S t r i n g B u i l d e r
r e s u l t . append ( c o n v e r t ( d i f f F u n c )

r e s u l t = new S t r i n g B u i l d e r ( "D[ " ) ;

) ;

i n t l e n = d i f f V a r s . s i z e ( ) ;
f o r (
)
{

i <l e n ; ++i

i n t i =0;

r e s u l t . append ( " , " + " { " ) ;
r e s u l t . append ( c o n v e r t ( d i f f V a r s . g e t ( i ) )
r e s u l t . append ( " , " ) ;
r e s u l t . append ( c o n v e r t ( d i f f O r d e r s . g e t ( i ) )
r e s u l t . append ( " } " ) ;

) ;

) ;

}

r e s u l t . append ( " ] " ) ;
return r e s u l t . t o S t r i n g ( ) ;

}

private boolean i n B r a c k e t ( S t r i n g t e x t )
{

a s s e r t
S t r i n g t x t = t e x t . t r i m ( ) ;

!= n u l l ;

t e x t

i n t l e n = t x t . l e n g t h ( ) ;
i f (
{

l e n < 2 )

return f a l s e ;

}

50

char f i r s t = t x t . charAt ( 0 ) ;
char l a s t = t x t . charAt (

l e n − 1 ) ;

return p a r s e r . i s L e f t B r a c k e t ( f i r s t )

&& p a r s e r . o p p o s i t e B r a c k e t ( f i r s t ) == l a s t ;

}

public s t a t i c void main ( S t r i n g [ ] a r g s
{

)

try
{

new D e r i v a t i v e S p e c i a l C a s e ( ) . a p p l y ( " $ \\ f r a c { d x

}{ dy} $ " ) ;

I n c o r r e c t S y n t a x E x c e p t i o n ex )

}
catch (
{
}

}

private S t r i n g e x t r a c t B l o c k ( )

throws I n c o r r e c t S y n t a x E x c e p t i o n

{

}

S t r i n g r e s u l t = n u l l ;
S t r i n g denominator = p a r s e r . r e a d B l o c k ( ) . t r i m ( ) ;

i n B r a c k e t ( denominator )

)

i f (
{

denominator = denominator

.
.
.

t r i m ( )
s u b s t r i n g ( 1 , denominator . l e n g t h ( ) − 1 )
t r i m ( ) ;

! denominator . isEmpty ( )

)

r e s u l t = denominator ;

i f (
{

}

}

return r e s u l t ;

private S t r i n g c o n v e r t ( S t r i n g l a t e x ) throws I n c o r r e c t S y n t a x E x c e p t i o n
{

return c o n v e r t e r . c o n v e r t (

’ $ ’+l a t e x+ ’ $ ’

) ;

}
private void f i r s t O r d e r C a s e ( )
{

}

private void h i g h e r O r d e r C a s e ( )
{

}

}

SubScriptSpecialCase.java

package v3 ;

51

/**
*
* @author Dmitriy Krylov
*/
public
c l a s s
extends
{

S u b S c r i p t S p e c i a l C a s e
S p e c i a l C a s e

private i n t s t a r t I n d e x = −1;
= −1;
private i n t endIndex

private LaTeXParser p a r s e r = n u l l ;

private f i n a l C o n v e r t e r c o n v e r t e r ;
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public S u b S c r i p t S p e c i a l C a s e ( )
{

c o n v e r t e r = new S p e c i a l C a s e C o n v e r t e r (

LaTeXToWolfMathConverter . g e t I n s t a n c e ( ) ) ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
/* Этот спецальный случай должен применяться ПОСЛЕ
* специальных случаев , обрабатывающие выражения ,
* которые могут содержать нижий предел , таких как
* интегралы и суммы .
*/
/* Метод ищет во входной строке случай применения
* нижнего индекса , извлекает элемент , обладающий
* нижним индексом и сам нижний индекс , конвертирует
* их и составляет соответствующее выражение на языке
* Mathematica .
*/
@Override
public

S p e c i a l C a s e R e p o r t a p p l y ( S t r i n g i n p u t
throws I n c o r r e c t S y n t a x E x c e p t i o n

)

{

}

a s s e r t

i n p u t != n u l l ;

i n t e n t r y I n d e x = i n p u t . l a s t I n d e x O f (
’_ ’
i f ( e n t r y I n d e x == −1 ) { return n u l l ; }

) ;

p a r s e r = new LaTeXParser (

input , e n t r y I n d e x ) ;

S t r i n g e l e m e n t
S t r i n g s u b s c r i p t = e x t r a c t S u b s c r i p t ( ) ;

= e x t r a c t S u b s c r i p t E l e m e n t ( ) ;

S t r i n g c o n v e r t e d = " S u b s c r i p t "

+ " [ "
+
+
+
+ " ] "
;

c o n v e r t ( e l e m e n t
" , "
c o n v e r t (

s u b s c r i p t

)

)

return new S p e c i a l C a s e R e p o r t (

s t a r t I n d e x , endIndex , c o n v e r t e d ) ;

52

//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private S t r i n g e x t r a c t S u b s c r i p t E l e m e n t ( )

throws I n c o r r e c t S y n t a x E x c e p t i o n

{

i n t o l d P o s = p a r s e r . g e t C u r r e n t P o s ( ) ;
S t r i n g r e s u l t = p a r s e r . r e a d P r e v i o u s B l o c k ( ) ;
s t a r t I n d e x = p a r s e r . g e t C u r r e n t P o s ( ) ;
p a r s e r . s e t C u r r e n t P o s ( o l d P o s + 1 ) ;
return r e s u l t ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private S t r i n g e x t r a c t S u b s c r i p t ( )

throws I n c o r r e c t S y n t a x E x c e p t i o n

{

S t r i n g r e s u l t = p a r s e r . r e a d B l o c k ( ) ;
endIndex = p a r s e r . g e t C u r r e n t P o s ( ) ;
return r e s u l t ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private S t r i n g c o n v e r t ( S t r i n g l a t e x ) throws I n c o r r e c t S y n t a x E x c e p t i o n
{

return c o n v e r t e r . c o n v e r t (

’ $ ’+l a t e x+ ’ $ ’

) ;

}

}

IntegralSpecialCase.java

package v3 ;

import v3 . LaTeXParser . L i m i t s ;
/**
*
* @author Dmitriy Krylov
*/
public
c l a s s
extends
{

I n t e g r a l S p e c i a l C a s e
S p e c i a l C a s e

private f i n a l S t r i n g intCmd = " \\ i n t " ;
private f i n a l S t r i n g h e a d e r = " I n t e g r a t e " ;
private f i n a l C o n v e r t e r c o n v e r t e r ;
private LaTeXParser p a r s e r ;
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public I n t e g r a l S p e c i a l C a s e ( )
{

c o n v e r t e r = new S p e c i a l C a s e C o n v e r t e r (

LaTeXToWolfMathConverter . g e t I n s t a n c e ( )

) ;

}

53

//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
/* a p p l y
* Метод принимает в качестве входного параметра
* строку содержащую описание формулы на языке LaTeX ,
* ищет в отоэ строке описание интеграла и конвертирует
* е г о в формат Wolfram Mathematica .
*
* Если интеграл удалось найти
* Возвращает обьект содержащий индексы начала и конца
* найденного интегралла и результат конвертации .
*
* Иначе возвращает n u l l
*
* Генерирует исключение если интеграл удалось найти но
* не удалось конвертировать .
*/
@Override
public

S p e c i a l C a s e R e p o r t a p p l y ( S t r i n g i n p u t
throws I n c o r r e c t S y n t a x E x c e p t i o n

)

{

a s s e r t

i n p u t != n u l l ;

//Найдём первое вхождение команды иинтеграла языка LaTeX .

//Будем считать найденное вхождение началом интеграла .
//Если строка не содержит этой команды будем считать что
// она не содержит описание интеграла .
//В этом случае возвращаем n u l l

// Требуется определить есть ли у рассматримваемого интеграла
//нижний и верхний предел .
//Найдём следующий за командой интеграла непробельный символ
//Если он является одним из символов ’_ ’ или ’^ ’
// обрабатываем интеграл как определённый .
//Иначе обрабатываем интеграл как неопределённый .

//Если обнаружено что у интеграла есть только верхний
//или только нижний предел , или если у интеграла
// два или б о л е е нижних или верхних предела синтаксис
// интеграла считается некорректным и метод кидает
//соответствующее исключение .

i n t e n t r y I n d e x = i n p u t . l a s t I n d e x O f ( intCmd ) ;
i f ( e n t r y I n d e x == −1 )
{

return n u l l ;

}

p a r s e r = new LaTeXParser (

input , e n t r y I n d e x ) ;

p a r s e r . readLaTeXCommand ( ) ;
// −−−

i n t s t a r t P o s = e n t r y I n d e x ;

S t r i n g c o n v e r s i o n R e s u l t ;
p a r s e r . s k i p S p a c e s ( ) ;
switch ( p a r s e r . c u r r e n t C h a r ( )

)

54

{

}

case ’_ ’ :
case ’ ^ ’ :

c o n v e r s i o n R e s u l t = t r e a t A s D e f i n i t e I n t e g r a l ( ) ;
break ;

d e f a u l t :

c o n v e r s i o n R e s u l t = t r e a t A s I n d e f i n i t e I n t e g r a l ( ) ;
break ;

i n t endPos = p a r s e r . g e t C u r r e n t P o s ( ) ;

return new S p e c i a l C a s e R e p o r t (

s t a r t P o s , endPos ,

c o n v e r s i o n R e s u l t

) ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private S t r i n g t r e a t A s D e f i n i t e I n t e g r a l ( ) throws I n c o r r e c t S y n t a x E x c e p t i o n
{

l i m i t s

L i m i t s
S t r i n g l o w e r L i m i t
S t r i n g u p p e r L i m i t

= p a r s e r . readLowerAndUpperLimits ( ) ;
= l i m i t s . l o w e r ;
= l i m i t s . upper ;

S t r i n g i n t e g r a n d
S t r i n g d i f f e r e n t i a l = r e a d D i f f e r e n t i a l ( ) ;

= r e a d I n t e g r a n d ( ) ;

return h e a d e r

+ " [ "
+
+ " , "
+
+
+
+
+
+
+
+ " ] " ;

c o n v e r t (

i n t e g r a n d )

" { "

" } "

)

c o n v e r t ( d i f f e r e n t i a l
" , "
c o n v e r t (
" , "
c o n v e r t ( u p p e r L i m i t

l o w e r L i m i t

)

)

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private S t r i n g t r e a t A s I n d e f i n i t e I n t e g r a l ( ) throws I n c o r r e c t S y n t a x E x c e p t i o n
{

S t r i n g i n t e g r a n d
S t r i n g d i f f e r e n t i a l = r e a d D i f f e r e n t i a l ( ) ;

= r e a d I n t e g r a n d ( ) ;

return h e a d e r

+ " [ "
+ c o n v e r t (
+ " , "
+ c o n v e r t ( d i f f e r e n t i a l
+ " ] " ;

i n t e g r a n d )

)

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private S t r i n g r e a d I n t e g r a n d ( ) throws I n c o r r e c t S y n t a x E x c e p t i o n
{

55

p a r s e r . s k i p S p a c e s ( ) ;

i n t s t a r t I n d e x = p a r s e r . g e t C u r r e n t P o s ( ) ;

boolean l a s t B l o c k I s M a t h O p e r a t o r = f a l s e ;

f o r ( ; ; )
{

S t r i n g r e a d B l o c k = p a r s e r . r e a d B l o c k ( ) ;

r e a d B l o c k . e q u a l s ( "d" )

i f (
&& l a s t B l o c k I s M a t h O p e r a t o r == f a l s e
) {

break ;

}

l a s t B l o c k I s M a t h O p e r a t o r = p a r s e r . isMathOperator (

r e a d B l o c k ) ;

}
i n t endIndex = p a r s e r . g e t C u r r e n t P o s ( ) − 1 ;

return p a r s e r . g e t P a r t (

s t a r t I n d e x , endIndex ) ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private S t r i n g r e a d D i f f e r e n t i a l ( ) throws I n c o r r e c t S y n t a x E x c e p t i o n
{

p a r s e r . s k i p S p a c e s ( ) ;
return p a r s e r . r e a d B l o c k ( ) ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private S t r i n g c o n v e r t ( S t r i n g t e x t
{

) throws I n c o r r e c t S y n t a x E x c e p t i o n

return c o n v e r t e r . c o n v e r t (

’ $ ’+t e x t+ ’ $ ’

) ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public s t a t i c void main ( S t r i n g [ ] a r g s ) throws I n c o r r e c t S y n t a x E x c e p t i o n
{

new I n t e g r a l S p e c i a l C a s e ( ) . a p p l y ( " $a+b+s +\\int_ {y}^{x} a+d+s+x dx$ " ) ;

}

}

SumSpecialCase.java

package v3 ;

import v3 . LaTeXParser . L i m i t s ;
/**
*
* @author Dmitriy Krylov
*/
public
c l a s s

SumSpecialCase

56

extends
{

S p e c i a l C a s e

private f i n a l S t r i n g sumCmd = " \\sum" ;

private S t r i n g c o n v e r t = n u l l ;
private S t r i n g sumBody = n u l l ;
private S t r i n g l o w e r L i m i t = n u l l ;
private S t r i n g u p p e r L i m i t = n u l l ;

private LaTeXParser p a r s e r ;
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

@Override
public

S p e c i a l C a s e R e p o r t a p p l y ( S t r i n g i n p u t )
throws I n c o r r e c t S y n t a x E x c e p t i o n

{

i f (
{

}

i n p u t == n u l l

)

throw new RuntimeException ( " argument

i s n u l l " ) ;

i n t i n t E n t r y I n d e x = i n p u t . l a s t I n d e x O f ( sumCmd ) ;
i f (
{

i n t E n t r y I n d e x == −1 )

return n u l l ;

}

p a r s e r = new LaTeXParser (

input ,

i n t E n t r y I n d e x ) ;

i n t s t a r t P o s = i n t E n t r y I n d e x ;

readSumLimits ( ) ;
readSumBody ( ) ;
convertSum ( ) ;

i n t endPos = p a r s e r . g e t C u r r e n t P o s ( ) ;

return new S p e c i a l C a s e R e p o r t (

s t a r t P o s , endPos , c o n v e r t

) ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private void readSumLimits ( ) throws I n c o r r e c t S y n t a x E x c e p t i o n
{

L i m i t s

l i m i t s = p a r s e r . readLowerAndUpperLimits ( ) ;

l o w e r L i m i t = l i m i t s . l o w e r ;
u p p e r L i m i t = l i m i t s . upper ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private void readSumBody ( ) throws I n c o r r e c t S y n t a x E x c e p t i o n
{

sumBody = p a r s e r . r e a d B l o c k ( ) ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private void convertSum ( ) throws I n c o r r e c t S y n t a x E x c e p t i o n

57

{

i f (

l o w e r L i m i t == n u l l
| | u p p e r L i m i t == n u l l
| |
== n u l l

sumBody

) {

}

throw new I n c o r r e c t S y n t a x E x c e p t i o n ( ) ;

S t r i n g cmdHeader = "Sum" ;

S p e c i a l C a s e C o n v e r t e r conv =

new S p e c i a l C a s e C o n v e r t e r (

LaTeXToWolfMathConverter . g e t I n s t a n c e ( )

) ;

S t r i n g cSumBody
S t r i n g cLowerLimit = conv . c o n v e r t ( " $$ "+l o w e r L i m i t+" $$ " ) ;
S t r i n g cUpperLimit = conv . c o n v e r t ( " $$ "+u p p e r L i m i t+" $$ " ) ;

= conv . c o n v e r t ( " $$ "+sumBody+" $$ " ) ;

c o n v e r t = cmdHeader

+ " [ "
+
+ " , "
+
+
+
+
+
+ " ] " ;

cSumBody

" { "

" } "

cLowerLimit
" , "
cUpperLimit

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public s t a t i c void main ( S t r i n g [ ] a r g s
{}

)

}

LaTeXParser.java

package v3 ;
/**
*
* @author Dmitriy Krylov
*/
public c l a s s LaTeXParser
{

i n t l e n g t h ;

private f i n a l
private f i n a l S t r i n g i n p u t ;
private i n t c u r r e n t P o s = −1;
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public LaTeXParser ( )
{
t h i s ( null , −1 ) ;

}

public LaTeXParser ( S t r i n g i n p u t

)

58

{

}

t h i s (

input , 0 ) ;

public LaTeXParser ( S t r i n g input ,
{

t h i s . i n p u t = i n p u t ;
t h i s . c u r r e n t P o s = c u r r e n t P o s ;
l e n g t h = i n p u t . l e n g t h ( ) ;

i n t c u r r e n t P o s

)

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public S t r i n g g e t P a r t (
{

i n t s t a r t I n d e x ,

i n t endIndex )

return i n p u t . s u b s t r i n g (

s t a r t I n d e x , endIndex ) ;

}

public char getChar (
{

i n t pos

)

return i n p u t . charAt ( pos

) ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public L i m i t s
{

readLowerAndUpperLimits ( ) throws I n c o r r e c t S y n t a x E x c e p t i o n

S t r i n g l o w e r L i m i t ;
S t r i n g u p p e r L i m i t ;

switch ( c u r r e n t C h a r ( )
{

)

case ’_ ’ :

l o w e r L i m i t = readLowerLimit ( ) ;
u p p e r L i m i t = readUpperLimit ( ) ;
break ;

case ’ ^ ’ :

u p p e r L i m i t = readUpperLimit ( ) ;
l o w e r L i m i t = readLowerLimit ( ) ;
break ;

d e f a u l t :

S t r i n g e r r o r = " e x p e c t upper o r
throw new I n c o r r e c t S y n t a x E x c e p t i o n ( e r r o r

l o w e r

l i m i t " ;

) ;

}

return new L i m i t s (

l o w e r L i m i t , u p p e r L i m i t

) ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public S t r i n g readLowerLimit ( ) throws I n c o r r e c t S y n t a x E x c e p t i o n
{

s k i p S p a c e s ( ) ;
i f ( c u r r e n t C h a r ( )
{

!= ’_ ’

)

S t r i n g e r r o r M e s s a g e = " e x p e c t
throw new I n c o r r e c t S y n t a x E x c e p t i o n ( e r r o r M e s s a g e

l i m i t " ;

l o w e r

) ;

}

59

nextNonSpace ( ) ;
return r e a d B l o c k ( ) ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public S t r i n g readUpperLimit ( ) throws I n c o r r e c t S y n t a x E x c e p t i o n
{

s k i p S p a c e s ( ) ;
i f ( c u r r e n t C h a r ( )
{

!= ’ ^ ’

)

S t r i n g e r r o r M e s s a g e = " e x p e c t upper
throw new I n c o r r e c t S y n t a x E x c e p t i o n ( e r r o r M e s s a g e

l i m i t " ;

) ;

}

nextNonSpace ( ) ;
return r e a d B l o c k ( ) ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public S t r i n g r e a d B l o c k ( ) throws I n c o r r e c t S y n t a x E x c e p t i o n
{

s k i p S p a c e s ( ) ;
char c = c u r r e n t C h a r ( ) ;

i f ( c == ’ \\ ’
{

)

return readLaTeXCommand ( ) ;

}

i f (
{

}

i s L e f t B r a c k e t ( c )

)

return r e a d B r e a c k e t s B l o c k ( c ) ;

return readChar ( ) ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public S t r i n g r e a d P r e v i o u s B l o c k ( ) throws I n c o r r e c t S y n t a x E x c e p t i o n
{

i n t endPos = lookupPreviousNonSpacePos ( ) + 1 ;
i n t s t a r t P o s = −1;
char c = getChar ( endPos − 1 ) ;
i f (
{

i s R i g h t B r a c k e t ( c )
s t a r t P o s = l o o k u p L e f t B r a c k e t P o s ( endPos − 1 ) ;

)

}
e l s e
i f (
{

)

i s L a t i n L e t t e r ( c )
i n t cmdPos = lookupBeginLaTeXCommand ( endPos − 1 ) ;
i f ( cmdPos != −1 )
{

s t a r t P o s = cmdPos ;

}
e l s e

60

{

}

s t a r t P o s = endPos − 1 ;

s t a r t P o s = endPos − 1 ;

}
e l s e
{

}

s e t C u r r e n t P o s (
return g e t P a r t (

s t a r t P o s

) ;

s t a r t P o s , endPos

) ;

}

//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public S t r i n g readLaTeXCommand ( ) throws I n c o r r e c t S y n t a x E x c e p t i o n
{

s k i p S p a c e s ( ) ;

i f ( c u r r e n t C h a r ( )
{

!= ’ \\ ’

)

S t r i n g e r r o r M e s s a g e = " e x p e c t LaTeX command" ;
throw new I n c o r r e c t S y n t a x E x c e p t i o n ( e r r o r M e s s a g e

) ;

}

nextChar ( ) ;

i f ( c u r r e n t C h a r ( ) == ’
{

’

)

return " \\ " ;

}

i f (
{

}

i s L a t i n L e t t e r ( c u r r e n t C h a r ( ) )
i n t startCommand = g e t C u r r e n t P o s ( ) − 1 ;

)

do
{

nextChar ( ) ;

}
while ( C h a r a c t e r . i s L e t t e r ( c u r r e n t C h a r ( ) )

) ;

return i n p u t . s u b s t r i n g ( startCommand , g e t C u r r e n t P o s ( )

) ;

throw new I n c o r r e c t S y n t a x E x c e p t i o n ( " e x p e c t laTeX command" ) ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public void s k i p S p a c e s ( ) throws I n c o r r e c t S y n t a x E x c e p t i o n
{

while (
{

i s S p a c e ( c u r r e n t C h a r ( ) )

)

nextChar ( ) ;

}

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

61

public char c u r r e n t C h a r ( ) throws I n c o r r e c t S y n t a x E x c e p t i o n
{

i f ( c u r r e n t P o s >= i n p u t . l e n g t h ( )
{

)

S t r i n g e r r o r M e s s a g e = " end o f
throw new I n c o r r e c t S y n t a x E x c e p t i o n ( e r r o r M e s s a g e

i n p u t " ;

) ;

}

return i n p u t . charAt ( c u r r e n t P o s

) ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public void s e t C u r r e n t P o s (
{

c u r r e n t P o s = newPos ;

i n t newPos )

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public i n t g e t C u r r e n t P o s ( )
{

return c u r r e n t P o s ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public char nextNonSpace ( ) throws I n c o r r e c t S y n t a x E x c e p t i o n
{

! i s S p a c e ( c u r r e n t C h a r ( ) )

)

nextChar ( ) ;

i f (
{

}

s k i p S p a c e s ( ) ;
return c u r r e n t C h a r ( ) ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public

i n t lookupPreviousNonSpacePos (
throws I n c o r r e c t S y n t a x E x c e p t i o n

)

{

}

i n t r e s u l t = −1;
boolean nonSpaceFound = f a l s e ;

i n t pos = g e t C u r r e n t P o s ( ) − 1
; pos >= 0 && ! nonSpaceFound
; pos−−

f o r (

) {

char c = i n p u t . charAt ( pos
i f ( C h a r a c t e r . i s W h i t e s p a c e ( c ) == f a l s e )
{

) ;

r e s u l t = pos ;
nonSpaceFound = true ;

}

}

return r e s u l t ;

62

//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public boolean i s L a t i n L e t t e r ( char ch )
{

char l c h = C h a r a c t e r . toLowerCase ( ch ) ;
return " q w e r t y u i o p l k j h g f d s a z x c v b n m " . indexOf (

l c h ) != −1;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public boolean i s L e f t B r a c k e t ( char c )
{

switch ( c )
{

case ’ ( ’ :
case ’ [ ’ :
case ’ { ’ :

return true ;

d e f a u l t :

return f a l s e ;

}

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public boolean i s R i g h t B r a c k e t ( char c )
{

switch ( c )
{

case ’ ) ’ :
case ’ ] ’ :
case ’ } ’ :

return true ;

d e f a u l t :

return f a l s e ;

}

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public char o p p o s i t e B r a c k e t ( char c )
{

switch ( c )
{

case ’ ( ’ : return ’ ) ’ ;
case ’ ) ’ : return ’ ( ’ ;
case ’ [ ’ : return ’ ] ’ ;
case ’ ] ’ : return ’ [ ’ ;
case ’ { ’ : return ’ } ’ ;
case ’ } ’ : return ’ { ’ ;
d e f a u l t : throw new I l l e g a l A r g u m e n t E x c e p t i o n ( ) ;

}

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public boolean i s S p a c e ( char c )
{

return C h a r a c t e r . i s W h i t e s p a c e ( c ) ;

63

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public i n t l o o k u p L e f t B r a c k e t P o s (
{

i n t r e s u l t = −1;

i n t r i g h t B r a c k e t P o s

)

char r i g h t B r a c k e t = i n p u t . charAt (
char l e f t B r a c k e t = o p p o s i t e B r a c k e t (
i n t pos = r i g h t B r a c k e t P o s − 1 ;
boolean found = f a l s e ;

r i g h t B r a c k e t P o s
r i g h t B r a c k e t

) ;
) ;

while ( pos >= 0 && ! found )
{

char c u r r e n t C h a r = i n p u t . charAt ( pos

) ;

i f ( c u r r e n t C h a r == l e f t B r a c k e t
{

)

r e s u l t = pos ;
found = true ;

}
e l s e
i f (
{

i s R i g h t B r a c k e t ( c u r r e n t C h a r )

)

pos = l o o k u p L e f t B r a c k e t P o s ( pos

) ;

}
pos−−;

}

return r e s u l t ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public boolean isMathOperator ( S t r i n g b l o c k )
{

i f ( b l o c k . l e n g t h ( )
{

return f a l s e ;

!= 1 )

}

switch ( b l o c k . charAt ( 0 )
{

)

case ’+ ’ :
case ’− ’ :
case ’* ’ :
case ’ / ’ :
case ’ ^ ’ :

return true ;

d e f a u l t :

return f a l s e ;

}

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private S t r i n g r e a d B r e a c k e t s B l o c k ( char l e f t B r a c k e t

)

throws I n c o r r e c t S y n t a x E x c e p t i o n

64

{

a s s e r t
) ;
char r i g h t B r a c k e t = o p p o s i t e B r a c k e t (

i s L e f t B r a c k e t (

l e f t B r a c k e t

l e f t B r a c k e t

) ;

i n t s t a r t I n d e x = g e t C u r r e n t P o s ( ) ;

do
{

nextChar ( ) ;
i f (
{

i s L e f t B r a c k e t ( c u r r e n t C h a r ( ) )

)

r e a d B r e a c k e t s B l o c k ( c u r r e n t C h a r ( )

) ;

}

}
while ( c u r r e n t C h a r ( )

!= r i g h t B r a c k e t

) ;

nextChar ( ) ;
i n t endIndex = g e t C u r r e n t P o s ( ) ;

return i n p u t . s u b s t r i n g (

s t a r t I n d e x , endIndex ) ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private void nextChar ( )
{

c u r r e n t P o s ++;

}

private void p r e v i o u s C h a r ( )
{

c u r r e n t P o s −−;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private S t r i n g readChar ( ) throws I n c o r r e c t S y n t a x E x c e p t i o n
{

char r e t u r n e d C h a r = c u r r e n t C h a r ( ) ;
nextChar ( ) ;
return S t r i n g . v a l u e O f (

r e t u r n e d C h a r

) ;

}

private i n t lookupBeginLaTeXCommand (
{

i n t endIndex )

i n t pos = endIndex + 1 ;
i n t r e s u l t = −1;
while ( −−pos >= 0 && r e s u l t == −1 )
{

char ch = i n p u t . charAt ( pos
i f (
{

i s L a t i n L e t t e r ( ch ) == f a l s e )

) ;

i f ( ch == ’ \\ ’
{

)

r e s u l t = pos ;

}

}

}

return r e s u l t ;

65

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public boolean endOfInput ( )
{

return ! ( c u r r e n t P o s < l e n g t h ) ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public s t a t i c c l a s s L i m i t s
{

public f i n a l S t r i n g upper ;
public f i n a l S t r i n g l o w e r ;

public L i m i t s ( S t r i n g lower , S t r i n g upper
{

)

t h i s . l o w e r = l o w e r ;
t h i s . upper = upper ;

}

}

}

LaTeXInputDialog.java

package v3 ;

import j a v a . awt . BorderLayout ;
import j a v a . awt . C o n t a i n e r ;
import j a v a . awt . Font ;
import j a v a . awt . e v e n t . ActionEvent ;
import j a v a . awt . e v e n t . A c t i o n L i s t e n e r ;
import j a v a . u t i l . r e g e x . Matcher ;
import j a v a . u t i l . r e g e x . P a t t e r n ;
import j a v a x . swing . Box ;
import j a v a x . swing . BoxLayout ;
import j a v a x . swing . JButton ;
import j a v a x . swing . J D i a l o g ;
import j a v a x . swing . JEditorPane ;
import j a v a x . swing . JFrame ;
import j a v a x . swing . JOptionPane ;
import j a v a x . swing . JPanel ;
import j a v a x . swing . J S c r o l l P a n e ;
import j a v a x . swing . t e x t . JTextComponent ;
/**
*
* @author Dmitriy Krylov
*/
public
c l a s s
extends
{

LaTeXInputDialog
JFrame

private f i n a l S t r i n g t x t I n s e r t = " Вставить " ;
private f i n a l S t r i n g t x t C a n c e l = "Отменить" ;
private f i n a l S p e c i a l C a s e C o n v e r t e r c o n v e r t e r ;

private f i n a l JTextComponent

t a r g e t ;

66

private f i n a l JEditorPane e d i t o r P a n e ;

private S t r i n g B u i l d e r
t e x t = n u l l ;
= −1;
private i n t c u r r P o s
private i n t s t a r t M a t h = −1;
private i n t f i n a l M a t h = −1;
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public LaTeXInputDialog ( JTextComponent
{

t a r g e t

)

t h i s . s e t S i z e ( 6 0 0 , 400 ) ;
t h i s . s e t D e f a u l t C l o s e O p e r a t i o n ( J D i a l o g .DO_NOTHING_ON_CLOSE ) ;

t h i s . t a r g e t = t a r g e t ;

e d i t o r P a n e = new JEditorPane ( ) ;
e d i t o r P a n e . s e t F o n t ( new Font ( null , Font . PLAIN , 1 8 )

) ;

C o n t a i n e r contentPane = t h i s . getContentPane ( ) ;
contentPane . s e t L a y o u t ( new BorderLayout ( )

) ;

J S c r o l l P a n e s c r o l l P a n e = new J S c r o l l P a n e ( ) ;
s c r o l l P a n e . s e t V i e w p o r t V i e w ( e d i t o r P a n e

) ;

JPanel buttonPane = new JPanel ( ) ;
buttonPane . s e t L a y o u t ( new BoxLayout ( buttonPane , BoxLayout . X_AXIS)

) ;

JButton b I n s e r t = new JButton (
JButton bCancel = new JButton (

t x t I n s e r t
t x t C a n c e l

) ;
) ;

buttonPane . add ( Box . c r e a t e H o r i z o n t a l G l u e ( )
buttonPane . add ( b I n s e r t
buttonPane . add ( Box . c r e a t e H o r i z o n t a l S t r u t ( 5 )
buttonPane . add ( bCancel
buttonPane . add ( Box . c r e a t e H o r i z o n t a l G l u e ( )

) ;

) ;

) ;

) ;

) ;

contentPane . add (
s c r o l l P a n e , BorderLayout .CENTER ) ;
contentPane . add ( buttonPane , BorderLayout .SOUTH ) ;

b I n s e r t . a d d A c t i o n L i s t e n e r ( new A c t i o n L i s t e n e r ( ) {

@Override public void a c t i o n P e r f o r m e d ( ActionEvent e ) {

i n s e r t ( ) ;

}

} ) ;

bCancel . a d d A c t i o n L i s t e n e r ( new A c t i o n L i s t e n e r ( ) {

@Override public void a c t i o n P e r f o r m e d ( ActionEvent e ) {

c a n s e l ( ) ;

}

} ) ;

c o n v e r t e r = new S p e c i a l C a s e C o n v e r t e r (

LaTeXToWolfMathConverter . g e t I n s t a n c e ( )

) ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private void i n s e r t ( )
{

S t r i n g sText = e d i t o r P a n e . g e t T e x t ( ) ;

67

sText . isEmpty ( )

)

c l o s e ( ) ;
return ;

i f (
{

}

try
{

t e x t = new S t r i n g B u i l d e r (
c u r r P o s = 0 ;

sText

) ;

while ( readMath ( )
{

)

S t r i n g math = t e x t . s u b s t r i n g (
S t r i n g convertedMath = c o n v e r t e r . c o n v e r t ( math ) ;

startMath ,

f i n a l M a t h ) ;

t e x t . r e p l a c e (

startMath ,

f i n a l M a t h , convertedMath ) ;

}
// −−−−

S t r i n g B u i l d e r
t a r g e t T e x t . i n s e r t (

t a r g e t T e x t = new S t r i n g B u i l d e r (
t a r g e t . g e t C a r e t P o s i t i o n ( ) ,

t a r g e t . g e t T e x t ( )
t e x t

) ;

) ;

t a r g e t . s e t T e x t (
c l o s e ( ) ;

t a r g e t T e x t . t o S t r i n g ( )

) ;

}
catch (
{

I n c o r r e c t S y n t a x E x c e p t i o n ex )

JOptionPane . showMessageDialog ( t h i s , ex . g e t M e s s a g e ( )

) ;

}

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private void c a n s e l ( )
{

c l o s e ( ) ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private i n t f i n d S t a r t M a t h ( )
{

i n t r e s u l t = −1;

P a t t e r n p = P a t t e r n . c o m p i l e ( " ( \ \ $ \\ $ ) | ( \ \ $ ) | ( \ \ \ \ \ \ ( ) | ( \ \ \ \ \ \ [ ) " ) ;
Matcher m = p . matcher (

t e x t

) ;

i f ( c u r r P o s < t e x t . l e n g t h ( ) && m. f i n d ( c u r r P o s )
{

)

r e s u l t = m. s t a r t ( ) ;
c u r r P o s = m. end ( ) ;

}

return r e s u l t ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

68

private i n t f i n d F i n a l M a t h ( )
{

i n t r e s u l t = −1;

P a t t e r n p = P a t t e r n . c o m p i l e ( " ( \ \ $ \\ $ ) | ( \ \ $ ) | ( \ \ \ \ \ \ ) ) | ( \ \ \ \ \ \ ] ) " ) ;
Matcher m = p . matcher (

t e x t

) ;

i f ( c u r r P o s < t e x t . l e n g t h ( ) && m. f i n d ( c u r r P o s )
{

)

r e s u l t = m. end ( ) ;
c u r r P o s = m. end ( ) ;

}

return r e s u l t ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private boolean readMath ( )
{

s t a r t M a t h = f i n d S t a r t M a t h ( ) ;
f i n a l M a t h = f i n d F i n a l M a t h ( ) ;
return s t a r t M a t h != −1
&& f i n a l M a t h != −1;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private void c l o s e ( )
{

t h i s . s e t V i s i b l e (

f a l s e ) ;

}

}

DirFinder.java

package v3 ;

import j a v a . i o . F i l e ;
import j a v a . i o . F i l e F i l t e r ;
import j a v a . u t i l . L i n k e d L i s t ;
/**
*
* @author Dmitriy Krylov
*/
c l a s s D i r F i n d e r
{

public s t a t i c F i l e f i n d S u b D i r ( F i l e r o o t D i r , S t r i n g t a r g e t
{

)

a s s e r t
a s s e r t
a s s e r t

r o o t D i r != n u l l ;
t a r g e t
!= n u l l ;
r o o t D i r . i s D i r e c t o r y ( ) ;

L i n k e d L i s t <F i l e > queue = new L i n k e d L i s t < >();
D i r F i l t e r d f = new D i r F i l t e r ( ) ;

f o r ( ;

r o o t D i r != n u l l ;

r o o t D i r = queue . p o l l ( )

)

69

{

F i l e [ ]

l i s t F i l e s = r o o t D i r . l i s t F i l e s ( d f

) ;

f o r ( F i l e
{

t e s t i n g D i r

:

l i s t F i l e s

)

t e s t i n g D i r . getName ( ) . e q u a l s ( t a r g e t )

)

return t e s t i n g D i r ;

i f (
{

}

queue . add (

t e s t i n g D i r

) ;

}

}

return n u l l ;

}

s t a t i c c l a s s D i r F i l t e r implements F i l e F i l t e r {

@Override public boolean a c c e p t ( F i l e

f i l e ) {

return f i l e . i s D i r e c t o r y ( ) ;

}

} ;

}

MathConnection.java

package v3 ;

import com . wolfram . j l i n k . Expr ;
import com . wolfram . j l i n k . K e r n e l L i n k ;
import com . wolfram . j l i n k . MathLinkException ;
import com . wolfram . j l i n k . P a c k e t A r r i v e d E v e n t ;
import com . wolfram . j l i n k . P a c k e t L i s t e n e r ;
import com . wolfram . j l i n k . P a c k e t P r i n t e r ;
/**
*
* @author Dmitriy Krylov
*/
public
c l a s s
implements A u t o C l o s e a b l e , P a c k e t L i s t e n e r
{

MathConnection

private s t a t i c MathConnection a c t i v e C o n n e c t i o n = n u l l ;
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public s t a t i c MathConnection g e t I n s t a n c e ( ) throws MathConnectionException
{

i f ( a c t i v e C o n n e c t i o n == n u l l
{

)

Log . msg ( " c r e a t e new c o n n e c t i o n " ) ;
a c t i v e C o n n e c t i o n = new MathConnection ( ) ;

}
e l s e
{

}

Log . msg ( " r e t u r n e x i s t c o n n e c t i o n " ) ;

70

return a c t i v e C o n n e c t i o n ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private S t r i n g
private S t r i n g
private S t r i n g
private K e r n e l L i n k
private boolean

= n u l l ;
l o c a t i o n
= n u l l ;
e r r o r M s g
r e s u l t
= n u l l ;
k e r n e l L i n k = n u l l ;
w a i t E r r o r

= f a l s e ;

public S t r i n g g e t L o c a t i o n ( ) { return l o c a t i o n ; }
public S t r i n g g e t E r r o r ( )
{ return e r r o r M s g ; }
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public MathConnection ( ) throws MathConnectionException
{

Log . msg ( ) ;

MathKernelFinder
f i n d e r . f i n d ( ) ;

f i n d e r = new MathKernelFinder ( ) ;

l o c a t i o n
k e r n e l L i n k = f i n d e r . g e t K e r n e l ( ) ;

= f i n d e r . g e t L o c a t i o n ( ) ;

a d d L i s t e n e r s ( ) ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public S t r i n g se n dR eq ue st ( S t r i n g r e q u e s t
{

) throws MathConnectionException

r e q u e s t == n u l l

)

throw new I l l e g a l A r g u m e n t E x c e p t i o n ( " r e q u e s t must be non n u l l " ) ;

i f (
{

}

Log . msg (

r e q u e s t

) ;

r e s u l t = n u l l ;
e r r o r M s g = n u l l ;

r e s u l t = k e r n e l L i n k . evaluateToInputForm (

r e q u e s t , 0 ) ;

r e s u l t == n u l l

)

Throwable l a s t E r r o r = k e r n e l L i n k . g e t L a s t E r r o r ( ) ;

c l o s e ( ) ;
throw new MathConnectionException (

l a s t E r r o r

) ;

i f (
{

}

Log . msg (

r e q u e s t+" −> "+r e s u l t

) ;

r e s u l t . e q u a l s ( " $ F a i l e d " )

)

r e s u l t = n u l l ;

i f (
{

}

71

return r e s u l t ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

@Override
public void c l o s e ( )
{

Log . msg ( ) ;
i f ( k e r n e l L i n k != n u l l
{

)

k e r n e l L i n k . evaluateToInputForm ( " CloseFrontEnd [ ] " , 0 ) ;
k e r n e l L i n k . c l o s e ( ) ;
k e r n e l L i n k = n u l l ;

}
i f ( t h i s == a c t i v e C o n n e c t i o n )
{

Log . msg ( " t h i s
a c t i v e C o n n e c t i o n = n u l l ;

i s a c t i v e c o n n e c t i o n " ) ;

}

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

@Override
public
boolean p a c k e t A r r i v e d ( P a c k e t A r r i v e d E v e n t e ) throws MathLinkException
{

Expr e xp r = n u l l ;

try
{

ex pr = ( ( K e r n e l L i n k ) e . g e t S o u r c e ( ) ) . getExpr ( ) ;
S t r i n g incomingMessage = e xp r . t o S t r i n g ( ) ;

switch ( e . getPktType ( )
{

)

case K e r n e l L i n k .MESSAGEPKT:
{

w a i t E r r o r = true ;

}
break ;

case K e r n e l L i n k .TEXTPKT:
{

i f ( w a i t E r r o r
{

)

w a i t E r r o r = f a l s e ;
i f ( e r r o r M s g == n u l l
{

)

e r r o r M s g = incomingMessage ;

e r r o r M s g += " \n" + incomingMessage ;

}
e l s e
{

}

}

}
break ;

d e f a u l t :

72

break ;

}

}
catch ( MathLinkException ex )
{

Log . msg ( ex . g e t M e s s a g e ( )
throw ex ;

) ;

}
f i n a l l y
{

ex pr . d i s p o s e ( ) ;

}

return true ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private void a d d L i s t e n e r s ( )
{

k e r n e l L i n k . a d d P a c k e t L i s t e n e r ( t h i s ) ;
k e r n e l L i n k . a d d P a c k e t L i s t e n e r ( new P a c k e t P r i n t e r ( )

) ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public s t a t i c c l a s s MathConnectionException extends E x c e p t i o n
{

public MathConnectionException ( S t r i n g msg ) { super ( msg ) ; }
public MathConnectionException ( Throwable e ) { super ( e ) ;
}

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public s t a t i c void main ( S t r i n g [ ] a r g s )
{

try {
try ( MathConnection mc = new MathConnection ( )
{

)

mc . se n dR eq ue st ( " To E x pr e s s io n [ \ " \ \ \ \ s i n (2 ) +2 \ " ,TeXForm ] " ) ;
Thread . s l e e p ( 7 0 0 0 ) ;
mc . se n dR eq ue st ( " To E x pr e s s io n [ \ " \ \ \ \ s i n (2 ) +2 \ " ,TeXForm ] " ) ;

}
} catch ( MathConnectionException |
{

Log . msg ( e . g e t M e s s a g e ( )

) ;

I n t e r r u p t e d E x c e p t i o n e )

}

}

}

MathKernelFinder.java

package v3 ;

import ca . beq . u t i l . win32 . r e g i s t r y . R e g i s t r y K e y ;
import ca . beq . u t i l . win32 . r e g i s t r y . R e g i s t r y V a l u e ;
import ca . beq . u t i l . win32 . r e g i s t r y . RootKey ;
import com . wolfram . j l i n k . K e r n e l L i n k ;

73

import com . wolfram . j l i n k . MathLinkException ;
import com . wolfram . j l i n k . MathLinkFactory ;
import j a v a . i o . B u f f e r e d R e a d e r ;
import j a v a . i o . F i l e ;
import j a v a . i o . IOException ;
import j a v a . i o . InputStreamReader ;
import j a v a . u t i l . A r r a y L i s t ;
import j a v a . u t i l . r e g e x . Matcher ;
import j a v a . u t i l . r e g e x . P a t t e r n ;
import v3 . MathConnection . MathConnectionException ;

/**
*
* @author Dmitriy Krylov
*/
public c l a s s MathKernelFinder
{

private s t a t i c f i n a l
private s t a t i c f i n a l S t r i n g
private s t a t i c f i n a l S t r i n g

long

t i m e o u t
kernelName
l i b P r o p e r t y = "com . wolfram . j l i n k . l i b d i r " ;

=
= " m a t h k e r n e l . exe " ;

1 0 0 0 0 ;

private S t r i n g
private K e r n e l L i n k k e r n e l L i n k
private boolean

k e r n e l L o c a t i o n = n u l l ;
= n u l l ;
= f a l s e ;

isFound

private S e t t i n g M a n a g e r

s e t t i n g s = S e t t i n g M a n a g e r . g e t S e t t i n g M a n a g e r ( ) ;

public S t r i n g
public K e r n e l L i n k
public boolean
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

g e t L o c a t i o n ( ) { return k e r n e l L o c a t i o n ; }
}
g e t K e r n e l ( )
isFound ( )
}

{ return k e r n e l L i n k ;
{ return isFound ;

public void f i n d ( ) throws MathConnectionException
{

Log . msg ( " s t a r t

s e a r c h " ) ;

f i n d U s i n g I n i F i l e ( ) ;
i f (

isFound ) { return ; }

f i n d U s i n g R e g i s t e r 2 ( ) ;
i f (

isFound ) { return ; }

throw new MathConnectionException ( " can ’ t

f i n d math module " ) ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private void t r y C o n n e c t ( S t r i n g l o c a t i o n )
{

Log . msg (

l o c a t i o n ) ;

F i l e k e r n e l F i l e = new F i l e (

l o c a t i o n ) ;

i f ( k e r n e l F i l e . canExecute ( ) == f a l s e )
{

Log . msg ( " f i l e d o e s not e x i s t o r
return ;

i s not e x e c u t a b l e . " ) ;

}

74

i f ( System . g e t P r o p e r t y ( l i b P r o p e r t y ) == n u l l
{

)

F i l e k e r n e l D i r = k e r n e l F i l e . g e t P a r e n t F i l e ( ) ;
F i l e

j l i n k d i r = D i r F i n d e r . f i n d S u b D i r ( k e r n e l D i r , " JLink " ) ;

j l i n k d i r == n u l l

)

Log . msg ( " can ’ t
return ;

f i n d l i b d i r " ) ;

i f (
{

}

S t r i n g j l i n k d i r P a t h = j l i n k d i r . getPath ( ) ;

Log . msg ( " l i b d i r : "+j l i n k d i r P a t h ) ;
System . s e t P r o p e r t y (

l i b P r o p e r t y ,

j l i n k d i r P a t h ) ;

}

try
{

S t r i n g [ ]

c r e a t i n g A r g s = {

"−linkmode " , " l a u n c h " , "−linkname " ,

l o c a t i o n

} ;

K e r n e l L i n k l i n k = MathLinkFactory

. c r e a t e K e r n e l L i n k ( c r e a t i n g A r g s

) ;

l i n k . c o n n e c t (
t i m e o u t
l i n k . d i s c a r d A n s w e r ( ) ;

) ;

// c o n n e c t i o n s u c c e s s .

isFound = true ;
k e r n e l L i n k = l i n k ;
k e r n e l L o c a t i o n = l o c a t i o n ;

Log . msg ( " c o n n e c t e d " ) ;

}
catch ( MathLinkException e )
{

// c o n n e c t i o n f a i l .
Log . msg ( e . g e t M e s s a g e ( )

) ;

}

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private void f i n d U s i n g I n i F i l e ( )
{

Log . msg ( ) ;

S t r i n g path = s e t t i n g s

. g e t S e t t i n g ( " Mathematica path " , "PathToMath" ) ;

i f ( path == n u l l
{

)

Log . msg ( " can ’ t g e t

s e t t i n g PathToMath" ) ;

}
e l s e
{

t r y C o n n e c t ( path ) ;

75

}

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private void f i n d U s i n g R e g i s t e r 1 ( )
{

Log . msg ( ) ;

try
{
S t r i n g [ ] cmdLine = { " r e g " , " query "

, "HKLM\\SOFTWARE\\ Wolfram R e s e a r c h "
, " / s "
, " / t " , "REG_SZ"
} ;

P r o c e s s
i n t retCode = r e g . w aitFor ( ) ;

r e g = Runtime . getRuntime ( ) . e x e c ( cmdLine ) ;

retCode != 0 )

Log . msg ( " f a i l
return ;

i n r e g p r o c e s s : " + retCode ) ;

B u f f e r e d R e a d e r

regOut =
new B u f f e r e d R e a d e r (

new InputStreamReader (

r e g . g e t I n p u t S t r e a m ( ) ) )

i f (
{

}

try
(

) {

P a t t e r n p a t h P a t t e r n = P a t t e r n . c o m p i l e ( " \\S + ? : \ \ \ \ ( . + \ \ \ \ ) " ) ;

f o r ( S t r i n g l i n e = regOut . r e a d L i n e ( )

;
;

l i n e != n u l l
l i n e = regOut . r e a d L i n e ( )

) {

Matcher m = p a t h P a t t e r n . matcher (

l i n e

) ;

i f ( m. f i n d ( )
{

)

S t r i n g path = m. group ( ) + kernelName ;

t r y C o n n e c t ( path ) ;

isFound )

i f (
{

s e t t i n g s . s e t S e t t i n g ( " Mathematica path "

, "PathToMath"
,
) ;

path

Log . msg ( " s u c c e s s : "+path ) ;
break ; // s u c c e s s .

}

}

76

} // f o r

} // t r y−with−r e s o u r c e s

}
catch (
{

I n t e r r u p t e d E x c e p t i o n |

IOException ex )

Log . msg ( ex . g e t M e s s a g e ( )

) ;

}

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private void f i n d U s i n g R e g i s t e r 2 ( )
{

P a t t e r n p = P a t t e r n . c o m p i l e ( " ^ ( [ c−zC−Z ] + ) : ( \ \ \ \ .* )* \ \ . ( .* ) $ " ) ;

R e g i s t r y K e y w o l f k y e = new R e g i s t r y K e y ( RootKey .HKEY_LOCAL_MACHINE

, "SOFTWARE\\ Wolfram R e s e a r c h "
) ;

R e g i s t r y S e l e c t o r
A r r a y L i s t <R e g i s t r y V a l u e > f i n d V a l u e D a t a = r s . f i n d V a l u e D a t a ( w o l f k y e

r s = new R e g i s t r y S e l e c t o r ( p ) ;

) ;

f o r ( R e g i s t r y V a l u e v :
{

f i n d V a l u e D a t a )

S t r i n g path = v . getData ( ) . t o S t r i n g ( ) ;

path = path . s u b s t r i n g ( 0 , path . l a s t I n d e x O f ( " \\ " ) + 1 )

. c o n c a t ( kernelName ) ;

t r y C o n n e c t ( path ) ;

isFound )

i f (
{

s e t t i n g s . s e t S e t t i n g ( " Mathematica path "

, "PathToMath"
,
) ;

path

Log . msg ( " s u c c e s s : "+path ) ;
break ; // s u c c e s s .

}

}

}

}

MathPresentationBuilder.java

package v3 ;

import j a v a x . swing . BoxLayout ;
import j a v a x . swing . J L a b e l ;
import j a v a x . swing . JOptionPane ;
import j a v a x . swing . JPanel ;
import o r g . s c i l a b . f o r g e . j l a t e x m a t h . TeXConstants ;
import o r g . s c i l a b . f o r g e . j l a t e x m a t h . TeXFormula ;
import v3 . MathConnection . MathConnectionException ;

77

/**
*
* @author User
*/
public
c l a s s M a t h P r e s e n t a t i o n B u i l d e r
{

private i n t f o n t S i z e = 2 0 ;

private S t r i n g i n p u t = n u l l ;

i n t readMath = 1 ;
private f i n a l
i n t readText = 2 ;
private f i n a l
private i n t readNow = readText ;

private JPanel
private S t r i n g B u i l d e r c u r r L i n e = new S t r i n g B u i l d e r ( ) ;
private S t r i n g B u i l d e r e r r o r M s g = new S t r i n g B u i l d e r ( ) ;

t a r g e t = new JPanel ( ) ;

enum TermType { func , number , b r a c k e t s ,
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

l i s t } ;

public M a t h P r e s e n t a t i o n B u i l d e r ( )
{

t a r g e t . s e t L a y o u t ( new BoxLayout ( t a r g e t , BoxLayout . Y_AXIS)

) ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public JPanel b u i l d ( S t r i n g i n p u t T e x t

)

throws MathConnectionException

{

t h i s . i n p u t = i n p u t T e x t . r e p l a c e A l l ( " \ r \n" , " \n" )

. r e p l a c e A l l ( " \ r " , " \n" ) ;

i n t c u r r e n t P o s = 0 ;
while ( true )
{

Range math = findMath ( c u r r e n t P o s
i f ( math == n u l l
{

)

) ;

break ;

}

i f ( math . b e g i n > c u r r e n t P o s
{

)

S t r i n g t e x t = i n p u t . s u b s t r i n g ( c u r r e n t P o s , math . b e g i n ) ;
t r e a t T e x t (

t e x t

) ;

}

S t r i n g tMath = i n p u t . s u b s t r i n g ( math . begin , math . end ) ;
treatMath ( tMath ) ;

i f ( math . end < i n p u t . l e n g t h ( )
{

)

i n p u t . charAt ( math . end ) == ’ \n ’

)

newLine ( ) ;

i f (
{

}

}

78

c u r r e n t P o s = math . end ;

}
i f ( c u r r e n t P o s < i n p u t . l e n g t h ( )
{

)

t r e a t T e x t (

i n p u t . s u b s t r i n g ( c u r r e n t P o s )

) ;

}
addLine ( ) ;
return t a r g e t ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private void treatMath ( S t r i n g math ) throws MathConnectionException
{

i f ( math . c o n t a i n s ( "#" )
{

)

S t r i n g B u i l d e r workMath = new S t r i n g B u i l d e r ( math ) ;
i n t l e n = math . l e n g t h ( ) ;
i n t s t a r t = math . indexOf ( "#" ) ;
while (
{

!= −1 )

s t a r t

i n t c u r r = s t a r t ;
while ( c u r r < l e n && i s L a t i n L e t t e r ( workMath . charAt ( c u r r ) )
{

)

++c u r r ;

}
workMath . i n s e r t (
workMath . i n s e r t ( c u r r +1 ,

s t a r t ,

’ \" ’

) ;

’ \" ’

) ;

s t a r t = workMath . indexOf ( "#" , c u r r +2 ) ;
l e n += 2 ;

}
math = workMath . t o S t r i n g ( ) ;

}

WolfMathToLaTeXConverter c o n v e r t e r = new WolfMathToLaTeXConverter ( ) ;
S t r i n g l a t e x = c o n v e r t e r . c o n v e r t ( math ) ;
i f (
{

l a t e x != n u l l

)

c u r r L i n e . append (

l a t e x ) ;

i f ( e r r o r M s g == n u l l
{

)

e r r o r M s g = new S t r i n g B u i l d e r ( ) ;

}

e r r o r M s g . append ( " E r r o r
. append ( math )
. append ( " : \ n" )
. append ( c o n v e r t e r . getErrorMsg ( )
. append ( " \n" ) ;

i n " )

)

}
e l s e
{

}

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private void t r e a t T e x t ( S t r i n g t e x t
{

)

79

t e x t . c o n t a i n s ( " \n" )

)

i f (
{

i n t count = 0 ;
S t r i n g [ ]
f o r ( S t r i n g s :
{

s p l i t = t e x t . s p l i t ( " \n" ) ;

s p l i t

)

t r e a t T e x t ( s ) ;
i f ( count++ < s p l i t . l e n g t h − 1 )
{

newLine ( ) ;

}

t e x t . endsWith ( " \n" )

)

}
i f (
{

newLine ( ) ;

}
return ;

}

S t r i n g l a t e x = " \\ t e x t { "+t e x t+" } " ;
c u r r L i n e . append (

l a t e x ) ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private boolean i s U n a r y ( char ch )
{

return "−+" . indexOf ( ch ) != −1;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private boolean i s S p a c e ( char ch )
{

return " \ t " . indexOf ( ch ) != −1;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private boolean isMathOperator ( char ch )
{

return "*+−/<=>^" . indexOf ( ch ) != −1;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private boolean i s D i g g i t ( char ch )
{

return " 0123456789 " . indexOf ( ch ) != −1;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private boolean i s L a t i n L e t t e r ( char ch )
{

return "qwertyuioplkjhgfdsazxcvbnmQWERTYUIOPLKJHGFDSAZXCVBNM#"

indexOf ( ch ) != −1;

.

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

80

private void newLine ( )
{

addLine ( ) ;
c u r r L i n e = new S t r i n g B u i l d e r ( ) ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private void addLine ( )
{

Log . msg ( ) ;

S t r i n g l a t e x = c u r r L i n e . t o S t r i n g ( ) ;

t a r g e t . add ( new J L a b e l ( new TeXFormula (

l a t e x )

s e t S t y l e ( TeXConstants . STYLE_DISPLAY )
s e t S i z e (

. new TeXIconBuilder ( )
.
.
. b u i l d ( )
)

f o n t S i z e )

) ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

Range findMath (
{

i n t s t a r t P o s

)

i n t s t a r t F i n d = s t a r t P o s ;
while ( true )
{

i n t beginMath = findBeginMath (
i f ( beginMath == −1 )
{

s t a r t F i n d ) ;

return n u l l ;

}

i n t endMath = readMath ( beginMath ) ;
i f ( endMath == −1 )
{

s t a r t F i n d = beginMath + 1 ;
continue ;

}

return new Range ( beginMath , endMath ) ;

}

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

i n t findBeginMath (
{

i n t s t a r t P o s

)

i n t l e n g t h = i n p u t . l e n g t h ( ) ;
i n t c u r r e n t P o s = s t a r t P o s ;
f o r (
{

; c u r r e n t P o s < l e n g t h ; ++c u r r e n t P o s

)

char ch = i n p u t . charAt ( c u r r e n t P o s
i f (
{

i s F i r s t C h a r I n T e r m ( ch )

)

) ;

return c u r r e n t P o s ;

}

}
return −1;

81

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

i n t readMath (
{

i n t s t a r t P o s

)

i n t endMath = −1;
i n t beginTerm = s t a r t P o s ;
while ( true )
{

i n t endTerm = readTerm ( beginTerm ) ;
i f ( endTerm == −1 )
{

break ;

}

endMath = endTerm ;

i n t nextNonSpacePos = s k i p S p a c e s ( endTerm ) ;
i f ( nextNonSpacePos == −1 )
{

break ;

}

char nonSpace = i n p u t . charAt ( nextNonSpacePos
i f (
{

isMathOperator ( nonSpace )

)

!

) ;

break ;

}
i f ( nonSpace == ’− ’
{

)

i f ( nextNonSpacePos + 1 < i n p u t . l e n g t h ( )
{

)

i n p u t . charAt ( nextNonSpacePos + 1 ) == ’> ’

)

++nextNonSpacePos ;

i f (
{

}

}

}

beginTerm = nextNonSpacePos + 1 ;

}
return endMath ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

boolean i s F i r s t C h a r I n T e r m ( char t e s t
{

)

return i s L a t i n L e t t e r ( t e s t )

| |
| |
| |
| |

i s D i g g i t ( t e s t )
i s U n a r y ( t e s t )
t e s t == ’ ( ’
t e s t == ’ { ’ ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

i n t readTerm (

i n t s t a r t P o s

)

82

{

i n t nonSpacePos = s k i p S p a c e s (

s t a r t P o s

) ;

TermType t y pe = determineTermType ( nonSpacePos
i f (
{

)

t yp e == n u l l
return −1;

) ;

}

switch (
{

t yp e )

case l i s t :
case f u n c :
case number :
case b r a c k e t s : return readBracketsTerm ( nonSpacePos

return readListTerm ( nonSpacePos
return readFuncTerm ( nonSpacePos
return readNumberTerm ( nonSpacePos

) ;
) ;

) ;

) ;

d e f a u l t :

S t r i n g e r r o r = " u n e x p e c t e d t yp e o f
throw new I l l e g a l S t a t e E x c e p t i o n ( e r r o r

term " ;
) ;

}

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

TermType determineTermType (
{

i n t s t a r t P o s

)

char f i r s t = i n p u t . charAt (

s t a r t P o s

) ;

i s L a t i n L e t t e r ( f i r s t )

)

return TermType . f u n c ;

i s D i g g i t ( f i r s t )

)

return TermType . number ;

f i r s t == ’ ( ’

)

return TermType . b r a c k e t s ;

f i r s t == ’ { ’

)

return TermType . l i s t ;

i s U n a r y ( f i r s t )

)

i f (
{

}

i f (
{

}

i f (
{

}

i f (
{

}

i f (
{

i n t newStart = s k i p S p a c e s (
i f ( newStart != −1 )
{

s t a r t P o s + 1 ) ;

return determineTermType ( newStart

) ;

}

}

return n u l l ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

83

i n t readFuncTerm (
{

i n t s t a r t P o s

)

i n t l e n g t h = i n p u t . l e n g t h ( ) ;
i n t endHeader = s k i p H e a d e r (
i f ( endHeader == l e n g t h )
{

return l e n g t h ;

}

skipUnary ( s t a r t P o s )

) ;

i n t nonSpacePos = s k i p S p a c e s ( endHeader
i f ( nonSpacePos == −1 )
{

) ;

return l e n g t h ;

}

char nonSpace = i n p u t . charAt ( nonSpacePos
i f ( nonSpace == ’ [ ’
{

)

) ;

i n t b e g i n S e q u e n c e = nonSpacePos + 1 ;
i n t endSequence = readSequenceMath ( b e g i n S e q u e n c e ,
i f ( endSequence != −1 )
{

return s k i p S p a c e s ( endSequence ) + 1 ;

’ ] ’

) ;

}
e l s e
{

}

}

return −1;

return endHeader ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private i n t readSequenceMath (
{

i n t beginMath = s t a r t P o s ;
while ( true )
{

i n t s t a r t P o s , char t e r m i n a t o r

)

i f ( beginMath >= i n p u t . l e n g t h ( )
{

return −1;

)

}

i n t endMath = readMath ( beginMath ) ;
i f ( endMath == −1 )
{

return −1;

}

i n t nextNonSpacePos = s k i p S p a c e s ( endMath ) ;
i f ( nextNonSpacePos == −1 )
{

return −1;

}

char nonSpace = i n p u t . charAt ( nextNonSpacePos
i f ( nonSpace == t e r m i n a t o r
{

)

) ;

84

return endMath ;

}
e l s e
i f ( nonSpace == ’ , ’
{

)

beginMath = nextNonSpacePos + 1 ;
continue ; //Read n e x t math .

}
e l s e
{

}

}

return −1;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private i n t readNumberTerm (
{

i n t s t a r t P o s

)

i n t l e n g t h = i n p u t . l e n g t h ( ) ;
i n t c u r r e n t P o s = s t a r t P o s ;
f o r (
{

; c u r r e n t P o s < l e n g t h ; ++c u r r e n t P o s

)

char ch = i n p u t . charAt ( c u r r e n t P o s
i f (
{

i s D i g g i t ( ch )

!

)

) ;

return c u r r e n t P o s ;

}

}
return l e n g t h ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private i n t readListTerm (
{

i n t s t a r t P o s

)

i n t beginMathSequence = s k i p S p a c e s (
i f ( beginMathSequence == −1 )
{

return −1;

}

s t a r t P o s + 1 ) ;

i n t endSequenceMath = readSequenceMath ( beginMathSequence ,
i f ( endSequenceMath == −1 )
{

return −1;

’ } ’

) ;

}

i n t e n d L i s t = s k i p S p a c e s ( endSequenceMath ) ;
i f ( e n d L i s t == −1 )
{

return −1;

}

return e n d L i s t + 1 ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private i n t readBracketsTerm (
{

i n t s t a r t P o s

)

85

i n t beginMath = s k i p S p a c e s (
i f ( beginMath == −1 )
{

return −1;

}

s t a r t P o s + 1 ) ;

i n t endMath = readMath ( beginMath ) ;
i f ( endMath == −1 )
{

return −1;

}

i n t e n d L i s t = s k i p S p a c e s ( endMath ) ;
i f ( e n d L i s t == −1 )
{

return −1;

}

return e n d L i s t + 1 ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private i n t s k i p H e a d e r (
{

i n t s t a r t P o s

)

i n t l e n g t h = i n p u t . l e n g t h ( ) ;
i n t c u r r e n t P o s = s t a r t P o s ;
f o r (
{

; c u r r e n t P o s < l e n g t h ; ++c u r r e n t P o s

)

char ch = i n p u t . charAt ( c u r r e n t P o s
i f (
{

i s L a t i n L e t t e r ( ch )

)

!

) ;

return c u r r e n t P o s ;

}

}
return l e n g t h ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

i n t skipUnary (
{

i n t s t a r t P o s

)

return i s U n a r y (

i n p u t . charAt ( s t a r t P o s )

)

? s k i p S p a c e s (
:

s t a r t P o s ;

s t a r t P o s + 1 )

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private i n t s k i p S p a c e s (
{

i n t s t a r t P o s

)

i n t l e n g t h = i n p u t . l e n g t h ( ) ;
i n t c u r r e n t P o s = s t a r t P o s ;
f o r (
{

; c u r r e n t P o s < l e n g t h ; ++c u r r e n t P o s

)

char ch = i n p u t . charAt ( c u r r e n t P o s
i f (
{

i s S p a c e ( ch )

)

!

) ;

return c u r r e n t P o s ;

}

}

86

return −1;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

c l a s s Range
{

public f i n a l
public f i n a l
public Range (
{

i n t b e g i n ;
i n t end ;

i n t begin ,

i n t end )

t h i s . b e g i n = b e g i n ;
t h i s . end = end ;

}

}

}

MathPresentationPanel.java

package v3 ;

import j a v a x . swing . J S c r o l l P a n e ;
import v3 . MathConnection . MathConnectionException ;
/**
*
* @author Dmitriy Krylov
*/
public
c l a s s
extends
{

M a t h P r e s e n t a t i o n P a n e l
J S c r o l l P a n e

public void b u i l d ( S t r i n g t e x t
{

) throws MathConnectionException

s e t V i e w p o r t V i e w ( new M a t h P r e s e n t a t i o n B u i l d e r ( ) . b u i l d ( t e x t )
r e v a l i d a t e ( ) ;

) ;

}

}

SettingManager.java

package v3 ;

import j a v a . i o . F i l e ;
import j a v a . i o . IOException ;
import o r g . i n i 4 j . I n i ;
/**
*
* @author Dmitriy Krylov
*/
public c l a s s S e t t i n g M a n a g e r
{

private S t r i n g s e t t i n g F i l e L o c a t i o n = " s e t t i n g s . i n i " ;
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

87

private s t a t i c S e t t i n g M a n a g e r

s e t t i n g M a n a g e r = new S e t t i n g M a n a g e r ( ) ;

public s t a t i c S e t t i n g M a n a g e r g e t S e t t i n g M a n a g e r ( )
{

return s e t t i n g M a n a g e r ;

}

private S e t t i n g M a n a g e r ( ) {}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public S t r i n g g e t S e t t i n g ( S t r i n g s e c t i o n , S t r i n g s e t t i n g )
{

Log . msg ( " g e t

s e t t i n g : " + s e t t i n g + " ( "+s e c t i o n+" ) " ) ;

try
{

i n i = new I n i ( new F i l e ( s e t t i n g F i l e L o c a t i o n )

) ;

I n i
return i n i . g e t (

s e c t i o n ,

s e t t i n g ) ;

}
catch (
{

IOException ex )

Log . msg ( " e r r o r : " + ex . g e t M e s s a g e ( )

) ;

}

return n u l l ;

}

public boolean s e t S e t t i n g ( S t r i n g s e c t i o n , S t r i n g s e t t i n g , S t r i n g v a l u e )
{

boolean r e t V a l u e = f a l s e ;

Log . msg ( " s e t
try
{

s e t t i n g : " + s e c t i o n + " " + s e t t i n g + " = " + v a l u e

) ;

i n i = new I n i ( new F i l e ( s e t t i n g F i l e L o c a t i o n )

) ;

s e c t i o n ,

s e t t i n g , v a l u e

) ;

I n i
i n i . put (
i n i . s t o r e ( ) ;

r e t V a l u e = true ;

}
catch (
{

IOException ex )

Log . msg ( " e r r o r : " + ex . g e t M e s s a g e ( )

) ;

}

return r e t V a l u e ;

}

}

RegistrySelector.java

package v3 ;

import ca . beq . u t i l . win32 . r e g i s t r y . R e g i s t r y E x c e p t i o n ;
import ca . beq . u t i l . win32 . r e g i s t r y . R e g i s t r y K e y ;
import ca . beq . u t i l . win32 . r e g i s t r y . R e g i s t r y V a l u e ;
import ca . beq . u t i l . win32 . r e g i s t r y . RootKey ;

88

import j a v a . i o . F i l e ;
import j a v a . i o . FileOutputStream ;
import j a v a . i o . IOException ;
import j a v a . i o . InputStream ;
import j a v a . i o . OutputStream ;
import j a v a . n e t .URL;
import j a v a . u t i l . ArrayDeque ;
import j a v a . u t i l . A r r a y L i s t ;
import j a v a . u t i l . I t e r a t o r ;
import j a v a . u t i l . Queue ;
import j a v a . u t i l . r e g e x . Matcher ;
import j a v a . u t i l . r e g e x . P a t t e r n ;

public c l a s s R e g i s t r y S e l e c t o r
{

private f i n a l s t a t i c S t r i n g DLL_NAME = " j R e g i s t r y K e y . d l l " ;
private f i n a l P a t t e r n p a t t e r n ;

private Queue <RegistryKey> k e y s = new ArrayDeque < >();
private Queue <R e g i s t r y V a l u e > queue = new ArrayDeque < >();
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public R e g i s t r y S e l e c t o r ( P a t t e r n p )
{

t h i s . p a t t e r n = p ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public A r r a y L i s t <R e g i s t r y V a l u e > f i n d V a l u e D a t a ( R e g i s t r y K e y r o o t
{

)

f o r ( R e g i s t r y K e y currKey = r o o t

;
;
) {

try
{

currKey != n u l l
currKey = k e y s . p o l l ( )

i f ( currKey . hasSubkeys ( )
{

)

I t e r a t o r
while (
{

s u b k e y s = currKey . s u b k e y s ( ) ;

s u b k e y s . hasNext ( )

)

k e y s . add (

( R e g i s t r y K e y )

s u b k e y s . ne x t ( )

) ;

}

}

i f ( currKey . h a s V a l u e s ( )
{

)

I t e r a t o r v a l u e s = currKey . v a l u e s ( ) ;
while ( v a l u e s . hasNext ( )
{

)

R e g i s t r y V a l u e v a l u e = ( R e g i s t r y V a l u e ) v a l u e s . ne x t ( ) ;
S t r i n g s t r i n g V a l u e = v a l u e . getData ( ) . t o S t r i n g ( ) ;
Matcher m = p a t t e r n . matcher (
i f ( m. matches ( )
{

s t r i n g V a l u e

) ;

)

Log . msg ( v a l u e . g e t S t r i n g V a l u e ( )
queue . add ( v a l u e

) ;

) ;

}

89

}

}

}
catch ( R e g i s t r y E x c e p t i o n ex )
{

Log . msg ( ex . g e t M e s s a g e ( )

) ;

}

} // f o r

return new A r r a y L i s t <> ( queue ) ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public s t a t i c void i n i t ( )
{

try
{

Log . msg ( ) ;
URL d l l = R e g i s t r y S e l e c t o r . c l a s s . g e t R e s o u r c e ( DLL_NAME ) ;

i f ( d l l == n u l l
{

)

throw new RuntimeException ( " can ’ t

f i n d "+DLL_NAME ) ;

}

F i l e temp = F i l e . c r e a t e T e m p F i l e ( " l i b r a r y " , " . d l l " ) ;
temp . d e l e t e O n E x i t ( ) ;

try (

) {

InputStream i s = d l l . openStream ( ) ;
OutputStream o s = new FileOutputStream ( temp ) ;
i n t r e a d B y t e s = −1;
byte [ ] b u f f e r = new byte [ 1 0 2 4 ] ;

( r e a d B y t e s = i s . r e a d ( b u f f e r ) )

!= −1 )

while (
{

o s . w r i t e ( b u f f e r , 0 ,

r e a d B y t e s ) ;

}

}
Log . msg ( " l o a d " ) ;
R e g i s t r y K e y . i n i t i a l i z e ( temp . g e t A b s o l u t e P a t h ( )

) ;

}
catch (
{

IOException ex )

Log . msg ( ex . g e t M e s s a g e ( )

) ;

}

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public s t a t i c void main ( S t r i n g [ ] a r g s )
{

S t r i n g w o l f = "SOFTWARE\\ Wolfram R e s e a r c h " ;
R e g i s t r y K e y w o l f k y e = new R e g i s t r y K e y ( RootKey .HKLM, w o l f
P a t t e r n p = P a t t e r n . c o m p i l e ( " ^ ( [ c−zC−Z ] + ) : ( \ \ \ \ .* )* \ \ . ( .* \ \ . exe ) $ " ) ;
// P a t t e r n p = P a t t e r n . c o m p i l e ( " .* " ) ;

) ;

90

R e g i s t r y S e l e c t o r

r s = new R e g i s t r y S e l e c t o r ( p ) ;

r s . f i n d V a l u e D a t a ( w o l f k y e

) ;

}

}

IncorrectSyntaxException.java

package v3 ;
/**
*
* @author Dmitriy Krylov
*/
public
c l a s s
extends E x c e p t i o n
{

I n c o r r e c t S y n t a x E x c e p t i o n

public I n c o r r e c t S y n t a x E x c e p t i o n ( S t r i n g msg )
{

super ( msg ) ;

}

public I n c o r r e c t S y n t a x E x c e p t i o n ( )
{

super ( ) ;

}

}

Исходные тексты интерфейса под Andriod

MainActivity.java

package com . example . t e s t 1 a p p ;

import j a v a . i o . B u f f e r e d R e a d e r ;
import j a v a . i o . IOException ;
import j a v a . i o . InputStream ;
import j a v a . i o . InputStreamReader ;
import j a v a . i o . S t r i n g W r i t e r ;
import j a v a . n e t . HttpCookie ;
import j a v a . u t i l . A r r a y L i s t ;
import j a v a . u t i l . HashMap ;
import j a v a . u t i l . L i s t ;
import j a v a . u t i l . r e g e x . Matcher ;
import j a v a . u t i l . r e g e x . P a t t e r n ;

import o r g . apache . h t t p . HttpResponse ;
import o r g . apache . h t t p . NameValuePair ;
import o r g . apache . h t t p . c l i e n t . H t t p C l i e n t ;
import o r g . apache . h t t p . c l i e n t . e n t i t y . UrlEncodedFormEntity ;
import o r g . apache . h t t p . c l i e n t . methods . HttpGet ;
import o r g . apache . h t t p . c l i e n t . methods . HttpPost ;
import o r g . apache . h t t p . c l i e n t . methods . HttpUriRequest ;
import o r g . apache . h t t p . c l i e n t . p r o t o c o l . C l i e n t C o n t e x t ;

91

import o r g . apache . h t t p . c o o k i e . Cookie ;
import o r g . apache . h t t p . impl . c l i e n t . B a s i c C o o k i e S t o r e ;
import o r g . apache . h t t p . impl . c l i e n t . D e f a u l t H t t p C l i e n t ;
import o r g . apache . h t t p . impl . c o o k i e . B a s i c C l i e n t C o o k i e ;
import o r g . apache . h t t p . message . BasicNameValuePair ;
import o r g . apache . h t t p . p r o t o c o l . B a s i c H t t p C o n t e x t ;
import o r g . apache . h t t p . p r o t o c o l . HttpContext ;

import a n d r o i d . o s . Bundle ;
import a n d r o i d . a n n o t a t i o n . S u p p r e s s L i n t ;
import a n d r o i d . app . A c t i v i t y ;
import a n d r o i d . c o n t e n t . r e s . AssetManager ;
import a n d r o i d . view . Menu ;
import a n d r o i d . view . View ;
import a n d r o i d . w e b k i t . WebView ;
import a n d r o i d . w i d g e t . AdapterView ;
import a n d r o i d . w i d g e t . ArrayAdapter ;
import a n d r o i d . w i d g e t . EditText ;
import a n d r o i d . w i d g e t . L i s t V i e w ;
import a n d r o i d . w i d g e t . TextView ;

public c l a s s M a i n A c t i v i t y extends A c t i v i t y {

private f i n a l S t r i n g BASE_ADDRESS = " h t t p : / / edu2 . n s c i e n c e . ru " ;
private f i n a l S t r i n g KERNEL_ADDRESS = " h t t p : / / i n t . pm . miem . edu . ru / taskpower3_war_exploded " ;

private f i n a l S t r i n g PROF_ADDRESS = BASE_ADDRESS + " / p r o f / " ;
private f i n a l S t r i n g TEST_REGISTER = BASE_ADDRESS + " / a j a x / p r o f e s s o r _ a u t h . php" ;
private f i n a l S t r i n g CHECK_ANSWER = KERNEL_ADDRESS + " / compareAnswer . do " ;
private f i n a l S t r i n g GET_TASK = KERNEL_ADDRESS + " / getTask . do " ;

private f i n a l H t t p C l i e n t h t t p C l i e n t = new D e f a u l t H t t p C l i e n t ( ) ;
private S t r i n g c o o k i e s L i n e _ = n u l l ;
private S t r i n g userLogin_ = n u l l ;

private L i s t V i e w t a s k L i s t = n u l l ;

private S t r i n g problem ;
private S t r i n g s o l u t i o n ;
private S t r i n g answer ;
private S t r i n g problemPage ;
private S t r i n g S o l u t i o n P a g e ;
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−
@Override
protected void onCreate ( Bundle s a v e d I n s t a n c e S t a t e ) {

super . onCreate ( s a v e d I n s t a n c e S t a t e ) ;
setContentView (R. l a y o u t . a c t i v i t y _ m a i n ) ;

}

@Override
public boolean onCreateOptionsMenu (Menu menu ) {

// I n f l a t e t h e menu ;
g e t M e n u I n f l a t e r ( ) . i n f l a t e (R. menu . main , menu ) ;
return true ;

t h i s adds i t e m s t o t h e a c t i o n b a r

i f

i t

i s p r e s e n t .

}

public void c l i c k H a n d l e r ( View t a r g e t ) {

switch (

t a r g e t . g e t I d ( )

) {

92

case R. i d . u s e r E n t e r B u t t o n :

u s e r E n t e r ( ) ;
break ;

case R. i d . returnHomeButton :

setContentView (R. l a y o u t . a c t i v i t y _ m a i n ) ;
break ;

case R. i d . r e t u r n T a s k L i s t B u t t o n :

readAndShowListOfTask ( userLogin_ ) ;
break ;

case R. i d . answerEnteredButton :

boolean r i g t h A n s w e r = checkAnswer ( ) ;
setContentView (R. l a y o u t . t a s t _ r e s u l t ) ;

TextView t e x t = ( TextView ) t h i s . findViewById (

R. i d . s o l u t i o n R e s u l t T e x t

) ;

i f (

r i g t h A n s w e r
t e x t . s e t T e x t ( "Ваш ответ верный" ) ;

) {

} e l s e {

t e x t . s e t T e x t ( "Ваш ответ неверный . Решение : " ) ;
WebView web = ( WebView ) t h i s . findViewById ( R. i d . webview ) ;
web . g e t S e t t i n g s ( ) . s e t J a v a S c r i p t E n a b l e d ( true ) ;
web . loadDataWithBaseURL ( " f a k e " , S o l u t i o n P a g e ,

" t e x t / html " , " u t f −8" , " " ) ;

}

break ;

d e f a u l t :

// do n o t h i n g .
break ;

}

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private boolean checkAnswer ( ) {

EditText e t = ( EditText ) t h i s . findViewById ( R. i d . taskAnswerEditText

) ;

S t r i n g r e a l _ a n s w e r = answer ;
S t r i n g user_answer = " ( "+e t . g e t T e x t ( ) . t o S t r i n g ()+ " ) " ;

try {

S t r i n g r e s u l t =
h t t p R e q u e s t P o s t (

CHECK_ANSWER,
" user_answer " , user_answer ,
" r e a l _ a n s w e r " ,

r e a l _ a n s w e r

) ;

return r e s u l t . t r i m ( ) . e q u a l s ( " True " ) ;

} catch ( E x c e p t i o n e ) {

// TODO Auto−g e n e r a t e d c a t c h b l o c k
e . p r i n t S t a c k T r a c e ( ) ;

}
return f a l s e ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public void u s e r E n t e r ( ) {

93

EditText e t = ( EditText ) t h i s . findViewById ( R. i d . u s e r L o g i n E d i t T e x t
S t r i n g u s e r L o g i n = e t . g e t T e x t ( ) . t o S t r i n g ( ) ;

) ;

try {

boolean u s e r R e g i s t e r e d = t e s t U s e r R e g i s t e r e d ( u s e r L o g i n ) ;
i f ( u s e r R e g i s t e r e d ) {

readAndShowListOfTask ( u s e r L o g i n ) ;
userLogin_ = u s e r L o g i n ;

}

} catch ( E x c e p t i o n e ) {
e . p r i n t S t a c k T r a c e ( ) ;

}

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private void readAndShowListOfTask ( S t r i n g u s e r L o g i n ) {

try {

c o o k i e s L i n e _ = " l o g i n=" + u s e r L o g i n ;
S t r i n g page ;
page = h t t p R e q u e s t P o s t ( PROF_ADDRESS ) ;

f i n a l S t r i n g [ ]
f i n a l S t r i n g [ ]
f i n a l S t r i n g [ ]

t a s k s = makeTaskList ( page ) ;
taskNames = new S t r i n g [ t a s k s . l e n g t h / 2 ] ;
t a s k R e f s = new S t r i n g [ t a s k s . l e n g t h / 2 ] ;

f o r (

i <taskNames . l e n g t h ; ++i

i n t i =0;
taskNames [ i ] = t a s k s [ 2* i ] ;
t a s k R e f s [ i ] = t a s k s [ 2* i + 1 ] ;

) {

}

ArrayAdapter<S t r i n g > l i s t A d a p t e r = new ArrayAdapter<S t r i n g >(

t h i s ,
R. l a y o u t . simplerow ,
taskNames

) ;
setContentView (R. l a y o u t . t a s k _ l i s t ) ;
t a s k L i s t = ( L i s t V i e w ) findViewById (R. i d . t a s k L i s t ) ;
t a s k L i s t . s e t A d a p t e r (
l i s t A d a p t e r
t a s k L i s t . s e t O n I t e m C l i c k L i s t e n e r (

) ;

new MyOnItemClickListener (

t a s k R e f s

) ) ;

} catch ( E x c e p t i o n e1 ) {

// TODO Auto−g e n e r a t e d c a t c h b l o c k
e1 . p r i n t S t a c k T r a c e ( ) ;

}

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private S t r i n g [ ] makeTaskList ( S t r i n g page ) {

L i s t <S t r i n g > t a s k L i s t = new A r r a y L i s t <S t r i n g > ( ) ;

S t r i n g f i n d P a t t e r n = "<a h r e f = ’/ edu / i n d e x . php ? t a s k=" ;
S t r i n g r e f = n u l l ;
S t r i n g name = n u l l ;

i n t patLen = f i n d P a t t e r n . l e n g t h ( ) ;

94

i n t s t a r t = 0 ;
i n t end = 0 ;

do{

f i n d P a t t e r n , end ) ;

s t a r t = page . indexOf (
i f (

!= −1 ) {

s t a r t
s t a r t += patLen ;
end = page . indexOf ( "&" ,
i f ( end != −1 ) {

name = page . s u b s t r i n g (
t a s k L i s t . add ( name ) ;
t a s k L i s t . add (

r e f

) ;

}

}

}

}

} while (

s t a r t

!= −1 && end != −1 ) ;

s t a r t

) ;

s t a r t , end ) ;
’> ’ , end ) ;

r e f = page . s u b s t r i n g (
s t a r t = page . indexOf (
i f (

!= −1 ) {

s t a r t
s t a r t += 1 ;
end = page . indexOf ( "</a>" ,
i f ( end != −1 ) {

s t a r t

) ;

s t a r t , end ) ;

S t r i n g [ ]
return t a s k L i s t . toArray (

t a s k L i s t A r r a y = new S t r i n g [ t a s k L i s t . s i z e ( ) ] ;

t a s k L i s t A r r a y ) ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private void r e q u e s t T a s k ( S t r i n g t a s k R e f

) throws E x c e p t i o n {

setContentView (R. l a y o u t . task_view ) ;
WebView web = ( WebView ) t h i s . findViewById ( R. i d . webview ) ;
web . g e t S e t t i n g s ( ) . s e t J a v a S c r i p t E n a b l e d ( true ) ;

S t r i n g t a s k D e s c r i p t i o n ;
t a s k D e s c r i p t i o n = httpRequestGet ( GET_TASK, " t a s k " ,

t a s k R e f

) ;

problem = extractXMLByTag (
s o l u t i o n = extractXMLByTag (
answer = extractXMLByTag (

t a s k D e s c r i p t i o n , " problem " ) ;

t a s k D e s c r i p t i o n , " s o l u t i o n " ) ;

t a s k D e s c r i p t i o n , " answer " ) ;

InputStream i s = g e t A s s e t s ( ) . open ( " h t m l p a t t e r n " ) ;
S t r i n g h t m l P a t t e r n = c o n v e r t S t r e a m T o S t r i n g (

i s

) ;

problem = problem . r e p l a c e ( "&#8518;" , "d" )

. r e p l a c e ( "&#8519;" , " e " ) ;

s o l u t i o n = s o l u t i o n . r e p l a c e ( "&#8518;" , "d" )

. r e p l a c e ( "&#8519;" , " e " ) ;

problemPage = h t m l P a t t e r n . r e p l a c e ( " ! ! ! " , problem ) ;
S o l u t i o n P a g e = h t m l P a t t e r n . r e p l a c e ( " ! ! ! " ,
web . loadDataWithBaseURL ( " f a k e " , problemPage , " t e x t / html " , " u t f −8" , " " ) ;
// web . l o a d U r l (" h t t p : / /www. mathjax . o r g /demos/ t e x−s a m p l e s / " ) ;

s o l u t i o n ) ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

95

private S t r i n g extractXMLByTag ( S t r i n g page , S t r i n g t a g ) {

S t r i n g p a t t e r n S t r i n g = "<" + t a g + " .*? >(.*?) </ " + t a g + ">" ;

i n t f l a g s = P a t t e r n . MULTILINE | P a t t e r n .DOTALL;
P a t t e r n p = P a t t e r n . c o m p i l e ( p a t t e r n S t r i n g ,

f l a g s

) ;

Matcher m = p . matcher ( page ) ;

i f ( m. f i n d ( )

) {

return m. group ( 1 ) ;

}
return n u l l ;

}

//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public boolean t e s t U s e r R e g i s t e r e d ( S t r i n g u s e r L o g i n )

throws E x c e p t i o n {

S t r i n g r e s u l t = httpRequestGet ( TEST_REGISTER, " l o g i n " , u s e r L o g i n ) ;
return r e s u l t . t r i m ( ) . e q u a l s ( " 1 " ) ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public S t r i n g httpRequestGet ( S t r i n g r e q u e s t , S t r i n g . . . params )

throws E x c e p t i o n {

i f ( params . l e n g t h % 2 != 0 ) {

S t r i n g e r r o r = "number o f params
throw new I l l e g a l A r g u m e n t E x c e p t i o n ( e r r o r

i s not even " ;

) ;

}

S t r i n g r e s u l t R e q u e s t = r e q u e s t ;

i f ( params . l e n g t h != 0 ) {
r e s u l t R e q u e s t += " ? " ;
f o r (

i n t i = 0 ;

i < params . l e n g t h ;

i +=2 ) {

r e s u l t R e q u e s t += params [ i ]+ "="+params [ i + 1 ] ;

}

}

HttpGet g e t R e q u e s t = new HttpGet (
return h t t p R e q u e s t ( g e t R e q u e s t
) ;

r e s u l t R e q u e s t

) ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public S t r i n g h t t p R e q u e s t P o s t ( S t r i n g r e q u e s t , S t r i n g . . . params )

throws E x c e p t i o n {

i f ( params . l e n g t h % 2 != 0 ) {

S t r i n g e r r o r = "number o f params
throw new I l l e g a l A r g u m e n t E x c e p t i o n ( e r r o r

i s not even " ;

) ;

}

HttpPost p o s t R e q u e s t = new HttpPost (

r e q u e s t

) ;

i f ( params . l e n g t h != 0 ) {

96

i n t pairNum = params . l e n g t h / 2 ;
f i n a l
L i s t <NameValuePair> p o s t P a r a m e t e r s =

new A r r a y L i s t <NameValuePair >( pairNum ) ;

f o r (

i n t i = 0 ;

i <params . l e n g t h ;

i +=2 ) {

p o s t P a r a m e t e r s . add (

new BasicNameValuePair ( params [ i ] , params [ i +1]

) ) ;

}

UrlEncodedFormEntity f o r m E n t i t y =

new UrlEncodedFormEntity ( p o s t P a r a m e t e r s

) ;

p o s t R e q u e s t . s e t E n t i t y ( f o r m E n t i t y ) ;

}

return h t t p R e q u e s t ( p o s t R e q u e s t

) ;

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

private S t r i n g h t t p R e q u e s t ( HttpUriRequest

r e q u e s t

)

throws E x c e p t i o n {

i f ( c o o k i e s L i n e _ != n u l l

) {

r e q u e s t . s e t H e a d e r ( " Cookie " , c o o k i e s L i n e _ ) ;

}
HttpResponse r e s p o n s e = h t t p C l i e n t . e x e c u t e (

r e q u e s t

) ;

InputStream i s = n u l l ;
try {

i s = r e s p o n s e . g e t E n t i t y ( ) . g e t C o n t e n t ( ) ;
return c o n v e r t S t r e a m T o S t r i n g (

i s

) ;

} f i n a l l y {

!= n u l l

i s
i s . c l o s e ( ) ;

) {

i f (

}

}

}
//−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−

public s t a t i c S t r i n g c o n v e r t S t r e a m T o S t r i n g (

InputStream i s

)

throws IOException {

i f (

i s == n u l l
throw new I l l e g a l A r g u m e n t E x c e p t i o n ( " a r g i s n u l l " ) ;

) {

}

B u f f e r e d R e a d e r
i n = new B u f f e r e d R e a d e r (new InputStreamReader (

i n ;

i s

) ) ;

S t r i n g B u f f e r
S t r i n g s e p a r a t o r = System . g e t P r o p e r t y ( " l i n e . s e p a r a t o r " ) ;

sb = new S t r i n g B u f f e r ( ) ;

S t r i n g l i n e ;
while (

( l i n e = i n . r e a d L i n e ( ) )

!= n u l l

) {

sb . append (

l i n e + s e p a r a t o r

) ;

}

S t r i n g r e s u l t = sb . t o S t r i n g ( ) ;
return r e s u l t ;

97

}

//========================================================================

c l a s s MyOnItemClickListener
implements AdapterView . O n I t e m C l i c k L i s t e n e r {

f i n a l S t r i n g [ ]

t a s k R e f s ;

public MyOnItemClickListener ( S t r i n g [ ]

t a s k R e f s

) {

t h i s . t a s k R e f s = t a s k R e f s ;

}

@Override
public void o n I t e m C l i c k (

AdapterView<?> arg0 ,
View arg1 ,

i n t p o s i t i o n ,

long a r g 3 ) {

try {

} catch ( E x c e p t i o n e ) {

t a s k R e f s [ p o s i t i o n ]

r e q u e s t T a s k (
) ;
// TODO Auto−g e n e r a t e d c a t c h b l o c k
e . p r i n t S t a c k T r a c e ( ) ;

}

}

}

}

activityMain.xml

<?xml version=" 1 . 0 " e n c o d i n g=" u t f −8" ?>
<L i n e a r L a y o u t

x m l n s : a n d r o i d=" h t t p : // schemas . a n d r o i d . com/ apk / r e s / a n d r o i d "
a n d r o i d : l a y o u t _ w i d t h=" match_parent "
a n d r o i d : l a y o u t _ h e i g h t=" match_parent "
a n d r o i d : o r i e n t a t i o n=" v e r t i c a l " >

<TextView

a n d r o i d : i d="@+i d / u s e r E n t e r T e x t F i e l d T i t l e "
a n d r o i d : l a y o u t _ w i d t h=" wrap_content "

a n d r o i d : l a y o u t _ h e i g h t=" wrap_content "

a n d r o i d : t e x t=" @ s t r i n g / u s e r E n t e r T e x t F i e l d T i t l e " />

<L i n e a r L a y o u t

a n d r o i d : l a y o u t _ w i d t h=" match_parent "
a n d r o i d : l a y o u t _ h e i g h t=" wrap_content "
a n d r o i d : o r i e n t a t i o n=" h o r i z o n t a l " >

<EditText

a n d r o i d : i d="@+i d / u s e r L o g i n E d i t T e x t "
a n d r o i d : i n p u t T y p e=" t e x t "
a n d r o i d : l a y o u t _ w e i g h t=" 1 . 0 "
a n d r o i d : l a y o u t _ w i d t h=" 0dp"
a n d r o i d : l a y o u t _ h e i g h t=" wrap_content " />

<Button

a n d r o i d : i d="@+i d / u s e r E n t e r B u t t o n "
a n d r o i d : o n C l i c k=" c l i c k H a n d l e r "

98

a n d r o i d : l a y o u t _ w i d t h=" wrap_content "
a n d r o i d : l a y o u t _ h e i g h t=" wrap_content "
a n d r o i d : t e x t=" @ s t r i n g / u s e r E n t e r B u t t o n T e x t " />

</ L i n e a r L a y o u t>

</ L i n e a r L a y o u t>

taskList.xml

<?xml version=" 1 . 0 " e n c o d i n g=" u t f −8" ?>
<L i n e a r L a y o u t x m l n s : a n d r o i d=" h t t p : // schemas . a n d r o i d . com/ apk / r e s / a n d r o i d "

a n d r o i d : l a y o u t _ w i d t h=" f i l l _ p a r e n t "
a n d r o i d : l a y o u t _ h e i g h t=" f i l l _ p a r e n t "
a n d r o i d : o r i e n t a t i o n=" v e r t i c a l " >

<Button

a n d r o i d : i d="@+i d / returnHomeButton "
a n d r o i d : o n C l i c k=" c l i c k H a n d l e r "
a n d r o i d : l a y o u t _ w i d t h=" wrap_content "
a n d r o i d : l a y o u t _ h e i g h t=" wrap_content "
a n d r o i d : t e x t=" @ s t r i n g / returnHomeButtonText " />

<L i s t V i e w

a n d r o i d : i d="@+i d / t a s k L i s t "
a n d r o i d : l a y o u t _ w i d t h=" wrap_content "
a n d r o i d : l a y o u t _ h e i g h t=" wrap_content " />

</ L i n e a r L a y o u t>

taskView.xml

<?xml version=" 1 . 0 " e n c o d i n g=" u t f −8" ?>
<L i n e a r L a y o u t x m l n s : a n d r o i d=" h t t p : // schemas . a n d r o i d . com/ apk / r e s / a n d r o i d "

a n d r o i d : l a y o u t _ w i d t h=" match_parent "
a n d r o i d : l a y o u t _ h e i g h t=" match_parent "
a n d r o i d : o r i e n t a t i o n=" v e r t i c a l " >

<Button

a n d r o i d : i d="@+i d / r e t u r n T a s k L i s t B u t t o n "
a n d r o i d : o n C l i c k=" c l i c k H a n d l e r "
a n d r o i d : l a y o u t _ w i d t h=" wrap_content "
a n d r o i d : l a y o u t _ h e i g h t=" wrap_content "
a n d r o i d : t e x t=" @ s t r i n g / r e t u r n T a s k L i s t B u t t o n T e x t " />

<WebView

a n d r o i d : i d="@+i d / webview "
a n d r o i d : l a y o u t _ w i d t h=" match_parent "
a n d r o i d : l a y o u t _ h e i g h t=" wrap_content "

/>

<L i n e a r L a y o u t

a n d r o i d : l a y o u t _ w i d t h=" f i l l _ p a r e n t "
a n d r o i d : l a y o u t _ h e i g h t=" wrap_content "
a n d r o i d : o r i e n t a t i o n=" h o r i z o n t a l " >

<EditText a n d r o i d : i d="@+i d / taskAnswerEditText "

99

a n d r o i d : i n p u t T y p e=" t e x t "
a n d r o i d : l a y o u t _ w e i g h t=" 1 . 0 "
a n d r o i d : l a y o u t _ w i d t h=" 0dp"
a n d r o i d : l a y o u t _ h e i g h t=" wrap_content " />

<Button

a n d r o i d : i d="@+i d / answerEnteredButton "
a n d r o i d : o n C l i c k=" c l i c k H a n d l e r "
a n d r o i d : l a y o u t _ w i d t h=" wrap_content "
a n d r o i d : l a y o u t _ h e i g h t=" wrap_content "
a n d r o i d : t e x t=" @ s t r i n g / answerEnteredText " />

</ L i n e a r L a y o u t>

</ L i n e a r L a y o u t>

tastResult.xml

<?xml version=" 1 . 0 " e n c o d i n g=" u t f −8" ?>
<L i n e a r L a y o u t x m l n s : a n d r o i d=" h t t p : // schemas . a n d r o i d . com/ apk / r e s / a n d r o i d "

a n d r o i d : l a y o u t _ w i d t h=" match_parent "
a n d r o i d : l a y o u t _ h e i g h t=" match_parent "
a n d r o i d : o r i e n t a t i o n=" v e r t i c a l " >

<Button

a n d r o i d : i d="@+i d / r e t u r n T a s k L i s t B u t t o n "
a n d r o i d : o n C l i c k=" c l i c k H a n d l e r "
a n d r o i d : l a y o u t _ w i d t h=" wrap_content "
a n d r o i d : l a y o u t _ h e i g h t=" wrap_content "
a n d r o i d : t e x t=" @ s t r i n g / r e t u r n T a s k L i s t B u t t o n T e x t " />

<TextView

a n d r o i d : i d="@+i d / s o l u t i o n R e s u l t T e x t "
a n d r o i d : t e x t I s S e l e c t a b l e=" t r u e "
a n d r o i d : l a y o u t _ w i d t h=" wrap_content "

a n d r o i d : l a y o u t _ h e i g h t=" wrap_content " />

<WebView

a n d r o i d : i d="@+i d / webview "
a n d r o i d : l a y o u t _ w i d t h=" match_parent "
a n d r o i d : l a y o u t _ h e i g h t=" wrap_content "

/>

</ L i n e a r L a y o u t>

strings.xml

<?xml version=" 1 . 0 " e n c o d i n g=" u t f −8" ?>
<r e s o u r c e s>

< s t r i n g name="app_name">uI</ s t r i n g>
< s t r i n g name=" a c t i o n _ s e t t i n g s ">S e t t i n g s</ s t r i n g>
< s t r i n g name=" u s e r E n t e r T e x t F i e l d T i t l e ">Вход в систему , введите л о г и н :</ s t r i n g>
< s t r i n g name=" u s e r E n t e r B u t t o n T e x t ">Вход</ s t r i n g>
< s t r i n g name=" returnHomeButtonText ">Вернуться</ s t r i n g>
< s t r i n g name=" r e t u r n T a s k L i s t B u t t o n T e x t ">Вернуться</ s t r i n g>
< s t r i n g name=" answerEnteredText ">Ввести ответ</ s t r i n g>

</ r e s o u r c e s>

100

Исходные тексты реализованных сервлетов ядра

ConverterServlet.java

package s e r v l e t ;

import c o n f i g u r a t i o n . C o n f i g u r a t i o n C o n t e x t H e l p e r ;
import math . MathAware ;
import math . MathException ;
import math . MathModule ;

import j a v a x . s e r v l e t . S e r v l e t E x c e p t i o n ;
import j a v a x . s e r v l e t . h t t p . H t t p S e r v l e t ;
import j a v a x . s e r v l e t . h t t p . H t t p S e r v l e t R e q u e s t ;
import j a v a x . s e r v l e t . h t t p . H t t p S e r v l e t R e s p o n s e ;
import j a v a . i o . IOException ;
import j a v a . i o . P r i n t W r i t e r ;

public c l a s s C o n v e r t e r S e r v l e t extends H t t p S e r v l e t implements MathAware {

public void doPost ( H t t p S e r v l e t R e q u e s t

req , H t t p S e r v l e t R e s p o n s e r e s

)

throws S e r v l e t E x c e p t i o n ,

IOException

{

S t r i n g r e s u l t = n u l l ;
r e s . s e t C h a r a c t e r E n c o d i n g ( "UTF8" ) ;
P r i n t W r i t e r out = r e s . g e t W r i t e r ( ) ;

math = C o n f i g u r a t i o n C o n t e x t H e l p e r

. g e t C o n f i g u r a t i o n C o n t e x t ( )
. getBean ( MathModule . c l a s s ) ;

S t r i n g inputFormat = r e q . g e t P a r a m e t e r ( " inputFormat " ) ;
S t r i n g outputFormat = r e q . g e t P a r a m e t e r ( " outputFormat " ) ;

S t r i n g t r e a t e d _ t e x t = r e q . g e t P a r a m e t e r ( " t e x t " ) ;

i f (

inputFormat == n u l l

| | outputFormat == n u l l
| |
t r e a t e d _ t e x t == n u l l

)

{

r e s u l t = " e r r o r : " ;
i f (

inputFormat == n u l l
r e s u l t += "

)

inputFormat

i f ( outputFormat == n u l l

)

r e s u l t += " , outputFormat
t r e a t e d _ t e x t == n u l l
r e s u l t += " ,

t r e a t e d _ t e x t

)

i f (

}
e l s e
{

i s not

s p e c i f i e d " ;

i s not

s p e c i f i e d " ;

i s not

s p e c i f i e d " ;

inputFormat . e q u a l s ( "LaTeX" )

i f (
&& outputFormat . e q u a l s ( "WolfMath" )
{

)

try
{

S t r i n g r e q u e s t = " T o E xp r e ss i o n [ \ " "

+ t r e a t e d _ t e x t
+ " \ " ,TeXForm , Hold ] " ;

r e s u l t = math . E v a l u a t e (

r e q u e s t

) ;

101

r e s u l t = r e s u l t . s u b s t r i n g ( 5 ,

r e s u l t . l e n g t h ( ) − 1 ) ;

}
catch ( MathException e )
{

r e s u l t = " e r r o r : " + e . g e t M e s s a g e ( ) ;
e . p r i n t S t a c k T r a c e ( ) ;

}

}
e l s e
i f (
&& outputFormat . e q u a l s ( "LaTeX" )
{

inputFormat . e q u a l s ( "WolfMath" )
)

try
{

S t r i n g r e q u e s t = "TeXForm [ HoldForm [ "+t r e a t e d _ t e x t+" ] ] " ;
r e s u l t = math . E v a l u a t e (

r e q u e s t

) ;

}
catch ( E x c e p t i o n e )
{

r e s u l t = " e r r o r : " + e . g e t M e s s a g e ( ) ;
e . p r i n t S t a c k T r a c e ( ) ;

}

r e s u l t = " e r r o r : unsupported c o n v e r s i o n " ;

}
e l s e
{

}

}

out . p r i n t l n (

r e s u l t

) ;

out . c l o s e ( ) ;

}

public void setMath ( MathModule math ) {

t h i s . math = math ;

}

protected MathModule math ;

}

CheckGrammarServlet.java

Данный сервлет был модифицирован. В данной дипломной ра-
боте в него была добавлена возможность возвращать сообщение с
описанием возникшей ошибки.
package s e r v l e t ;

import j a v a . l a n g . E x c e p t i o n ;

import j a v a x . s e r v l e t . S e r v l e t E x c e p t i o n ;
import j a v a x . s e r v l e t . h t t p . H t t p S e r v l e t ;
import j a v a x . s e r v l e t . h t t p . H t t p S e r v l e t R e q u e s t ;
import j a v a x . s e r v l e t . h t t p . H t t p S e r v l e t R e s p o n s e ;
import j a v a . i o . * ;
import grammar . CheckGrammar ;

102

/**
* Author : Zhukov Dmitry
* Date : 1 7 . 0 5 . 1 1
*/
public c l a s s CheckGrammarServlet extends H t t p S e r v l e t {

public void doPost ( H t t p S e r v l e t R e q u e s t

req , H t t p S e r v l e t R e s p o n s e r e s

)

throws S e r v l e t E x c e p t i o n ,

IOException

{

r e s . s e t C h a r a c t e r E n c o d i n g ( "UTF8" ) ;
P r i n t W r i t e r out = r e s . g e t W r i t e r ( ) ;

S t r i n g f i l e C o n t e n t = r e q . g e t P a r a m e t e r ( " f i l e c o n t e n t " ) ;

try {

CheckGrammar checkGrammar = new CheckGrammar ( ) ;
Boolean s t a t u s = checkGrammar . c h e c k V a l i d (

f i l e C o n t e n t

) ;

out . p r i n t l n (

s t a t u s . t o S t r i n g ( )

) ;

s t a t u s == f a l s e )

out . p r i n t l n ( checkGrammar . getErrorMsg ( )

) ;

i f (
{

}

}
catch ( E x c e p t i o n e ) {

out . p r i n t l n ( " e r r o r " ) ;
System . out . p r i n t l n ( e . g e t M e s s a g e ( )

) ;

}

out . c l o s e ( ) ;

}

}

103

