Аннотация

Отчет 45 с., 20 рис., 35 источников. Ключевые слова: верификация, сети Петри, вло-
женные сети Петри, параллелизм, проверка моделей, развертки, мультиагентные системы.
Темой данного исследования является исследования метода разверток в применении к

верификации вложенных сетей Петри.

Формализм вложенных сетей Петри используется для моделирования мультиагентных
систем – систем, состоящих из набора автономных агентов, имеющих свое собственное по-
ведение, взаимодействующие через механизмы синхронизации. Засчет наличия автоном-
ного поведения, мультиагентные системы имеют являются сильно распараллеленными.

При верификации параллельных и распределенных система часто возникает проблема
экспоненциального роста пространства достижимых состояний системы. Одной из при-
чин этого является наличие большого числа промежуточных состояний, получаемых в
результате рассмотрения всех возможных последовательных исполнений системы – интер-
ливинга (interleaving). Один из способов решения этой проблемы использует построение
(конечных префиксов) разверток сетей.

Развертки сетей (net unfoldings) используются для описания поведения системы в се-
мантике истинного параллелизма. В случае высокопаралленьных систем развертки (а точ-
нее их конечные префиксы) имеют размер меньший чем графы достижимости, тем самым
позволяя частично обойти проблему взрывоподобного роста числа достижимых состояний.
Основным результатом данной работы является определение разверток и ветвящихся
процессов для консервативных вложенных сетей Петри, моделирующих системы с неиз-
менных множеством агентов. Это определение используется для построения основанного
на развертках алгоритма верификации важных поведенческих свойств для консерватив-
ных вложенных сетей Петри.

Результаты данных исследований представлены в докладе, принятом на семинар Ve-
riﬁcation and Program Transformation, в рамках международной конференции Computer
Aided Veriﬁcation 2014, которая будет проходить в Вене в июле этого года.

Оглавление

Введение

1 Сети Петри и развертки сетей

1.1 Сети Петри . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.2 Развертки сетей . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.3 Библиографический комментарий . . . . . . . . . . . . . . . . . . . . . . . . .

2 Вложенные сети Петри и модели мультиагентных систем

2.1 Определение вложенных сетей Петри . . . . . . . . . . . . . . . . . . . . . . .
2.2 Примеры моделирования . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.3 Библиографический комментарий . . . . . . . . . . . . . . . . . . . . . . . . .

3 Развертки вложенных сетей Петри

3.1 Покомпонетная развертка сетей . . . . . . . . . . . . . . . . . . . . . . . . . .
3.2 Ветвящиеся процессы вложенных сетей Петри . . . . . . . . . . . . . . . . . .

4 Верификация с помощью разверток

4.1 Канонические префиксы разверток . . . . . . . . . . . . . . . . . . . . . . . .
4.2 Алгоритм генерации канонического префикса . . . . . . . . . . . . . . . . . .

Заключение

Список использованных источников

4

6
6
9
13

15
16
19
22

23
23
25

34
34
37

41

42

3

Введение

Данная работа просвещена тематики верификации формальных моделей распределенных
мультиагентных систем.

Мультиагентные системы – это системы, которые состоят из нескольких отдельных
автономных сущностей – агентов, имеющих свои цели и задачи, и коммуницирующих
друг с другом.

В современном мире, распределенные мульти-агентные и параллельные системы стано-
вятся все более популярными. Очень часто мы не замечаем их присутствие, но современ-
ные настольные и портативные компьютеры работают на мультиядерных процессорах,
и даже наша бытовая техника часто контролируется параллельными системами. Цена
ошибки в таких системах может быть очень велика. Вследствие этого возрастает спрос на
методы верификации таких систем. В большинстве случаев, невозможно верифицировать
реальную систему, поэтому объектами верификации являются модели систем. Таким об-
разом рабочий процесс разработки распределенных параллельных систем выглядит сле-
дующим образом: моделирование, верификация модели, имплементация. Это позволяет
обнаруживать ошибки на ранних стадиях разработки.

Популярным формализмом для моделирования распределенных систем являются сети
Петри. Вложенные сети Петри (nested Petri nets, NP-сети) [22, 35] являются расширени-
ем формализма сетей Петри высокого уровня, в соответствии с парадигмой “сети внутри
сетей”. Подход “сети внутри сетей” широко изучается в литературе, как подход для моде-
лирования активных объектов, мобильности и динамичности в распределенных системах
[1, 15, 20, 34].

NP-сети – это удобный формализм для моделирования динамических систем с взаимо-
действующими агентами: каждый агент представляется отдельной элементной фишкой,
в то время как агенты расположены в системной сети. Смежные уровни в NP-сетях вза-
имодействуют друг с другом с помощью механизма вертикальной синхронизации (одно-
временное срабатывание переходов в системной сети и в элементных сетях). Из-за гибкой
связанности многоуровневой структуры NP-сети являются эффективным формализмом
для моделирования мультиагентных систем ([7, 13, 24, 23, 3] для примера).

Мультиагентны системы являются сильно-параллельными (т.е. содержат высокий про-
цент параллелизма) за счет того, что агенты имеют почти независимое поведение. При
верификации систем параллельные поведения часто симулируют с помощь недетермини-

4

рованного последовательного исполнения (как если бы параллельная программа испол-
нялась на копмьютере с одним процессором). Такой подход заметно упрощает семантику
системы, но порождает другую проблему – огромное количество interleavings – способов
последовательного исполнения событий. Это приводит к так называемой проблеме взры-
вообразного роста числа достижимых состояний системы (state space explosion problem),
когда пространство состояний системы возрастает экспоненциально при добавлении новых
компонент. Для решения этой проблемы были разработаны различные методы, основы-
вающиеся на семантике т.н. “истинного параллелизма” (true concurrency semantics). Один
из самых популярных методов основан на конечных префиксах разверток сетей (ﬁnite
preﬁxes of unfoldings). Все последовательные исполнения системы можно собрать в дерево
вычислений (computation tree) – дерево, в котором вершины являются глобальными со-
стояниями системы, а дуги – событиями, которые связывают состояния со следующими
возможными состояниями. Развертка сети [29] являются в свою очередь собранием па-
раллельных исполнений (nonsequential process) системы. В случаях когда параллельная
система не имеет бесконечно длинных исполнений, размер развертки может быть силь-
но меньше размера графа достижимости, за счет того, что в развертке не учитываются
промежуточные состояния, которые возникают за счет interleaving’а. В случае когда па-
раллельная система имеет бесконечные исполнения, часто развертку можно сократить до
какого-то конечного префикса.

В данной работе представлено определение развертки и алгоритм построения конечных

префиксов развертки для подкласса вложенных сетей Петри.

В первой главе представлена общие понятия касающиеся сетей Петри и разверток.
Во второй главе описан формализм вложенных сетей Петри и подкласс консервативных
NP-сетей. В третьей главе содержится основной вклад автора, а именно, определение вет-
вящихся процессов и разверток для консервативных вложенных сетях Петри. В послед-
ней главе представлен алгоритм построения конечных префиксов разверток консерватив-
ных NP-сетей, который основан на теории канонических префиксов и контекста среза-
ния (cutting context). В работе показано, что определение разверток для консервативных
NP-сетей удволетворяет фундаментальному свойству разверток. Данное определение поз-
воляет переносить результаты теории канонических префиксов и контекста срезания на
консервативные вложенные сети Петри.

5

1 Сети Петри и развертки сетей

В этой главе будут рассмотрены базовые понятия, касающиеся тематики работы и исполь-
зуемые в тексте: сети Петри и развертки сетей.

1.1 Сети Петри

Сети Петри – это формализм, используемый для описания распределенных и параллель-
ных систем. Сеть Петри является направленным взвешенным графом, имеющим вершины
двух типов: позиции (графически обозначаются кружками) и переходы (графически обо-
значаются прямоугольниками). Внутри позиций могут находиться черные фишки. Часто,
фишки символизируют ресурсы или порядок исполнения (control ﬂow), а переходы – воз-
можные события. Переходы в сети Петри могут срабатывать, изменяя распределение фи-
шек по позициям сети. Распределение фишек по позициям сети называется маркировкой
сети и символизирует состояние системы, которая моделируется с помощью сети Петри.
Формальное определение сетей Петри и их поведения требует введения понятия муль-

тимножества.

Мультимножества. Пусть S – конечное множество. Мультимножество m над множе-
ством S является функцией m : S Ñ N. Неформально говоря, мультимножество является
множеством, в котором некоторые элементы могут присутствовать более одного раза. Для
двух мультимножеств m, m1 пишут m Ď m1 если @s P S : m(s) ď m1(s). Функции суммы и
вычитания мультимножеств определяются стандартным образом: @s P S : (m ` m1)(s) =
m(s) ` m1(s), (m ´ m1)(s) = max(0, m(s) ´ m1(s)).

Если f : S Ñ S1 – функция, то образом мультимножества m относительно f называется

ř

мультимножество f (m), определенное следующим образом: f (m)(s1) =

sP f ´1(s1) m(s).

R ´ OH

t1

2

H2O

R ´ O ´ R

Рис. 1: Химический процесс представленный в виде сети Петри

Определение 1.1 (Сеть Петри).
(Помеченная) Сеть Петри – это четверка (P,T, F, λ), где

6

• P, T – раздельные множества позиций и переходов, соответственно;
• F Ă (P ˆ T) Y (T ˆ P) Ñ N – отношения потока;
• λ : T Ñ Λ – частичная функция пометки.

Если сеть Петри не помечена, то последний компонент λ опускают.
Маркировкой сети N = (P,T, F, λ) является мультимножество над множеством позиций

P. Маркированная сеть Петри (N, M0) – это сеть, вместе с ее начальной маркировкой.

Для перехода t P T, дуга (x,t) называется входной дугой, и дуга (t, x) – выходной. Для
каждой вершины x P P Y T определено пред-множество ‚x = ty | (y, x) P Fu и пост-
множество x‚ = ty | (x, y) P Fu.

Говорят, что переход t в сети Петри N = (P,T, F) активен в маркировке M, если ‚t Ď
M. Активный переход может сработать, в результате чего получается новая маркировка
M1 = M ´ ‚t ` t‚ (обозначается как M tÝÑ M1). Маркировка M называется достижимой,
t2ÝÑ M2 ÝÑ
если существует (возможно пустая) последовательность срабатываний M0
¨¨¨ ÝÑ M из начальной маркировке сети в M. Через RM(N) обозначают множество всех
достижимых маркировок N.

t1ÝÑ M1

Маркировка M называется безопасной, если для всех позиций p P P, M(p) ď 1. Сеть
Петри называется безопасной, если все ее достижимые маркировки M P RM(N) безопас-
ны. В этой работе рассматриваются только безопасные сети Петри.

Граф достижимости маркированной сети Петри – это помеченный направленный
граф, вершинами которого являются достижимые маркировки сети, а дугами – переходы.
При этом, между двумя маркировками M, M1 существует дуга t тогда и только тогда,
когда M tÝÑ M1.
Анализ поведенческих свойств (верификация) сетей Петри. Одним из преиму-
ществ использования математических формализмов для моделирования систем является
то, что модели систем поддаются формальной верификации. Для верификации моделей,
представленных в виде сетей Петри, используются как структурные (анализ инвариан-
тов, ловушки), так и т.н. методы проверки моделей, которые основываются на анализе
графа достижимости. Можно привести некоторые примеры свойств, которые поддаются
проверке такими методам:

• Свойство достижимости: какая-то маркировка m (какое-то состояние системы) яв-

ляется достижимой в сети.

7

• Отсутствие дедлоков в системе: в любой достижимой маркировке в сети может сра-

ботать хотя бы один переход.

• Свойство срабатывания: какое-то событие, обозначенное переходом t, может произой-
ти в системе, т.е. существует такая достижимая маркировка, при которой переход t
является активным.

Однако, анализ полного пространства состояний часто бывает невозможен, ввиду боль-
шого размера графа достижимости. При композиции параллельных компонент количество
допустимых состояний системы может возрастать экспоненциально.

Такой рост объясняется тем, что в графе достижимости учитываются все возможные
последовательные исполнения параллельных компонент – interleavings. (Можно провести
аналогию с анализом пространства состояний и анализом поведения мультипоточной про-
граммы на одном процессоре.)

Для примера можно рассмотреть сеть Петри показанную на рис. 2. Граф достижимости
такой сети имеет 2k вершин, где k количество параллельных компонент в системе. Все
последовательные исполнения этой сети равноправны и одинаковы в том смысле, что
срабатывание перехода в одной из компонент не зависит от срабатывания переходов в
других компонентах. Таким образом, порядок срабатывания переходов в NX не играет
никакой роли.

. . .

Рис. 2: Сеть Петри NX. Размер граф достижимости такой сети возрастает экспоненциально
с добавлением параллельных компонент.

Некоторые методы решения проблемы экспоненциального роста размера пространства
состояний базируются на семантике истинного параллелизма. Семантика истинного па-
раллелизма – эта семантика, которая различает параллельное срабатывание двух событий
a и b ( a (cid:107) b, на языке процессных алгебр) от недетерминированного выбора срабатывания
событий a и b или срабатывания b и a (a.b ` b.a).

Один из таких подходов – развертки (unfoldings) – будет рассмотрен в следующей

части.

8

b

a

a

b

Рис. 3: a.b ` b.a

1.2 Развертки сетей

Развертки используются для задания параллельной семантики сетей Петри, и они со-
ответствуют полному набору параллельных исполнений сети. Формально, развертки за-
даются через специальный подкласс сетей Петри, которые носит название сети событий
(occurrence nets). В этой главе мы рассмотрим определения разверток и основные факты
о них.

Пусть N = (P,T, F) – сеть Петри. На вершинах P Y T сети определены следующие

отношения.

1. Отношение зависимости, обозначающееся ă, – это транзитивное замыкание F, а ď

– рефликсивное замыкание ă.

2. Отношение конфликта. Две вершины x, y P P Y T находятся в конфликте, если

x#y ðñ Dt,t1 P T.t (cid:44) t ^ ‚t X ‚t1 (cid:44) H ^ t ď x ^ t1 ď y.

3. Отношение параллельности, обозначающееся как co : две вершины параллельны, ес-

ли они не в конфликте, и ни одна из них не зависит от другой.

Для множества вершин B пишут co (B) если все вершины в B попарно параллельны.
Примеры двух вершин, зависящих одна от другой, конфликтующие друг с другом или
параллельные друг другу можно найти на рис. 4 (слева), на рис. 4 (справа) или на рис. 5,
соответственно.

Определение 1.2.
Сеть событий (occurrence net) - это безопасная сеть Петри ON = (B, E,G), где

1. В ON нет циклов.
2. @p P B : |‚p| ď 1.

9

Рис. 4: Иллюстрация к отношениям зависимости и конфликта

Рис. 5: Иллюстрация к отношению параллельности

3. @x P B Y E множество ty | y ă xu конечно.
4. @x P B Y E : (cid:32)(x#x).

Обычно позиции в сетях событий называют условиями, а переходы – событиями. Мно-

жество B Y E называют множеством вершин, и пишут x P ON, если x P B Y E.

Также нам пригодится следующая теорема, характеризующая отношение параллель-

ности:

Теорема 1.1.
Пусть S – множество позиций в маркированной сети событий ON. Следующие утвер-
ждения равносильны:

• Существует достижимая маркировка M, в которой S Ď M.
• co (S)

То есть, множество условий S может быть покрыто какой-либо маркировкой тогда и

только тогда, когда S попарно параллельно.

10

В сетях событий также определяют конфигурации – бесконфликтные множества вер-

шин, замкнутые относительно ă:

Определение 1.3.
Пусть ON – сеть событий. Конфигурацией ON называется множество вершин C, для
которого выполняется следующее:

1. @x, y P C, (cid:32)(x#y);
2. @x P C, если y ă x, то y P C.
Для каждой вершины e конфигурация res = tx | x ď eu называется локальной кон-
фигурацией. Также, если C – конфигурация, а E1 – множество событий, то под C ‘ E1
понимается множество C Y E1 Y E1‚, если оно является конфигурацией, и если C X E1 = H.
В таком случае C называют префиксом, а E1 – суффиксом.

Прежде чем перейти к определению ветявлящихся процессов, надо определить канони-
ческое представление сетей событий. По-существу, определяя каноническое представление
сетей событий и устанавливая одну четкую схему образования имен для позиций и пере-
ходов сети, мы “склеиваем” изоморфные сети в одну, избавляясь тем самым от проблем
связанных с рассмотрением изоморфных, но разных сетей.

Множество C канонических имен для маркированной сети Петри N = (P,T, F, M0) явля-
ется наименьшим множеством имен таким, что если x P PYT, а A – конечное подмножество
C, то (A, x) P C.

Тогда C-сеть – это сеть событий (B, E,G), где
• B Y E Ď C.
• @(A, x) P B Y E, ‚(A, x) = A.
Начальная маркировка C-сети является множеством t(H, x) | (H, x) P Bu.
Для каждой C-сети определяется функция (морфизм) h отображающая вершины C-

сети на вершины сети N:

Если для вершины x выполняется h(x) = y, то мы говорим что вершина x помечена y,

h((A, x)) = x

(1.1)

и обозначаем ее соответствующим образом графически.

Пусть S (конечное или бесконечное) множество C-сетей. Тогда объединение S опреде-

Ť

11

Ť

Ť

Ť

Ť

ляется покомпонентно:

S = (

(P,T,F,M)PS P,

(P,T,F,M)PS T,

(P,T,F,M)PS F,

(P,T,F,M)PS M).

Определение 1.4 (Ветвящийся процесс).
Для маркированной сети Петри N = (P,T, F, M0), множество ветвящихся процессов
определяется индуктивно.

1. Сеть событий (I,H,H), где I = t(H, p) | p P M0u, является ветвящимся процессом.
2. Пусть B1 – ветвящийся процесс, a M – достижимая маркировка B1, и M1 Ď M,
причем h(M1) = ‚t для какого-либо t из T. Пусть B2 – сеть, полученная добавлени-
ем события (M1,t) и условий t(t(M1,t)u, p) | p P t‚u к B1. Тогда B2 – ветвящийся
процесс.
Ť

3. Пусть BB (конечное или бесконечное) множество ветвящихся процессов. Тогда

BB – ветвящийся процесс.

Примеры ветвящихся процессов для сети Ns (рис. 6) можно увидеть на рис. 7–9.

p2

p3

t1

p1

p4

p5

p6

t5

t6

p7

t2

t3

t4

t7

Рис. 6: Сеть Петри Ns

p2

p3

t1

p1

t3

p5

Рис. 7: Ветвящийся процесс BP1 для сети Ns

Ветвящийся процесс B1 = ((P1, E1, F1), h1) называется префиксом ветвлящегося процес-

са B2 = ((P2, E2, F2), h2) (обозначается как B1 Ď B2), если P1 Ď P2 и E1 Ď E2.

Максимальный, с точки зрения Ď, ветвящийся процесс называется разверткой.
Развертка полностью представляет поведение оригинальной сети, что выражается в

следующей теореме.

12

p2

p3

t1

p1

t2

t3

t4

p4

p5

p6

Рис. 8: Ветвящийся процесс BP2 для сети Ns

p2

p3

t1

p1

t2

t3

t4

p4

p5

p6

t5

t6

p7

p7

t7

t7

Рис. 9: Ветвящийся процесс BP3 для сети Ns

Свойство 1.1 (Фундаментальное свойство разверток).
Пусть M – достижимая маркировка сети N. Пусть MU – достижимая маркировка
развертки U(N), причем h(MU) = M. Тогда

U в U(N), то существует срабатывание M tÝÑ M1 в N, такое что h(tU) =

tUÝÑ M1

U в U(N), такое что h(tU) =

tUÝÑ M1
U) = M1

Если MU
t ^ h(M1
Если M tÝÑ M1 в N, то существует срабатывание MU
t ^ h(M1

U) = M1

В следующей главе будет рассмотрел формализм вложенных сетей Петри. Именно для
этого формализма в работе будет разработано понятие разверток. Для разверток вло-
женных сетей потребуется теорема схожая с 1.1, т.е. развертки вложенных сетей должны
будут также полностью представлять поведение сети.

1.3 Библиографический комментарий

Сети Петри впервые были введены Карлом Адамом Петри и формализованы им в своей
диссертации [30]. В настоящее время сети Петри являются популярным формализмом и
объектом исследований. Заинтересованный читатель может обратиться к обзорным кни-
гам по тематике [31, 6].

13

Изначально, развертки были введены Нильсеном, Плоткиным и Винскелом в [29].
Строго говоря, авторы не использовали современное определение развертки, а работа-
ли со схожим понятием “event structure”. Работа была посвящена семантики истинного
параллелизма, и задачей авторов было установление соответствия между теорией сетей и
теорией доменов Скотта. В статье не обсуждались вопросы верификации.

МакМиллан [27] был первым, кто применил теорию разверток для решения проблем
верификации. В оригинальной работе МакМиллана обсуждалась верификации представ-
ленных в виде сетей Петри асинхронных электронных схем (asynchronous circuits), а имен-
но проблема проверки срабатывания перехода. Алгоритм МакМиллана в последствии был
улучшен и расширен для решения других проблем верификации [11, 28, 14, 5]. Алгоритм
верификации, изначально предназначенный для безопасных сетей Петри, также был при-
менен к другим моделям вычислений, таким как процессные алгебры [21, 2], синхронное
произведение конечных автоматов [12], сети Петри со временем [4], и других.

Другой важной ветвью в развитии теории разверток, было формулирование понятия
ветвящегося процесса (branching process) [8]. Если развертка, как объект, представляет
из себя все возможные полные параллельные исполнения сети, то ветвящийся процесс –
только частичные. Довольно часто, для решения проблем верификации требуется не вся
развертка сети (которая может быть бесконечной), а только конечный ветвящийся процесс
– префикс развертки.

Изначально, ветвящиеся процессы и алгоритмы нахождения конечных префиксов при-
менялись к (безопасным) классическим сетям Петри, однако в последствии эти понятия
были расширены и применены к сетям Петри высокого уровня [18]. В этой работе рас-
сматривается расширения понятия ветвящегося процесса на вложенные сети Петри.

Общий метод сокращения разверток, который абстрагируется от конкретной инфор-
мации, которую требуется сохранить в префиксе, был предложен в [19, 17]. Этот метод
базируется на понятии контекст срезания(cutting context), о котором пойдет речь в главе
4.

Дополнительный обзор литературы по теории разверток сетей Петри можно найти в

[9]. Книга [10] также является хорошим введением в тематику разверток.

14

2 Вложенные сети Петри и модели мультиа-
гентных систем

Сети Петри являются удобным формализмом для описания параллельных систем. Тем
не менее, за счет плоской структуры сетей, классические сети Петри не позволяют опи-
сывать простым образом модели мультиагентных систем: при моделировании сложных
мультиагентных систем классическими сетями Петри (или даже иерархическими сетями
Петри), модель становится большой и запутанной. Рудигер Вальк предложил концепцию
т.н. “сетей внутри сетей” (“nets within nets”) [33]. В рамках этого подхода фишки в сети
Петри имеют свою собственную структуру (которая также базируется на моделях сетей
Петри) и свое поведение. Такая концепция позволяет с большим удобством моделировать
системы с иерархией, мобильностью и инкапсуляцией.

На базе этого подхода существует несколько моделей, расширяющих классические сети
Петри, и они различаются семантикой и свойствами. В этой работе рассматривается фор-
мализм вложенных сетей Петри. Вложенная сеть Петри состоит из системной сети (system
net), в позициях которой находятся сетевые фишки (net tokens) – размеченные элементные
сети (element nets). Сетевые фишки могут совершать действия независимо от системной
сети, а могут координировать действия путем механизма вертикальной синхронизации.
Более конкретно, в данной работе рассматривается подкласс вложенных сетей Пет-
ри – консервативные вложенные сети Петри, основным свойством которого является то,
что сетевые фишки не могут появляться или исчезать. Такое ограничение было выбрано
автором по следующей причине. Классические развертки были определены для безопас-
ных сетей Петри, и консервативные вложенные сети являются в свою очередь аналогом
“безопасности” в мире вложенных сетей. Поскольку целью работы является предложить
определение разверток для вложенных сетей, то именно этот класс был изначально вы-
бран для рассмотрения.

Пример вложенной сети Петри можно увидеть на рис. 10. Эта сеть моделирует два
процесса, пытающиеся получить доступ к одному ресурсу. Справа на рисунке показана
системная сеть, в позиции Res которой находится ресурс – элементная сеть (обозначается
не залитым кружком). Сама элементная сеть представлена на правой части рисунка. Как
можно заметить, некоторые переходы в сетях помечены буквами. Таким образом обозна-
чаются метки вертикальной синхронизации. Так, переход Lock1 в системной сети может

15

p1

t1

p2

q1

t2

q2

x

x

Res

x

x

Lock1

L

x

p3

x

Release1

R

p4

L Lock2
x

q3

x
R Release2

q4

a1

Lock

L

a2

SomeW ork
a3

Release

R

Рис. 10: NP-сеть NP1

сработать только если в позиции p2 находится черная фишка, а в позиции Res находится
системная фишка, в которой активен переход Lock.

В следующей части будет формально описаны вложенные сети Петри и их поведение.

2.1 Определение вложенных сетей Петри

Для начала, зафиксируем некоторые множества. Пусть Type – множество типов, Var –
множество типизированных переменных, а Lab – множество пометок. Тогда определение
вложенной сети Петри выглядит следующим образом.

Определение 2.1 (Вложенные сети Петри (NP-сети)).
Вложенная сеть Петри NP – это кортеж (SN, (EN1, . . . ,ENk), υ, λ,W ), где

• SN = (PSN,TSN, FSN) сеть Петри, которая называется системной сетью.
• для каждого i = 1, k, ENi = (PENi ,TENi , FENi ) – сеть Петри, которая называется
элементной сетью, где все множества позиций и переходов не пересекаются; также
считается что каждой элементной сети присвоен тип из Type.

• υ : PSN Ñ Type Y t‚u – функция типизации позиций.
• λ : TNP Ñ Lab – частичная функция разметки позиций, где TNP = TSN Y TEN1 Y¨¨¨Y
TENk ;
• W : FSN Ñ Var Y t‚u – функция разметки дуг, которая согласована с типами пози-

ций и переменных.

16

Маркированная элементная сеть называется сетевой фишкой.
Для каждой вложенной сети Петри определяется множество Anet = t(EN, m) | Di =

1, . . . , k : EN = ENi, m P M(ENi)u всех возможных сетевых фишек, и A = Anet Y t‚u.

Маркировка M во вложенной сети Петри NP – это функция, которая сопоставляет

каждому p P PSN некое мультимножество M(p) над A.

Пусть t – переход в SN, ‚t = tp1, . . . , piu, t‚ = tq1, . . . , qju. Тогда,

W (t) = tW (p1,t), . . . ,W (pi,t),W (t, q1), . . . ,W (t, qj)u

– множество переменных на дугах, смежных с t. Связывание для t – это функция b,

которая присваивает каждой переменной из W (t) значение из A.

Переход t называют активным в маркировке M со связыванием b, если @p P ‚t

:

W (p,t)(b) Ď M(p).

Активный переход может сработать, в результате чего получается новая маркировка

M1 (M ÝÑ M1), такая что M1(p) = (M(p)zW (p,t)(b)) Y W (t, p)(b).

Существует три типа шагов во вложенных сетях Петри.
• Элементно-автономный шаг. Пусть t – непомеченный переход в одной из системных
сетей. Тогда срабатывание перехода t определяется стандартными правилами сраба-
тывания перехода в сетях Петри.

• Системно-автономный шаг. Пусть t – непомеченный переход в системной сети. Сраба-
тывание t определяется правилами срабатывания переходов в сетях высокого уровня
(например, см [16]), как описано выше.

• Шаг синхронизации. Пусть t – помеченный λ переход в системной сети, который
активен в маркировке M со связыванием b. Пусть α1, . . . , αk P Anet – сетевые фишки,
участвующие в срабатывании перехода t. Тогда t может сработать если в каждом из
αi существует активный переход ki, также помеченный λ. При этом, при срабатыва-
нии перехода t должны сработать переходы ki , 0 ă i ď k.

Вложенная сеть Петри называется безопасной, если в каждой ее достижимой марки-
ровке в системной сети в каждой позиции находится не более одной фишки, а также во
всех сетевых фишках находится не более одной черной фишки в каждой из позиций. В
данной работе рассматриваются только безопасные NP-сети.

В данной работе рассматривается определенный подкласс вложенных сетей Петри –

консервативные NP-сети.

17

Определение 2.2.
NP-сеть N = SN, (EN1, . . . ,ENk), υ, λ,W ) называется консервативной, если

1. Для каждого t P TSN и для каждого p P ‚t, D!p1 P t‚ . W (p,t) = W (t, p1) или W (p,t) = ‚
2. Для каждого t P TSN и для каждого p P t‚, D!p1 P ‚t . W (p1,t) = W (t, p) или W (p,t) = ‚

3. N безопасна

Данное определение устанавливает, что сетевые фишки в системной сети могут совер-
шать внутренние действия, но новые сетевые фишки не могут появляться, а существующие
не могу уничтожаться.

Идентифицированные сетевые фишки. В консервативных вложенных сетях, вме-
сто того что бы рассматривать просто сетевые фишки (маркированные элементные сети
находящиеся в позициях системной сети), имеет смысл рассматривать идентифицирован-
ные сетевые фишки. Так как количество сетевых фишек в сети не меняется, каждой из
них можно присвоить идентификатор. Формально, идентифицированная сетевая фишка
– это тройка xI,EN, µy, где I является уникальным идентификатором фишки, ENj пред-
ставляет из себя структуру фишки (т.е. элементная сеть из множества tEN1, . . . ENku), и µ
– маркировка ENj. Представляя фишки таким образом, можно различать сетевые фиш-
ки с одинаковой структурой и маркировкой. Это пригодится в главе 3 при определении
ветвящихся процессов для консервативных вложенных сетей Петри.

Под NTok будет пониматься множество всех идентифицированных сетевых фишек в
данной сети. С помощью τ(ηi) = τ((I,ENi, µ)) будет обозначаться тип сетевой фишки
(ENi, µ). Поскольку далее в тексте будут упоминаться только консервативные вложенные
сети Петри, слово “идентифицированные” будет часто опускаться.

По системной сети SN, множеству сетевых фишек NTok и функции M, сопоставляющей
позиции SN элементы из NTok Y t‚u, можно легко восстановить множество элементных
сетей и маркировку вложенной сети. Это является альтернативным заданием вложенной
сети Петри, который будет использован в работе.

По маркировке M вложенной сети NP определим проекции маркировки на разные

компоненты NP:

1. Проекция M на системную сеть SN, обозначается как M(cid:22)SN, это маркировка плоской
сети SN, полученная заменой всех сетевых фишек на черные фишки, т.е. M(cid:22)SN(p) =
|M(p)|.

18

2. Проекция M на сетевую фишку ηk = xidk,ENk, µky, обозначается как M(cid:22)ηk , это просто

µk.

Дополнительную информацию по вложенным сетям Петри можно получить в [35].

2.2 Примеры моделирования

В этой секции рассматривается два примера использования вложенных сетей Петри при
моделировании мультиагентных систем. Первый пример представляет из себе простой од-
норанговый протокол, и он является иллюстрационным примером из статьи [7]. Второй
пример это инструмент для моделирование беспроводных сенсорных сетей, который опи-
сан в [3].

P2P протокол. Данный пример представляет из себя вложенную сеть Петри, модели-
рующую протокол одноранговой сети (peer-to-peer, p2p).

На рис. 11 можно увидеть системную сеть SN, отвечающую за сам протокол, а так же
элементные сети, моделирующие сидов E1, предоставляющих данные, пиров E2, потребля-
ющие данные, и безопасные каналы передачи E3. Сиды и пиры моделируются абстрактно,
так как в данной модели описывается только взаимодействие агентов.

Сид E1 может быть в одном из состояний “готов к загрузке” p1, “загрузка в процессе”
p2 или “ре-инициализация” p3. В качестве переходов в сиде выступают события “загрузка
началась” t1, “загрузка закончилась” t2 и “ре-инициализация закончилась” t3. Пир может
находится в состоянии “готов к загрузке” p4 или “загрузка в процессе” p5. Событиями пира
являются “загрузка началась” t4 и “загрузка закончилась” t5.

Канал связи (pipe) позволяет улучшать качество загрузки данных за счет буферизации
данных. Канал E3 имеет интерфейсы для сидов (p6,p7) и для пиров (p12,p13), а также
двухместный буфер (p8,p9,p10,p11). Изначально, канал находится в состоянии ожидания
(p15), когда сид и пир начинают взаимодействие (t11). Сид может начать (t6) передавать
данные (p6) в буфер, а пир начать ожидания порции данных. Когда передача данных
заканчивается (t7), сид возвращается в состояние ожидания (p7), и одно место в буфере
заполнено (p8).

Затем первая порция данных передается (t8) во второе место буфера, в результате чего
первое место буфера становится свободным (p9). Когда пир загружает (t9) первую порцию
данных из второго места буфера (p10), второе место буфера становится пустым (p11), и
пир начинает ожидать второй порции данных (p13).

Когда сид загрузил все свои данные, канал ожидает передачи данных к пиру (p13),

19

Рис. 11: Вложенная сеть Петри, моделирующая P2P протокол [7]

а затем перемещается (t12) состояние ре-инициализации (p14). Когда ре-инициализация
заканчивается (t10), канал завершает цикл трансфера и готов заново принимать и пере-
давать данные (p15).

Системная сеть содержит начальные и конечные пулы для сидов, пиров и каналов

20

p1p2p3t1λt2λt3λp4p5t4λt5λp6p7p8p9p10p11p12p13p14p15t6t7t8t9t10λt11λt12λp16p17p18p19p20p21p22p23t14λxyzxyzt15λxxt16λxyzxyzt17λzzα1oftypeE1(seed):α3oftypeE2(peer):α5oftypeE3(pipe):SN(protocol):(p16, p17 и p18 соответственно). В начальном пуле агенты готовы к взаимодействию, а в
конечном пуле агенты проходят ре-инициализацию.

Данная модель является высокоуровневым представлением протокола, и в ней не учи-
тываются такие вещи как чрезвычайны ситуации (например сбои канала) и их обработка.

Моделирование беспроводных сенсорных сетей. В работе [3] описывается инстру-
мент для моделирования беспроводных сенсорных сетей на базе вложенных сетей Петри.
Беспроводные сенсорные сети (Wireless sensor networks, WSN) – это распределенные
компьютерные сети, состоящие из беспроводных сенсоров, которые считывают какую-либо
информацию, обмениваются ей друг с другом и передают ее на хост (сервер). Часто сен-
соры используются для мониторинга физических условий окружающей среды, таких как
температура, атмосферное давление и пр. Одним из применений беспроводных сенсорных
сетей является наблюдение за дикими животными. Ученые, с помощью сенсорных сетей
с камерами пытаются определить тропы животных.

Описываемый в статье инструмент позволяет пользователю задавать беспроводную
сенсорную сеть, а затем конвертировнять ее во вложенную сеть Петри, с целью анализа.
Конвертация сенсорной сети в NP-сеть происходит следующим образом. Сначала, каж-
дому сенсорному устройству сопоставляется по две позиции, соединенные переходом, как
можно увидеть на рис. 12. В одной из позиций находится слетевшая фишка, описывающее
поведение сенсора, в другой – может находиться обычная фишка, обозначающая сигнал.
Затем, сенсоры, находящиеся рядом, соединены переходами. Поведение отдельных сенсо-
ров задается пользователем в виде элементных сетей.

Рис. 12: Вложенная сеть Петри, моделирующая WSN [3]

Применение NP-сетей. В данной главе были представлены два примера применения
формализма вложенных сетей Петри к системам из разных сфер.

21

Эти примеры показывают, что вложенные сети Петри являются удобным формализмом
для моделирования мультиагентных системы. Если бы мы моделировали такие системы с
помощью плоских сетей, то полученные модели были бы очень громоздкими. За счет того,
что вложенные сети Петри позволяют задавать поведение агентов отдельно от протокола
общего поведения, полученные модели являются обозримыми.

Эти примеры хорошо подходят для моделирования с помощью формализма с жесткой
иерархией и value-семантикой. Одно поведение (одну сеть) задается нескольким агентам
сразу. Такое было бы невозможно сделать в формализмах гиперсетей [26] или TSA-систем
[32].

2.3 Библиографический комментарий

Одной из ранних разработок в области “nets within nets” является формализм Объектных
сетей, который позже был сужен до Элементарных Объектных Сетей Петри (Elementary
Object Nets, EON) [33], основанный в определенной степени на идеях объектно-ориентированного
программирования. Сети, используемые как фишки, в EON называются сетевыми фиш-
ками, и они имеют свою собственную структуру и поведение.

Другой формализм, основывающийся на парадигме “сети-внутри-сетей” – это Гиперсе-
ти [26, 1, 25]. Гиперсеть – это набор агентов, вместе с гипермаркировкой – распределением
агентов по позициям сети, каждый из которых является произведением конечных автома-
тов (или консервативной сетью Петри, в случае обобщенных гиперсетей). Каждый агент
может находится в любом из других агентов (за исключением циркулярных ситуаций), и
такая иерархия может меняться во время исполнения.

Формализм, который рассматривается в этой работе – это вложенные сети Петри
[22, 13, 24, 35]. Этот формализм был выбран для изучения по нескольким причинам:
во-первых, это удобство для моделирования большого класса систем; во-вторых, вложен-
ные сети Петри являются не Тьюринг-полными, но более выразительными чем обычные
сети Петри, что делает некоторое количество проблем разрешимыми (например, проблему
покрытия [35]). Вложенные сети Петри отличаются от других формализмов “сети-внутри-
сетей” и другими свойствами. Например, в отличии от uTSA-систем ([32]), вложенные сети
Петри имеют т.н. value semantics, что означает что взаимодействие с агентами (сетевыми
фишками) происходит локально путем прямого взаимодействия с фишками, а не глобаль-
но через специальные идентификаторы. Также, в отличии от Гиперсетей, вложенные сети
Петри имеют статическую иерархию, которая не может изменяться во время исполнения
сети.

22

3 Развертки вложенных сетей Петри

В этой главе будут рассмотрены два варианта определения разверток для консерватив-
ных вложенных сетей Петри: покомпонентная развертка, в которой каждый компонент
разворачивается отдельно, но остается компонентом вложенной сети, и прямая развертка
вложенной сети Петри в сеть событий. Как можно будет увидеть, второй вариант явля-
ется более привлекательным, поскольку именно он позволяет применить метод разверток
для верификации вложенных сетей Петри.

3.1 Покомпонетная развертка сетей

Поскольку в консервативных NP-сетях сетевые фишки не создаются и не уничтожаются,
естественным будет рассмотреть раздельные развертки всех индивидуальных компонент
сети и их взаимодействия. Композициональность такой конструкции является интересной
и может сыграть положительную роль при верификации. Такая “развертка” (далее в тек-
сте называющаяся “покомпонентной разверткой”, component-wise unfolding), безусловно,
должна иметь свойство, схожее с фундаментальной теоремой разверток (свойство 1.1).

Покомпонентная развертка NP-сети N = (SN,NTok = tη1, . . . , ηku, υ, λ,W, M 0), это NP-
сеть UC(N) = (UC(SN),UC(NTok),UC(λ),UC(W ),UC(M 0)), полученная разверткой каждого
компонента сети в отдельности:

• UC(SN) – это развертка плоской сети SN с начальной маркировкой M 0
• UC(NTok) – это множество сетевых фишек, каждая из которых развернута по от-

(cid:22)SN;

дельности.

Пусть h : PUC (SN) Y TUC (SN) Y0ăiďk PUC (ηi ) Y PUC (ηi ) Ñ PSN Y TSN Y0ăiďk Pηi Y Pηi –

объединение всех морфизмов из разверток в индивидуальные компоненты. Т.е.

$’&’%hSN(x),

hηi (x),

h(x) =

если x P PUC (SN) Y TUC (SN)
если x P PUC (ηi ) Y TUC (ηi )

Тогда функции UC(W ),UC(λ) и UC(M 0) определяются следующим образом:

• UC(W )(x, y) = W (h(x), h(y));
• UC(λ)(t) = λ(h(t)).

23

• UC(M 0)(p) = M 0(h(p)) если p минимальный элемент (с точки зрения ă) в множестве

tp1 | h(p1) = h(p)u, или UC(M 0)(p) = H в противном случае.

Прежде чем исследовать поведенческие свойства такой развертки, требуется расши-
рить определение функции h (морфизма), что бы оно включало также NP-маркировки:
Пусть MU – маркировка UC(NP), тогда соответствующая ей маркировка h(MU) опре-

деляется следующим образом:

$’&’%h(S),

H,

h(MU)(p) =

если Dp1 . h(p1) = p ^ MU (p1) = S (cid:44) H
в противном случае

(3.1)

Важно заметить, что функция определенная в уравнении 3.1 является корректной: если
выполняется первое условие уравнение, то такое p1 уникально, ведь никакие два элемента
из множества tp1 | h(p1) = xu не параллельны и, следовательно, не могут быть помечены
ни в какой достижимой маркировке одновременно.

Теперь все готово для формулирования и доказательства теоремы о соответствии по-

ведения NP-сети и ее покомпонентной развертки.

Теорема 3.1.
Пусть NP – консервативная NP-сеть. Пусть M – достижимая маркировка NP, а MU –
достижимая маркировка UC(NP), такая что h(MU) = M. Тогда выполняется следующее:
U в UC(NP), то существует шаг M TÝÑ M1 в NP,

1. Если существует шаг MU
такой что h(TU) = T и h(M1

TUÝÑ M1
U) = M1.

2. Если существует шаг M TÝÑ M1 в NP, то существует шаг MU

такой что h(TU) = T и h(M1

U) = M1.

TUÝÑ M1

U в UC(NP),

То есть поведение сети NP эквивалентно поведению ее покомпонентной развертки.

Доказательство. Рассмотрим первое утверждение и шаг синхронизации. Остальные слу-
чаи рассматриваются подобным образом.

Для каждого из компонент UC(Ni),i P IT, занятого в срабатывании TU, существует

переход ti P TU. Также, существует ts P TU, принадлежащий системной сети.

Для каждого ti существует позиция pi в системной сети где находится фишка UC(Ni). В
таком случае, ‚ti Ď MU (pi). Более того, если срабатывание T переносит фишку UC(Ni) из pi
в позицию p1
‚. Это значит, что в системной фишке UC(Ni) (как

i) = MU (pi)z‚ti Y ti

i, то M1

U (p1

24

в отдельном компоненте) MU (pi) tiÝÑ M1
разверток для плоских сетей, h(MU (pi)) = M(h(pi)) h(ti )ÝÝÝÑ M1(h(p1

U (p1

i). Следовательно, по фундаментальной теореме

i)) = h(M1

U (p1

i)) в Ni.

Также можно заметить, что существует шаг MU

U в UC(SN). Следовательно су-
ществует шаг h(MU (cid:22)SN)
U (cid:22)SN) в SN. Вместе с тем фактом, что UC сохраняет
метки на переходах, получаем что переход T = h(TU) активен в маркировке M сети NP.
Нетрудно заметить что M1 совпадает с h(M1
(cid:3)

h(t S )ÝÝÝÑ h(M1

U).

t SÝÑ M1

Не смотря на то, что вышеописанная конструкция имеет ряд привлекательных тео-
ретических свойств, ее прямая применимость к процессу композициональной проверки
моделей не вполне очевидна. Более точно, не вполне понятно, каким образом анализ раз-
верток индивидуальных компонент может помочь анализу развертки всей сети целиком.
Так, например, не-живость хотя бы одной из компонент сети (свойство живости можно
проверить на развертках индивидуальных компонент) ведет к не-живости всей сети це-
ликом, однако живость всех компонент сети не обязательно приводит к живости сети в
целиком1.

В следующей секции будет рассмотрен другой подход к определению разверток NP-
сетей, в котором поведение NP-сети представляется на прямую одной общей сетью собы-
тий.

3.2 Ветвящиеся процессы вложенных сетей Петри

В этой части будет рассмотрены развертки консервативных вложенных сетей Петри непо-
средственно в сети событий. Определение развертки будет дано через понятие ветвящегося
процесса.

Для удобства зафиксируем на протяжение всей главы консервативную вложенную сеть
Петри NP = (SN, (EN1, . . . ,ENk), υ, λ, M 0), где SN = (PSN,TSN, FSN), ENi = (PENi ,TENi , FENi ),
0 ă i ď k.

Для начала определим элементно-индексированные C-сети Петри. Данная конструк-
ция похожа на каноническое представление ветвящихся процессов плоских сетей Петри,
однако в случае элементно-индексированных C-сетей Петри, каждая позиция которой по-
мечена сетевой фишкой (ее идентификатором).
Определение 3.1 (Элементно-индексированные C-сети).
Элементно-индексированная C-сеть Θ – это C-сеть, в которой каждая позиция помечена
идентификатором сетевой фишки.

1Данный вопрос был изучен в [7]

25

Формально, множество канонических имен C определяется рекурсивно следующим

образом:

Ť
Ť

ENi

C, то (X, x, ηi) P C;

• Если x P (

PENiYPSN ), ηi P NTokYt‚u, и X является конечным подмножеством

ENi

TENi Y TSN ), и X – конечное подмножество C, то (X, x) P C.

• Если x Ă (
Тогда индексированная C-сеть (P,T, F, M0) – это сеть Петри, где
1. P Y T Ď C;
2. Если p = (X, x, N) P P, то ‚p = X;
3. Если t = (X, x) P P, то ‚t = X;
4. (X, x) P M0 тогда и только тогда, когда X = H.
Так же как и в случае простых C-сетей (ф-л. (1.1)), определяется функция h, сопо-

ставляющая вершинам сети событий вершины вложенной сети:

$’&’%t

h(x) =

если x = (A,t)

(3.2)

p

если x = (A, p, ηi)

Объединение элементно-индексированных C-сетей определяется так же как и объеди-

нение простых C-сетей – покомпонентно.

Вообще говоря, позиция (A, p,i) соответствует либо позиции p в сетевой фишке с иден-
тификатором i, либо позиции p в системной сети, в которой находится сетевая фишка
с идентификатором i. Графически, позиция (A, p,i) обозначается как обычная позиция с
именем (p,i).

Для каждой элементно-индексированной C-сети Θ и сетевой фишки ηi определено
множество Path(Θ, ηi) позиций, которые соответствуют позициям в системной сети, по-
меченные ηi, и смежные к ним переходы. То есть Path(Θ, ηi) содержит все (и только их)
позиции вида (A, p, ηi), а так же переходы ‚(A, p, ηi). Также, Path(Θ, S, ηi) будет обозначать
Path(Θ, ηi) X S. Эта функции называется Path, поскольку в случае ветвящихся процессов,
Path(Θ, ηi) обозначает “путь” фишки ηi в сети Θ. Так, на рис. 16 все элементы Path(BP1, N2)
обозначены синим цветом.

Также, для каждого множество S вершин элементно-индексированной C-сети Θ опре-

делено мультимножество пометок:

26

y

y

p2

x
αt1

x

p1

p3

z

z

t2

β

k2

k1
α

q1

q2

k3
β

Рис. 13: Сеть NP2: системная сеть

Рис. 14: Сеть NP2: Элементная сеть

Labs(S) = tλ(t) | (A,t) P Su

Возвращаясь к предыдущему примеру, Labs(Path(BP1, N2)) = tαu.
Также следует определить понятие смежного места. В соответствии с определением
2.2, для каждой пары (p,t) P PSN ˆ TSN, где υ(p) (cid:44) ‚, существует уникальная позиция p1,
такая что W (p,t) = W (t, p1) или W (p1,t) = W (t, p). Такая позиция p1 называется смежной к

p через t и обозначается как x|p,ty. Например, на рис. 13, смежной к p2 через t1 является
позиция x~p2,t1y = p3.

Теперь все готово для определения элементно-индексированных ветвящихся процессов
(далее просто “ветвящихся процессов”, где это позволительно использовать без потери
смысла).

Определение 3.2 (Элементно-индексированные ветвящиеся процессы).
Множество элементно-индексированных ветвящихся процессов для NP – это наимень-
шее множество элементно-индексированных C-сетей, которое удовлетворяет следую-
щим требованиям:

1. Пусть

C = t(H, p, ηi) | p P PSN, ηi P M 0(p)u Y t(H, p, ηi) | ηi P NTok, p P M 0
(cid:22)ηi

u

множество позиций. Тогда сеть Θ = (C,H,H), состоящая из позиций C и не имею-
щая никаких переходов, является ветвящимся процессом. Такой процесс называют
начальным.

2. Пусть Θ – ветвящийся процесс, а B – множество позиций в Θ. Если B удовле-
творяет правилу PosEN (рис. 15), то тогда сеть, полученная путем добавления
перехода e и позиций C к Θ, является ветвящимся процессом.

27

3. Пусть Θ – ветвящийся процесс, а B – множество позиций в Θ. Если B удовле-
творяет правилу PosSN (рис. 15), то тогда сеть, полученная путем добавления
перехода e и позиций C к Θ, является ветвящимся процессом.

4. Пусть Θ – ветвящийся процесс, а B и BE – множество позиций в Θ. Если B и
BE удовлетворяют правилу PosSync (рис. 15), то тогда сеть, полученная путем
добавления перехода e и позиций C к Θ, является ветвящимся процессом.

5. Пусть BS является (конечным или бесконечным) множеством ветвящихся про-

цессов. Тогда объединение

BS является ветвящимся процессом.

Ť

В правилах (2)-(4), переход e называют возможным расширением Θ.

Предикат SyncCond(BE, E, I, Θ, (B,t)) является истинным при тогда и только тогда, ко-

гда выполняются следующие условия

Ť
iPIt(yj,cj, ηi) | j P Ji, ηi = (idi,ENi, µi) P NTok,ci P PENiu ^ co(BE), т.е. BE –

1. BE =

множество достижимых условий, соответствующих позициям в сетевых фишках;

2. E = tti P TENi | i P I, (idi,ENi, µi) P NToku, т.е. E – подмножетсво переходов в каждой

Ť
iPItcj | j P Ji, ηi P NToku

из сетевых фишек;
3. @e P E, λ(e) = λ(t)
4. ‚E =
5. @i P I, ηi P NTok Ñ Labs(Path(Θ,rBs, ηi)) = Labs(rt(yj,cj, ηi) | j P Jius), т.е. список по-
меток на пути ηi в конфигурации rBs такой же, как список пометок в конфигурации
rcis.

Правила, обозначенные в рис. 15, можно понимать так же и с операционной точки
зрения: правила PosEN, PosSN и PosSync применяются для получения событий (перехо-
дов), соответствующие элементно-автономным, системно-автономным и синхронизирую-
щим шагам, соответственно.

Для примера, рассмотрим NP-сеть NP2, изображенную на рис. 13 и 14. В этом примере
в системной сети (рис. 13) находятся две системные фишки одного типа (рис. 14). При
срабатывании перехода t1 системная фишка из позиции p1 переходит в позицию p2, а
фишка из позиции p2 переходит в позицию p3. Возможные ветвящийся процессы NP2
изображены на рис. 16 и 17.

28

B = t(xi, bi, ηk) | i P Iu

co(B)

e = (B,ttu)

and C =

pPt‚ (e, p, ηk)

Ť
t P Tηk , λ(t) = ˚

‚t = tbi | i P Iu

PosEN

B = t(xi, bi, ηi) | i P Iu

co(B)
e = (B,ttu)

t P TSN, λ(t) = ˚

and C = t(e,x}bi,ty, ηi) | i P I, ηi (cid:44) ‚uY

‚t = tbi | i P Iu

t(e, b,‚) | b P t‚, υ(b) = ‚u

PosSN

B = t(xi, bi, ηi) | i P Iu

co(B)
e = (B Y BE,ttu Y E)

t P TSN, λ(t) (cid:44) ˚
‚t = tbi | i P Iu

and C = t(e,x}bi,ty, ηi) | i P I, ηi (cid:44) ‚uY

SyncCond(BE, E, I, Θ, (B,t))

PosSync

t(e, b,‚) | b P t‚, υ(b) = ‚uY
t(t1,c1

i , ηi) | i P I, ηi (cid:44) ‚,c1

i P Pηi ,c1

i P ti

‚u

Рис. 15: Правила для построения возможных расширений ветвящихся процессов

(q1, N2)

(p2, N2)

(p1, N1)

(q1, N1)

(q2, N2)

k2

(q2, N2)

(p3, N2)

tt1, k1u

α

(p2, N1)

(q2, N1)

(q2, N1)

k2

Рис. 16: BP1: ветвящийся процесс NP2

29

(q1, N2)

(p2, N2)

(p1, N1)

(q1, N1)

(q2, N2)

k2

(q2, N2)

(q1, N2)

tt2, k3u

(p3, N2)

β

(p3, N2)

k2

(q2, N2)

tt2, k3u

. . .

β

. . .

tt1, k1u

α

(p2, N1)

(q2, N1)

(q2, N1)

k2

Рис. 17: BP2: ветвящийся процесс NP2

Свойства элементно-индексированных ветвящихся процессов. Далее будут сфор-
мулированы и доказаны важные свойства, касающиеся ветвящихся процессов, как они
были определены.

Утверждение 3.1.
Каждый элементно-индексный ветвящийся процесс является сетью событий.

Доказательство. Пусть Θ = (PΘ,TΘ, FΘ) – элементно-индексированный ветвящийся про-
цесс. Что бы доказать что Θ является сетью событий, надо удостовериться что для Θ
выполняются все условия, указанные в определении 1.2.

1. Это условие выполняется потому что Θ является элементно-индексированной C-

сетью Петри.

2. Можно удостовериться что это условие выполняется, посмотрев на каждой из ин-
дуктивных правил и заметив, что при применении каждого из правил каждая новая
позиция имеет лишь один пре-переход.

3. Выполнимость этого условия следует прямо из индуктивных правил возможных рас-

ширений.

4. Докажем выполнимость этого условия от обратного. Пусть такая наименьшая (с
t ă x ^ t1 ă

точки зрения ă) вершина x P PΘ Y TΘ, что x#x. Тогда Dt,t1 P TΘ.

30

x ^ ‚t X ‚t (cid:44) H (по определению отношения конфликта). Если x является позицией,
то, по пункту 2, существует единственный переход y, такой что ‚x = tyu и y#y
(x не может не иметь пред-переходов, так как в соответствии с гипотезой t ă x и
t1 ă x). Более того, x#x ðñ y#y. Поэтому без ограничения общности, достаточно
рассмотреть случай когда x – переход.
Если x – переход, то он имеет вид (B,t), и существуют такие различные b, b1 P B, что
t ă b, t1 ă b1. В таком случае b#b1, т.е. (cid:32)co(B). Однако, такая ситуация невозможна,
в соответствии с правилами возможных расширений.

(cid:3)

Пусть B – ветвящийся процесс NP. Следующим шагом мы определим функцию ˜h,
расширяющую функцию h из формулы 3.2, сопоставляющую каждой маркировке ветв-
лящегося процесса B маркировку NP. В случае плоских сетей специального расширения
определения морфизма не требовалось, так как маркировкой плоской сети Петри являет-
ся мультимножество позиций, и образ мультимножества позиций относительно функции
h определяется стандартным образом. В случае вложенных сетей, маркировки представ-
ляют из себя функции из позиций системной сети в мультимножества сетевых фишек.
Можно заметить, что в случае когда в сети отсутствуют сетевые фишки, определение
совпадает просто с функцией h.

$’’’’’&’’’’’%

˜h(M)(p) =

t‚u
ttq | q P Pηi ,DA, (A, q, ηi) P Muu
H

если υ(p) = ‚ и h(M)(p) ą 0
если υ(p) = τ(ηi) и DA, (A, p, ηi) P M
в противном случае

(3.3)

Допустим, M – маркировка BP1, изображенная на рис. 16. Тогда ˜h(M) – маркировка

NP2, изображенная на рис. 18.

Такое определение корректно, поскольку для каждой сетевой фишки ηk в каждой до-
стижимой маркировке B, лишь только одна позиция может быть помечена ηk. Поскольку
каждый ветвящийся процесс является сетью событий, то каждая достижимая маркировка
является попарно-параллельным множеством. Следовательно, требуется доказать следу-
ющую лемму:

Лемма 3.1.
Пусть ηk является системной фишкой, а θ – ветвящимся процессом. Если pi, pj P PSN,
pi (cid:44) pj и (A, pi, ηk), (B, pj, ηk) P θ, то (cid:32)((A, pi, ηk) co (B, pj, ηk)).

31

y

y

p2

x
αt1

x

p1

p3

z

z

t2

β

k2

k1
α

k2

k1
α

q2

q2

k3
β

k3
β

q1

q1

Рис. 18: NP-сеть NP2 с маркировкой ˜h(M) (рис. 16). Слева направо, сверху вниз: системная
сеть SN, находящаяся в p1 системная фишка N1, находящаяся а p2 системная фишка N2.

Доказательство. Доказательство проводится при помощи структурной индукции на опре-
делении ветвлящегося процесса. Утверждение леммы очевидно выполняется для началь-
ного ветвлящегося процесса.

Пусть утверждение выполняется для θ, а θ1 – расширение θ, полученной применени-
ем одного из правил возможных расширений. Пусть C – множество новых добавленных
позиций, помеченных позициями системной сети. Можно заметить, что все элементы C
помечены разными сетевыми фишками. Следовательно, для доказательства леммы тре-
буется показать что @(A, pi, ηk) P θ, @(B, pj, ηk) P C, (cid:32)((A, pi, ηk) co (B, pj, ηk)).

Правило PosEN не вводит новых позиций, помеченных позициями системной сети; в
таком случае множество C пустое. В случае с правилом PosSN можно заметить что суще-
ствует такая позиция (A1, pl, ηk) в θ, что (A1, pl, ηk) P ‚‚(B, pj, ηk), где pj является смежным
к pl, для каждого (B, pj, ηk) из C. По индуктивной гипотезе, (cid:32)((A1, pl, ηk) co (A, pi, ηk)). Сле-
довательно, (cid:32)((A, pi, ηk) co (B, pj, ηk)).

Случай PosSync может быть рассмотрен в таком же виде.

(cid:3)

Поскольку плоские сети Петри являются частным случаем вложенных сетей Петри
(без элементных сетей и синхронизации), то можно сформулировать и доказать следующее
свойство, которое является в своем роде “sanity check”, проверяющим то что определение
элементно-индексированных ветвящихся процессов определенно верно для плоских сетей
Петри.

32

Утверждение 3.2.
Пусть N – безопасная сеть Петри. Множество ветвящихся процессов N изоморфно
множество элементно-индексированных ветвящихся процессов N, рассмотренной как
вложенная сеть Петри.

Доказательство. Единственное возможное правило, которое может быть применено при
построении элементно-индексированного ветвлящегося процесса, в данном случае явля-
ется PosSN. Можно заметить, что в случае отсутствия сетевых фишек, правило PosSN
совпадает с правилом возможных расширений для ветвящихся процессов сетей низкого
(cid:3)
уровня.

Таким образом, можно расширить определение префиксного отношения Ď, охватывая
ветвящиеся процессы вложенных сетей Петри. Развертка (обозначается U(NP)) вложенной
сети Петри NP в таком случае определяется как Ď-максимальный ветвящийся процесс NP.
Благодаря этому можно сформулировать фундаментальное свойство разверток, кото-

рое выполняется для вложенных сетей Петри.

Теорема 3.2.
Пусть M – достижимая маркировка NP и MU – достижимая маркировка U(NP), такая
что ˜h(MU) = M

1. Если MU

tUÝÑ M1
M1 и h(tU) = t.

U в U(NP), то существует шаг M tÝÑ M1 в NP, такой что ˜h(M1

U) =

2. Если M tÝÑ M1 в NP, то существует шаг MU

M1 и h(tU) = t.

tUÝÑ M1

U в U(NP), такой что ˜h(M1

U) =

В следующей главе будет рассмотрено применение базового алгоритма для построения
конечных префиксов разверток вложенных сетей Петри на базе теории контекста среза-
ния, а также применение конечных префиксов вложенных сетей Петри для верификации
поведенческих свойств NP-сетей.

33

4 Верификация с помощью разверток

В данной главе будет рассмотрено применение разверток сетей для верификации раз-
личных свойств вложенных сетей Петри. Основная идея такого подхода к верификации
заключается в использовании конечных префиксов разверток, которые не представляют
поведение оригинальной сети полностью, насколько его представляет сама развертка, но
которые сохраняют необходимые для верификации свойства. В начале главы будут пред-
ставлены необходимые определения и небольшая теоретическая база. Далее будут рас-
смотрены алгоритмы, позволяющие строить необходимые конечные префиксы. Материал
этой главы основан на исследованиях теории канонических префиксов [19, 17].

В случаях когда система имеет бесконечные исполнения развертка является неогра-
ниченной и, следовательно, не может применяться для верификации. Для анализа пове-
денческих свойств таким образом используются конечные префиксы развертки, которые
сохраняют достаточную информацию для корректного анализа оригинальной системы.
Основной характеристикой существующих алгоритмов генерация конечных префиксов
является концепция событий-отсечек (cut-oﬀ events), после которых информация в раз-
вертке начинает повторяться. Именно после таких событий развертку можно сокращать
до префикса. В теории канонических префиксов понятие событие-отсечки является неза-
висимым от алгоритма и, следовательно, применимо почти к любому существующему
алгоритму. Какое событие является отсечкой, а какое – нет, определяется по контексту
срезания, которые определяет какое количество информации оставить в префиксе раз-
вертки. В данном тексте в качестве базового алгоритма рассмотрен алгоритм ERV [11],
а точнее его обобщение с использованием теории канонических префиксов и контекстов
срезания.

Благодаря результатам предыдущей главы, вся теория о канонических префиксах мо-
жет применяться к консервативным вложенным сетям Петри практически без изменений.

4.1 Канонические префиксы разверток

Для начала, вспомним определение конфигурации (1.3): бесконфликтное множество вер-
шин, замкнутое относительно ă. Для ветвлящегося процесса B множества конечных и
локальных конфигураций обозначаются CB
loc. Верхний индекс опускается, если B
является разверткой.

f in и CB

Для каждой конфигурации C определяется срез:

34

ď

ePC

ď

ePC

‚e)

e‚)z(

Cut(C) = (

Срез определяет достижимое состояние ветвлящегося процесса, и, соответственно, до-

стижимое состояние оригинальной сети Петри: Mark(C) = ˜h(Cut(C)).

Главным понятием при определение канонических префиксов является контекст сре-

зания (cutting context).

Определение 4.1.
Контекст срезания (cutting context) – это тройка κ = («,Ÿ,tCeuePE), где

1. « – отношение эквивалентности на C f in.
2. Ÿ – строгий, фундированный порядок на C f in, улучшающий Ă (т.е. если C Ă C1, то

C Ÿ C1). Такой порядок называется адекватным.

3. « и Ÿ сохраняют конечные расширения, т.е. если C1,C2 P C f in, C1 « C2 и E1 –

конечный суффикс C1, то существует такой суффикс E2, что

• C1 ‘ E1 « C2 ‘ E2
• Если C2 Ÿ C1, то C2 ‘ E2 Ÿ C1 ‘ E1

4. tCeuePE – семейство конфигураций для каждого перехода из развертки.
Условно говоря, « определяет уровень информации, который должен оставаться в ка-
ноническом префиксе: в префиксе должны присутствовать элементы из каждого класса
эквивалентности, заданного «. В изначальном алгоритме МакМиллана две конфигурации
C1 « C2 если они представляли собой одни и те же маркировки Mark(C1) = Mark(C2).
Однако, в некоторых случаях такая информация может быть избыточной. Например, нас
может интересовать равенство маркировок с точностью до симметрии, или равенство мар-
кировок какой-либо элементной сети.

Отношение Ÿ на конфигурации имеет техническое значение: именно в этом порядке
будут выбираться кандидаты для событий-отсечек (cut-oﬀ событий). В результате, все Ÿ-
минимальные конфигурации в каждом из классов эквивалентности « будут сохранены.
МакМиллан в качестве адекватного порядка использовал порядок размера: C1 Ÿ C2 ðñ
|C1| ă |C2|.

Последний параметр контекста срезания определяет конфигурации, которые будут рас-
сматриваться для поиска событий-отсечек. Обычно рассматриваются только локальные
конфигурации, и в качестве этого параметра выступает tClocuePE.

35

Для простоты, пишут e Ÿ e1 если res Ÿ re1s.
Далее определяется понятие полноты префикса.

Определение 4.2.
Ветвящийся B называется полным по отношение к множеству событий-отсечек (cut-
oﬀ событий) Ecut, если:

1. Для каждого C P C f in существует C1 P CB
2. Если C P CB
f in такой что C X Ecut = H, а e – событие, такое что C ‘ teu P C f in, то
C ‘ teu P CB
f in.

f in, такой что C1 X Ecut = H и C « C1;

Ветвящийся процесс называется полным, если он полный по отношению к какому-

нибудь множеству событий-отсечек.

Первое условие говорит о том, что все классы эквивалентности « должны быть пред-
ставлены в полном ветвящемся процессе. Второе условие утверждает что все не отрезан-
ные конечные конфигурации в полном ветвящемся процессе должны быть продолжены,
если такое возможно.

Далее приводится алгоритмо-независимое определение событий-отсечек (cut-oﬀ собы-

тий).

Определение 4.3.
Для заданного контекста срезания κ множество возможных (feasible) событий, обозна-
чающееся fsbleκ, и множество событий-отсечек, обозначающееся cut κ, определяются
следующим образом:

• Событие e принадлежит fsbleκ, если (reszteu) X cut κ = H.
• Событие e принадлежит cut κ, если e P fsbleκ и существует такая конфигурация
C P Ce что C Ď fsbleκzcut κ, C « res, C Ÿ res. Конфигурация C удовлетворяющая
таким условиям называется соответствующей событию e.

Поскольку возможные (feasible) события и события-отсечки (cut-oﬀ) определяются
друг через друга, может возникнуть впечатление, что такое определение является цик-
личным. Однако, надо заметить, что в определениях используются только предыдущие
(по отношению к ă и Ÿ события). Корректность такого определения гарантируется с по-
мощью Нётеровой индукции, которая в свою очередь обеспечивается фундированостью Ÿ
и следующим свойством:

36

Утверждение 4.1.
Пусть e, e1 – события, а C P C f in.

1. Если e ă e1, то e Ÿ e1.
2. Если e P C Ÿ re1s, то e Ÿ e1.

Также хочется заметить, что в стандартном случае, когда третий компонент контекста
срезания определяется как tClocuePE, определение событий-отсечек принимает следующий
вид: событие e принадлежит cut κ, если e P fsbleκ и существует такое событие e1 P fsbleκ,
что re1s « res и e1 Ÿ e.

После определения возможных и событий-отсечек, естественным образом возникает
определение канонического префикса развертки: канонические префикс Bκ развертки U(N)
– это префикс, содержащий только возможные события fsbleκ и смежные к ним позиции.
Таким образом, канонический префикс задан однозначно для контекста срезания κ. Важ-
ным свойством канонического префикса является его полнота:

Теорема 4.1.
Bκ полон по отношению к множеству событий cut κ.

Также для канонического префикса выполняется условие конечности:

Теорема 4.2.
Bκ является конечным только в том случае, если в fsbleκ не существует бесконечной
ă-цепочки.

4.2 Алгоритм генерации канонического префикса

В этом разделе приводится алгоритм построения конечного префикса разверток для NP-
сетей. Этот алгоритм является модификацией ERV-алгоритма [11]. Алгоритм приведен на
рис. 19. Этот алгоритм будем называть базовым.

Базовый алгоритм почти не отличается от алгоритма, приведенного в [17]. Алгоритм
из [17] является модификацией ERV-алгоритма, но если оригинальный ERV-алгоритм ис-
пользовал конкретное определение событий-отсечек, то алгоритм из [17] использует обоб-
щенное алгоритмнонезависимое понятия события-отсечки, основанное на теории о канони-
ческих префиксов, которая была приведена в прошлой секции. Наш алгоритм отличается
функцией возможных расширений PotExt. В нашем случае процедура PotExt возвращает
все возможные расширения ветвящегося процесса в соответствии с правилами из опреде-
лен. 3.2.

37

Корректность алгоритма. В [17] было доказано, что базовый алгоритм строит полные
канонические префиксы для классических сетей Петри. Все наши определения, включая
определения возможного расширения, удовлетворяют всем требованиям, на которых ос-
новано доказательство в [17]. Таким образом, оригинальное доказательство может быть
использовано дословно для доказательства корректности базового алгоритма.

Примеры верификации. В качестве примера рассмотрим канонический префикс для
сети NP2 (рис. 13 и 14). В качестве контекста срезания возьмем контекст срезания Мак-
Миллана (C1 « C2 ðñ Mark(C1) = Mark(C2) и C1 Ÿ C2 ðñ |C1| ă |C2|), т.е. наш
префикс будет содержать все возможные достижимые разметки. Результат применения
алгоритма показан на рис. 20.

(q1, N2)

(p2, N2)

(p1, N1)

(q1, N1)

(q2, N2)

k2

(q2, N2)

k2

(q2, N2)

(q1, N2)

tt2, k3u

(p3, N2)

β

(p3, N2)

tt1, k1u

α

(p2, N1)

(q2, N1)

(q2, N1)

k2

Рис. 20: BPc: Ветвящийся процесс NP2

Событие ec (на рис. 20 отмечено зеленым цветом) помечается как событие-отсечка.
Это происходит потому, что конфигурация recs соответствует маркировке, при которой
две сетевые фишки находятся в позициях p2 и p3, причем обе фишки имеют одну и ту же
маркировку tq2u, и при этом в сети существует локальная конфигурация (конфигурация
re1s, где e1 – помеченное фиолетовым цветом на рисунке событие), которая меньше по
размеру и соответствует такой же маркировке.

Полученный канонический префикс BPc позволяет решать проблему выполнимости:
может ли когда-нибудь в будущем в сети выполниться данный переход t. Для этого до-

38

статочно проверить, есть ли в BPc переход помеченный t, поскольку в конечном префиксе
развертки содержаться только те переходы которые могут сработать.

Также с помощью конечных префиксов, используя приведенный выше конекст среза-
ния МакМиллана, можно решить проблему дедлока. В сети есть дедлок в том и только
в том случае, ели в префиксе есть конфигурация не имеющая событий-отсечек, соответ-
ствующая маркировка которой является дедлоком. Пример такой конфигурации показан
на рис. 20 отмеченной оранжевым цветом. Этой конфигурации соответствует маркировка,
в которой две сетевые фишки находятся в позициях p1 и p2, при этом обе сетевые фиш-
ки имеют одну и ту же маркировку q2. Как можно заметить, такая ситуация является
дедлоком.

Приведенный пример показывает, что определенная нами конструкция позволяет про-

верять важные с точки зрения верификации поведенческие свойства системы.

39

1: procedure Unfold(NP)
Pref Ð Пустая сеть
Ź Канонический префикс
Добавить все позиции из начальной маркировке NP в Pref , получив тем самым

2:

3:

начальный ветвящийся процесс NP

Ź Пока существуют возможные расширения ветвящегося

Ź Возможен недетерминизм

Ź Добавить e во множество событий-отсечек, если оно

pe Ð PotExt(Pref )
cut_oﬀ Ð H
while pe (cid:44) H do

процесса

e Ð minŸpe
if res X cut_oﬀ = H then

Pref Ð Pref ‘ teu
pe Ð PotExt(Pref )
if e P cut κ then

таковым является

cut_oﬀ Ð cut_oﬀ Y teu

end if

else

pe Ð pezteu

4:

5:

6:

7:

8:

9:

10:

11:

12:

13:

14:

15:

16:

17:

end if
end while
Pref Ð Pref ‘ cut_oﬀ
return Pref
19:
20: end procedure

18:

Рис. 19: Базовый алгоритм

40

Заключение

В этой работе было представлено конструктивное определение ветвящихся процессов кон-
сервативных вложенных сетей Петри. Развертка NP-сети определяется как максимальный
ветвящийся процесс. Было показано что такое определение развертки является коррект-
ным и полезным поскольку, во-первых, развертка сохраняет поведение сети, во-вторых,
к таким определениям развертки и ветвящихся процессов можно легко, почти без из-
менений, применить теорию канонических префиксов и получить алгоритм построения
конечного префикса развертки, с помощью которого можно проводить анализ вложенной
сети.

В качестве направления дальнейших исследований рассматриваются два пути:

1. Расширение определения развертки на другие подклассы вложенных сетей Петри.

2. Поиск аксиоматического определения развертки, которое позволяет строить разверт-

ку композиционально.

41

Список использованных источников

[1] Marek A. Bednarczyk, Luca Bernardinello, Wies(cid:32)law Paw(cid:32)lowski, and Lucia Pomello.
Modelling mobility with petri hypernets.
In Recent Trends in Algebraic Development
Techniques, volume 3423 of Lecture Notes in Computer Science, pages 28–44. Springer,
2005.

[2] G´erard Boudol, Ilaria Castellani, Matthew Hennessy, Mogens Nielsen, and Glynn Winskel.
Twenty years on: Reﬂections on the CEDISYS project. combining true concurrency
with process algebra.
In Pierpaolo Degano, Rocco Nicola, and Jos´e Meseguer, editors,
Concurrency, Graphs and Models, volume 5065 of Lecture Notes in Computer Science,
pages 757–777. Springer, 2008.

[3] Nina Buchina and Leonid Dworza´nski. The tool for modeling of wireless sensor networks
with nested Petri nets.
In Proceedings of 7th the Spring/Summer Young Researchers’
Colloquium on Software Engineering, SYRCoSE ’13, pages 15–18. Institute for System
Programming of the Russian Academy of Sciences, 2013.

[4] Thomas Chatain and Claude Jard. Complete ﬁnite preﬁxes of symbolic unfoldings of
safe time Petri nets. In Susanna Donatelli and P.S. Thiagarajan, editors, Petri Nets and
Other Models of Concurrency - ICATPN 2006, volume 4024 of Lecture Notes in Computer
Science, pages 125–145. Springer, 2006.

[5] Jean-Michel Couvreur, S´ebastien Grivet, and Denis Poitrenaud. Designing a LTL model-
checker based on unfolding graphs.
In Mogens Nielsen and Dan Simpson, editors,
Application and Theory of Petri Nets 2000, volume 1825 of Lecture Notes in Computer
Science, pages 123–145. Springer, 2000.

[6] Michel Diaz, editor. Petri nets: fundamental models, veriﬁcation and applications. Wiley-

ISTE, 2009. 1-656 pp.

[7] Leonid W. Dworza´nski and Irina A. Lomazova. On compositionality of boundedness and

liveness for nested Petri nets. Fundamenta Informaticae, 120(3):275–293, 2012.

[8] Joost Engelfriet. Branching processes of Petri nets. Acta Informatica, 28(6):575–591, 1991.

42

[9] Javier Esparza. A false history of true concurrency: From Petri to tools. In Proceedings
of the 17th International SPIN Conference on Model Checking Software, SPIN’10, pages
180–186. Springer-Verlag, 2010.

[10] Javier Esparza and Keijo Heljanko. Unfoldings: a partial-order approach to model checking.

Springer, 2008.

[11] Javier Esparza, Stefan R¨omer, and Walter Vogler. An improvement of McMillan’s unfolding
algorithm. In Tiziana Margaria and Bernhard Steﬀen, editors, Tools and Algorithms for
the Construction and Analysis of Systems, volume 1055 of Lecture Notes in Computer
Science, pages 87–106. Springer, 1996.

[12] Javier Esparza and Stefan R¨omer. An unfolding algorithm for synchronous products of
transition systems. In CONCUR’99 Concurrency Theory, volume 1664 of Lecture Notes
in Computer Science, pages 2–20. Springer, 1999.

[13] Kees M. van Hee, Irina A. Lomazova, Olivia Oanea, Alexander Serebrenik, Natalia
In Petri Nets and

Sidorova, and Marc Voorhoeve. Nested nets for adaptive systems.
Other Models of Concurrency-ICATPN 2006, pages 241–260. Springer, 2006.

[14] Keijo Heljanko. Deadlock and reachability checking with ﬁnite complete preﬁxes. Technical
report, Helsinki University of Technology, Laboratory for Theoretical Computer Science,
1999.

[15] Kathrin Hoﬀmann, Hartmut Ehrig, and Till Mossakowski. High-level nets with nets and
rules as tokens. In Gianfranco Ciardo and Philippe Darondeau, editors, Applications and
Theory of Petri Nets 2005, volume 3536 of Lecture Notes in Computer Science, pages
268–288. Springer, 2005.

[16] Kurt Jensen and Lars M. Kristensen. Coloured Petri nets: modelling and validation of

concurrent systems. Springer, 2009. 384 pp.

[17] Victor Khomenko. Model Checking Based on Preﬁxes of Petri Net Unfoldings. Ph.D.

Thesis, School of Computing Science, Newcastle University, 2003.

[18] Victor Khomenko and Maciej Koutny. Branching processes of high-level Petri nets. In
Hubert Garavel and John Hatcliﬀ, editors, Tools and Algorithms for the Construction and
Analysis of Systems, volume 2619 of Lecture Notes in Computer Science, pages 458–472.
Springer, 2003.

43

[19] Victor Khomenko, Maciej Koutny, and Walter Vogler. Canonical preﬁxes of Petri net

unfoldings. Acta Informatica, 40(2):95–118, 2003. ISSN 0001-5903.

[20] Michael K¨ohler and Berndt Farwer. Object nets for mobility. In Jetty Kleijn and Alex
Yakovlev, editors, Petri Nets and Other Models of Concurrency – ICATPN 2007, volume
4546 of Lecture Notes in Computer Science, pages 244–262. Springer, 2007.

[21] Rom Langerak and Ed Brinksma. A complete ﬁnite preﬁx for process algebra. In Nicolas
Halbwachs and Doron Peled, editors, Computer Aided Veriﬁcation, volume 1633 of Lecture
Notes in Computer Science, pages 184–195. Springer, 1999.

[22] Irina A. Lomazova. Nested Petri nets(cid:22)a formalism for speciﬁcation and veriﬁcation of

multi-agent distributed systems. Fundamenta Informaticae, 43(1):195–214, 2000.

[23] Irina A. Lomazova. Modeling dynamic objects in distributed systems with nested Petri

nets. Fundamenta Informaticae, 51(1-2):121–133, 2002.

[24] Irina A. Lomazova. Nested Petri nets for adaptive process modeling. In Pillars of computer

science, pages 460–474. Springer, 2008.

[25] Marco Mascheroni. Generalized hypernets and their semantics.

In Proceedings of the
Fitfh International Workshop on Modelling of Objects, Components and Agents, MOCA,
volume 9, pages 87–106, 2009.

[26] Marco Mascheroni. Hypernets: a Class of Hierarchical Petri Nets. Ph.D. Thesis,
Facolt di Scienze Naturali Fisiche e Naturali, Dipartimento di Informatica Sistemistica
e Comunicazione, Universit`a Degli Studi Di Milano Bicocca, 2010.

[27] Kenneth L. McMillan. Using unfoldings to avoid the state explosion problem in the
veriﬁcation of asynchronous circuits. In Gregor Bochmann and DavidKarl Probst, editors,
Computer Aided Veriﬁcation, volume 663 of Lecture Notes in Computer Science, pages
164–177. Springer, 1993.

[28] Kenneth L. McMillan. A technique of state space search based on unfolding. Form.

Methods Syst. Des., 6(1):45–65, 1995.

[29] Mogens Nielsen, Gordon Plotkin, and Glynn Winskel. Petri nets, event structures and

domains, part I. Theoretical Computer Science, 13(1):85–108, 1981.

44

[30] Carl A. Petri. Kommunikation mit Automaten. Ph.D. Thesis, Institut f¨ur instrumentelle

Mathematik, Bonn, 1962.

[31] Wolfgang Reisig. Understanding Petri Nets - Modeling Techniques, Analysis Methods, Case

Studies. Springer, 2013. 1-230 pp.

[32] Fernando Rosa-Velardo. Petri nets with name creation for transient secure association.

Acta Informatica, 50(7-8):403–436, 2013. ISSN 0001-5903.

[33] R¨udiger Valk. Petri nets as token objects: An introduction to Elementary Object Nets. In
J¨org Desel and Manuel Silva, editors, Application and Theory of Petri Nets 1998, volume
1420 of Lecture Notes in Computer Science, pages 1–24. Springer, 1998.

[34] R¨udiger Valk. Object Petri nets. In J¨org Desel, Wolfgang Reisig, and Grzegorz Rozenberg,
editors, Lectures on Concurrency and Petri Nets, volume 3098 of Lecture Notes in
Computer Science, pages 819–848. Springer, 2004.

[35] Ирина Александровна Ломазова. Вложенные сети Петри: моделирование и анализ
распределенных систем с объектной структурой. Научный Мир, Москва, 2004. 208
pp.

45

